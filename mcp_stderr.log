Wrapper script running...
Set LD_LIBRARY_PATH=/home/adam/repos/vectordb-cli/target/release/lib:/usr/local/cuda-12.8/lib64::/home/adam/Downloads/squashfs-root/usr/lib/:/home/adam/Downloads/squashfs-root/usr/lib32/:/home/adam/Downloads/squashfs-root/usr/lib64/:/home/adam/Downloads/squashfs-root/lib/:/home/adam/Downloads/squashfs-root/lib/i386-linux-gnu/:/home/adam/Downloads/squashfs-root/lib/x86_64-linux-gnu/:/home/adam/Downloads/squashfs-root/lib/aarch64-linux-gnu/:/home/adam/Downloads/squashfs-root/lib32/:/home/adam/Downloads/squashfs-root/lib64/:/usr/local/cuda-12.8/lib64:
Executing: /home/adam/repos/vectordb-cli/target/release/vectordb-mcp
[2m2025-05-01T07:07:38.668628Z[0m [32m INFO[0m [2mvectordb_mcp[0m[2m:[0m Starting vectordb-mcp server...
[2m2025-05-01T07:07:38.668895Z[0m [32m INFO[0m [2mvectordb_mcp[0m[2m:[0m Using configuration: AppConfig { qdrant_url: "http://localhost:6334", onnx_model_path: Some("/home/adam/repos/vectordb-cli/onnx/all-minilm-l6-v2.onnx"), onnx_tokenizer_path: Some("/home/adam/repos/vectordb-cli/onnx"), server_api_key_path: None, repositories: [RepositoryConfig { name: "gitlab", url: "https://gitlab.com/gitlab-org/gitlab.git", local_path: "/home/adam/repos/gitlab", default_branch: "master", tracked_branches: ["master"], remote_name: Some("origin"), last_synced_commits: {"master": "30cd6957e13996b861a3a5f99887adf5605a069f"}, active_branch: Some("master"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["fallback", "go", "javascript", "markdown", "python", "ruby", "typescript", "yaml"]), added_as_local_path: true, target_ref: None }, RepositoryConfig { name: "charts", url: "git@gitlab.com:gitlab-org/charts/gitlab.git", local_path: "/home/adam/repos/charts/", default_branch: "master", tracked_branches: ["master"], remote_name: Some("origin"), last_synced_commits: {"master": "6f1495aa9f0a392d22311ad5573ec19d891157bc"}, active_branch: Some("master"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["fallback", "markdown", "ruby", "yaml"]), added_as_local_path: true, target_ref: None }, RepositoryConfig { name: "langchain", url: "https://github.com/langchain-ai/langchain", local_path: "/home/adam/repos/langchain", default_branch: "master", tracked_branches: ["master"], remote_name: Some("origin"), last_synced_commits: {"f14bcee5250f74504f7fedeec53377befd4aea1f": "f14bcee5250f74504f7fedeec53377befd4aea1f"}, active_branch: Some("f14bcee5250f74504f7fedeec53377befd4aea1f"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["markdown", "python"]), added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "spoon_knife_am3JNg", url: "https://github.com/octocat/Spoon-Knife.git", local_path: "Spoon-Knife", default_branch: "main", tracked_branches: ["main"], remote_name: Some("origin"), last_synced_commits: {"main": "beffdb0def9eed7b1d1569e8fb8230786f122059"}, active_branch: Some("main"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["fallback", "markdown", "python"]), added_as_local_path: true, target_ref: None }, RepositoryConfig { name: "e2e-query-rustbook", url: "https://github.com/rust-lang/book", local_path: "/home/adam/repos/e2e-query-rustbook", default_branch: "main", tracked_branches: ["main"], remote_name: Some("origin"), last_synced_commits: {"main": "d33916341d480caede1d0ae57cbeae23aab23e88"}, active_branch: Some("main"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["fallback", "javascript", "markdown", "rust", "yaml"]), added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "e2e-query-flask", url: "https://github.com/pallets/flask", local_path: "/home/adam/repos/e2e-query-flask", default_branch: "main", tracked_branches: ["main"], remote_name: Some("origin"), last_synced_commits: {"main": "b78b5a210bde49e7e04b62a2a4f453ca10e0048c"}, active_branch: Some("main"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["fallback", "markdown", "python", "yaml"]), added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "e2e-query-gin", url: "https://github.com/gin-gonic/gin", local_path: "/home/adam/repos/e2e-query-gin", default_branch: "master", tracked_branches: ["master"], remote_name: Some("origin"), last_synced_commits: {"master": "67c9d4ee110e9adfe33063ef847dba56717c148a"}, active_branch: Some("master"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["fallback", "go", "markdown", "yaml"]), added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "e2e-query-tsnode", url: "https://github.com/microsoft/TypeScript-Node-Starter", local_path: "/home/adam/repos/e2e-query-tsnode", default_branch: "master", tracked_branches: ["master"], remote_name: Some("origin"), last_synced_commits: {"master": "1e15e8b4bf6136ee181a8d46ccda9d5b3ed4e479"}, active_branch: Some("master"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["fallback", "javascript", "markdown", "typescript", "yaml"]), added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "e2e-query-sinatra", url: "https://github.com/sinatra/sinatra", local_path: "/home/adam/repos/e2e-query-sinatra", default_branch: "main", tracked_branches: ["main"], remote_name: Some("origin"), last_synced_commits: {"main": "91cfb548c9e50a65324a9ce9e4ea5f10cd897027"}, active_branch: Some("main"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["fallback", "markdown", "ruby", "yaml"]), added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "test-git-url-parse-rs", url: "https://github.com/tjtelan/git-url-parse-rs.git", local_path: "/home/adam/repos/test-git-url-parse-rs", default_branch: "main", tracked_branches: ["main"], remote_name: Some("origin"), last_synced_commits: {}, active_branch: Some("main"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: None, added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "docker-moby", url: "https://github.com/moby/moby.git", local_path: "/home/adam/repos/docker-moby", default_branch: "master", tracked_branches: ["master"], remote_name: Some("origin"), last_synced_commits: {}, active_branch: Some("master"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: None, added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "docker-compose", url: "https://github.com/docker/compose.git", local_path: "/home/adam/repos/docker-compose", default_branch: "main", tracked_branches: ["main"], remote_name: Some("origin"), last_synced_commits: {}, active_branch: Some("main"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: None, added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "actix-web", url: "https://github.com/actix/actix-web.git", local_path: "/home/adam/repos/actix-web", default_branch: "master", tracked_branches: ["master"], remote_name: Some("origin"), last_synced_commits: {"master": "e27e1e380692575ce08a3b7cb0825ed029385100"}, active_branch: Some("master"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["rust"]), added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "e2e-query-ripgrep", url: "https://github.com/BurntSushi/ripgrep", local_path: "/home/adam/repos/e2e-query-ripgrep", default_branch: "master", tracked_branches: ["master"], remote_name: Some("origin"), last_synced_commits: {"master": "6dfaec03e830892e787686917509c17860456db1"}, active_branch: Some("master"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["rust"]), added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "polars", url: "https://github.com/pola-rs/polars.git", local_path: "/home/adam/repos/polars", default_branch: "main", tracked_branches: ["main"], remote_name: Some("origin"), last_synced_commits: {}, active_branch: Some("main"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: None, added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "rust-client", url: "https://github.com/qdrant/rust-client", local_path: "/home/adam/repos/rust-client", default_branch: "v1.13.0", tracked_branches: ["v1.13.0"], remote_name: Some("origin"), last_synced_commits: {"v1.13.0": "04ba549171f941f4174a829cea6f24ccc5cee29c"}, active_branch: Some("v1.13.0"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["fallback", "markdown", "rust", "yaml"]), added_as_local_path: false, target_ref: None }, RepositoryConfig { name: "landing_page", url: "https://github.com/qdrant/landing_page.git", local_path: "/home/adam/repos/landing_page", default_branch: "master", tracked_branches: ["master"], remote_name: Some("origin"), last_synced_commits: {"0938fcf2507f8e1e54f18b8e063afc0df75ffd6c": "0938fcf2507f8e1e54f18b8e063afc0df75ffd6c"}, active_branch: Some("0938fcf2507f8e1e54f18b8e063afc0df75ffd6c"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: Some(["javascript", "markdown", "yaml"]), added_as_local_path: false, target_ref: Some("0938fcf2507f8e1e54f18b8e063afc0df75ffd6c") }, RepositoryConfig { name: "tfidf-rs", url: "https://github.com/ferristseng/rust-tfidf.git", local_path: "/home/adam/repos/tfidf-rs", default_branch: "master", tracked_branches: ["master"], remote_name: Some("origin"), last_synced_commits: {}, active_branch: Some("master"), ssh_key_path: None, ssh_key_passphrase: None, indexed_languages: None, added_as_local_path: false, target_ref: None }], active_repository: Some("e2e-query-ripgrep"), repositories_base_path: Some("/home/adam/repos"), indexing: IndexingConfig { max_concurrent_upserts: 32 } }
[2m2025-05-01T07:07:38.670674Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Qdrant connection successful.
[2m2025-05-01T07:07:39.011912Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Embedding handler initialized with type: ONNX
[2m2025-05-01T07:07:39.011939Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Embedding dimension: 384
[2m2025-05-01T07:07:39.011945Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m MCP server reading from stdin and writing to stdout.
[2m2025-05-01T07:07:39.012114Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{"tools":true,"prompts":false,"resources":true,"logging":false,"roots":{"listChanged":false}},"clientInfo":{"name":"cursor-vscode","version":"1.0.0"}},"jsonrpc":"2.0","id":0}
[2m2025-05-01T07:07:39.012203Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"capabilities":{"tools":{"ping":{"annotations":{"idempotentHint":true,"openWorldHint":false,"readOnlyHint":true,"title":"Ping Server"},"description":"Checks if the server is responsive.","inputSchema":{"properties":{},"type":"object"},"name":"ping"},"query":{"annotations":{"destructiveHint":false,"idempotentHint":true,"openWorldHint":false,"readOnlyHint":true,"title":"Query Repository"},"description":"Performs semantic search on an indexed repository.","inputSchema":{"properties":{"branchName":{"description":"Optional branch to query (defaults to active)","type":"string"},"limit":{"description":"Maximum number of results to return","type":"integer"},"queryText":{"description":"The natural language query text","type":"string"},"repositoryName":{"description":"Name of the repository to query","type":"string"}},"required":["repositoryName","queryText","limit"],"type":"object"},"name":"query"},"repository_add":{"annotations":{"destructiveHint":false,"idempotentHint":false,"openWorldHint":true,"readOnlyHint":false,"title":"Add Repository"},"description":"Clones and adds a new Git repository for indexing.","inputSchema":{"properties":{"branch":{"description":"Optional specific branch to checkout","type":"string"},"local_path":{"description":"Optional path to a pre-existing local repository","type":"string"},"name":{"description":"Unique name for the repository","type":"string"},"ssh_key":{"description":"Optional path to SSH private key for cloning","type":"string"},"ssh_passphrase":{"description":"Optional passphrase for the SSH key","type":"string"},"url":{"description":"Remote Git URL (e.g., HTTPS or SSH)","type":"string"}},"required":["name"],"type":"object"},"name":"repository_add"},"repository_list":{"annotations":{"destructiveHint":false,"idempotentHint":true,"openWorldHint":false,"readOnlyHint":true,"title":"List Repositories"},"description":"Lists currently configured repositories.","inputSchema":{"properties":{},"type":"object"},"name":"repository_list"},"repository_remove":{"annotations":{"destructiveHint":true,"idempotentHint":true,"openWorldHint":false,"readOnlyHint":false,"title":"Remove Repository"},"description":"Removes a repository configuration and deletes its data.","inputSchema":{"properties":{"name":{"description":"Name of the repository to remove","type":"string"}},"required":["name"],"type":"object"},"name":"repository_remove"},"repository_sync":{"annotations":{"destructiveHint":false,"idempotentHint":false,"openWorldHint":true,"readOnlyHint":false,"title":"Sync Repository"},"description":"Fetches latest changes, updates local copy, and re-indexes a repository.","inputSchema":{"properties":{"name":{"description":"Name of the repository to sync","type":"string"}},"required":["name"],"type":"object"},"name":"repository_sync"}}},"protocolVersion":"2024-11-05","serverInfo":{"name":"vectordb-mcp","version":"0.1.0"}},"id":0}
[2m2025-05-01T07:07:39.013024Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"notifications/initialized","jsonrpc":"2.0"}
[2m2025-05-01T07:07:39.013032Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "notifications/initialized", params: None, id: None } [3mrequest_id[0m[2m=[0mNone [3mmethod[0m[2m=[0mnotifications/initialized[1m}[0m[2m:[0m [2mvectordb_mcp::server[0m[2m:[0m Received initialized notification
[2m2025-05-01T07:07:39.014195Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/list","jsonrpc":"2.0","id":1}
[2m2025-05-01T07:07:39.014232Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"tools":[{"annotations":{"idempotentHint":true,"openWorldHint":false,"readOnlyHint":true,"title":"Ping Server"},"description":"Checks if the server is responsive.","inputSchema":{"properties":{},"type":"object"},"name":"ping"},{"annotations":{"destructiveHint":false,"idempotentHint":false,"openWorldHint":true,"readOnlyHint":false,"title":"Add Repository"},"description":"Clones and adds a new Git repository for indexing.","inputSchema":{"properties":{"branch":{"description":"Optional specific branch to checkout","type":"string"},"local_path":{"description":"Optional path to a pre-existing local repository","type":"string"},"name":{"description":"Unique name for the repository","type":"string"},"ssh_key":{"description":"Optional path to SSH private key for cloning","type":"string"},"ssh_passphrase":{"description":"Optional passphrase for the SSH key","type":"string"},"url":{"description":"Remote Git URL (e.g., HTTPS or SSH)","type":"string"}},"required":["name"],"type":"object"},"name":"repository_add"},{"annotations":{"destructiveHint":false,"idempotentHint":true,"openWorldHint":false,"readOnlyHint":true,"title":"List Repositories"},"description":"Lists currently configured repositories.","inputSchema":{"properties":{},"type":"object"},"name":"repository_list"},{"annotations":{"destructiveHint":true,"idempotentHint":true,"openWorldHint":false,"readOnlyHint":false,"title":"Remove Repository"},"description":"Removes a repository configuration and deletes its data.","inputSchema":{"properties":{"name":{"description":"Name of the repository to remove","type":"string"}},"required":["name"],"type":"object"},"name":"repository_remove"},{"annotations":{"destructiveHint":false,"idempotentHint":false,"openWorldHint":true,"readOnlyHint":false,"title":"Sync Repository"},"description":"Fetches latest changes, updates local copy, and re-indexes a repository.","inputSchema":{"properties":{"name":{"description":"Name of the repository to sync","type":"string"}},"required":["name"],"type":"object"},"name":"repository_sync"},{"annotations":{"destructiveHint":false,"idempotentHint":true,"openWorldHint":false,"readOnlyHint":true,"title":"Query Repository"},"description":"Performs semantic search on an indexed repository.","inputSchema":{"properties":{"branchName":{"description":"Optional branch to query (defaults to active)","type":"string"},"limit":{"description":"Maximum number of results to return","type":"integer"},"queryText":{"description":"The natural language query text","type":"string"},"repositoryName":{"description":"Name of the repository to query","type":"string"}},"required":["repositoryName","queryText","limit"],"type":"object"},"name":"query"}]},"id":1}
[2m2025-05-01T07:08:04.008539Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"limit":5,"queryText":"Rust example using SPLADE sparse vectors","repositoryName":"landing_page"}},"jsonrpc":"2.0","id":2}
[2m2025-05-01T07:08:04.008647Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("Rust example using SPLADE sparse vectors"), "repositoryName": String("landing_page")}, "name": String("query")}), id: Some(Number(2)) } [3mrequest_id[0m[2m=[0mSome(Number(2)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("Rust example using SPLADE sparse vectors"), "repositoryName": String("landing_page")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "landing_page", query_text: "Rust example using SPLADE sparse vectors", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mlanding_page [3mquery[0m[2m=[0mRust example using SPLADE sparse vectors[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_landing_page [3mbranch[0m[2m=[0m0938fcf2507f8e1e54f18b8e063afc0df75ffd6c [3mlimit[0m[2m=[0m5
[2m2025-05-01T07:08:04.123583Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("Rust example using SPLADE sparse vectors"), "repositoryName": String("landing_page")}, "name": String("query")}), id: Some(Number(2)) } [3mrequest_id[0m[2m=[0mSome(Number(2)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("Rust example using SPLADE sparse vectors"), "repositoryName": String("landing_page")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "landing_page", query_text: "Rust example using SPLADE sparse vectors", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mlanding_page [3mquery[0m[2m=[0mRust example using SPLADE sparse vectors[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Returning query results [3mcount[0m[2m=[0m5
[2m2025-05-01T07:08:04.123647Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"results\": [\n    {\n      \"filePath\": \"qdrant-landing/content/documentation/fastembed/fastembed-splade.md\",\n      \"startLine\": 6,\n      \"endLine\": 7,\n      \"score\": 0.8646239,\n      \"content\": \"# How to Generate Sparse Vectors with SPLADE\"\n    },\n    {\n      \"filePath\": \"qdrant-landing/content/articles/sparse-vectors.md\",\n      \"startLine\": 253,\n      \"endLine\": 254,\n      \"score\": 0.8599025,\n      \"content\": \"SPLADE is not the only method to create sparse vectors.\"\n    },\n    {\n      \"filePath\": \"qdrant-landing/content/articles/sparse-vectors.md\",\n      \"startLine\": 14,\n      \"endLine\": 18,\n      \"score\": 0.85418075,\n      \"content\": \"  - sparse vectors\\n  - SPLADE\\n  - hybrid search\\n  - vector search\"\n    },\n    {\n      \"filePath\": \"qdrant-landing/content/articles/search-as-you-type.md\",\n      \"startLine\": 56,\n      \"endLine\": 57,\n      \"score\": 0.85101104,\n      \"content\": \"Now I have, in the best Rust tradition, a blazingly fast semantic search.\"\n    },\n    {\n      \"filePath\": \"qdrant-landing/content/articles/sparse-vectors.md\",\n      \"startLine\": 88,\n      \"endLine\": 89,\n      \"score\": 0.8505338,\n      \"content\": \"First, let's look at how to create a sparse vector. Then, we'll look at the concepts behind SPLADE.\"\n    }\n  ]\n}","type":"text"}],"isError":false},"id":2}
[2m2025-05-01T07:08:06.822970Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"queryText":"Rust example adding or querying named sparse vectors","limit":5,"repositoryName":"landing_page"}},"jsonrpc":"2.0","id":3}
[2m2025-05-01T07:08:06.832586Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("Rust example adding or querying named sparse vectors"), "repositoryName": String("landing_page")}, "name": String("query")}), id: Some(Number(3)) } [3mrequest_id[0m[2m=[0mSome(Number(3)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("Rust example adding or querying named sparse vectors"), "repositoryName": String("landing_page")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "landing_page", query_text: "Rust example adding or querying named sparse vectors", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mlanding_page [3mquery[0m[2m=[0mRust example adding or querying named sparse vectors[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_landing_page [3mbranch[0m[2m=[0m0938fcf2507f8e1e54f18b8e063afc0df75ffd6c [3mlimit[0m[2m=[0m5
[2m2025-05-01T07:08:06.843377Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("Rust example adding or querying named sparse vectors"), "repositoryName": String("landing_page")}, "name": String("query")}), id: Some(Number(3)) } [3mrequest_id[0m[2m=[0mSome(Number(3)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("Rust example adding or querying named sparse vectors"), "repositoryName": String("landing_page")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "landing_page", query_text: "Rust example adding or querying named sparse vectors", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mlanding_page [3mquery[0m[2m=[0mRust example adding or querying named sparse vectors[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Returning query results [3mcount[0m[2m=[0m5
[2m2025-05-01T07:08:06.843438Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"results\": [\n    {\n      \"filePath\": \"qdrant-landing/content/documentation/examples/mighty.md\",\n      \"startLine\": 11,\n      \"endLine\": 16,\n      \"score\": 0.8632685,\n      \"content\": \"  - vector search\\n  - embeddings\\n  - mighty\\n  - rust\\n  - semantic search\"\n    },\n    {\n      \"filePath\": \"qdrant-landing/content/documentation/concepts/vectors.md\",\n      \"startLine\": 131,\n      \"endLine\": 151,\n      \"score\": 0.8429019,\n      \"content\": \"```rust\\nuse qdrant_client::qdrant::{\\n    CreateCollectionBuilder, SparseVectorParamsBuilder, SparseVectorsConfigBuilder,\\n};\\n\\nuse qdrant_client::Qdrant;\\n\\nlet client = Qdrant::from_url(\\\"http://localhost:6334\\\").build()?;\\n\\nlet mut sparse_vectors_config = SparseVectorsConfigBuilder::default();\\n\\nsparse_vectors_config.add_named_vector_params(\\\"text\\\", SparseVectorParamsBuilder::default());\\n\\nclient\\n    .create_collection(\\n        CreateCollectionBuilder::new(\\\"{collection_name}\\\")\\n            .sparse_vectors_config(sparse_vectors_config),\\n    )\\n    .await?;\\n```\"\n    },\n    {\n      \"filePath\": \"qdrant-landing/content/articles/search-as-you-type.md\",\n      \"startLine\": 137,\n      \"endLine\": 138,\n      \"score\": 0.84248024,\n      \"content\": \"To sum up: Rust is fast, recommend lets us use precomputed embeddings, batch requests are awesome and one can do a semantic search in mere milliseconds.\"\n    },\n    {\n      \"filePath\": \"qdrant-landing/content/documentation/concepts/vectors.md\",\n      \"startLine\": 1673,\n      \"endLine\": 1699,\n      \"score\": 0.838024,\n      \"content\": \"```rust\\nuse qdrant_client::qdrant::{\\n    CreateCollectionBuilder, Datatype, Distance, SparseIndexConfigBuilder,\\n    SparseVectorParamsBuilder, SparseVectorsConfigBuilder, VectorParamsBuilder,\\n};\\n\\nuse qdrant_client::Qdrant;\\n\\nlet client = Qdrant::from_url(\\\"http://localhost:6334\\\").build()?;\\n\\nlet mut sparse_vector_config = SparseVectorsConfigBuilder::default();\\n\\nsparse_vector_config.add_named_vector_params(\\n    \\\"text\\\",\\n    SparseVectorParamsBuilder::default()\\n        .index(SparseIndexConfigBuilder::default().datatype(Datatype::Uint8)),\\n);\\nlet create_collection = CreateCollectionBuilder::new(\\\"{collection_name}\\\")\\n    .sparse_vectors_config(sparse_vector_config)\\n    .vectors_config(\\n        VectorParamsBuilder::new(128, Distance::Cosine)\\n            .datatype(Datatype::Uint8)\\n    );\\n\\nclient.create_collection(create_collection).await?;\\n```\"\n    },\n    {\n      \"filePath\": \"qdrant-landing/content/documentation/concepts/vectors.md\",\n      \"startLine\": 1480,\n      \"endLine\": 1503,\n      \"score\": 0.8363307,\n      \"content\": \"```rust\\nuse qdrant_client::qdrant::{\\n    CreateCollectionBuilder, Datatype, Distance, SparseIndexConfigBuilder, SparseVectorParamsBuilder, SparseVectorsConfigBuilder, VectorParamsBuilder\\n};\\nuse qdrant_client::Qdrant;\\n\\nlet client = Qdrant::from_url(\\\"http://localhost:6334\\\").build()?;\\n\\nlet mut sparse_vector_config = SparseVectorsConfigBuilder::default();\\nsparse_vector_config.add_named_vector_params(\\n    \\\"text\\\",\\n    SparseVectorParamsBuilder::default()\\n        .index(SparseIndexConfigBuilder::default().datatype(Datatype::Float32)),\\n);\\n\\nlet create_collection = CreateCollectionBuilder::new(\\\"{collection_name}\\\")\\n    .sparse_vectors_config(sparse_vector_config)\\n    .vectors_config(\\n        VectorParamsBuilder::new(128, Distance::Cosine).datatype(Datatype::Float16),\\n    );\\n\\nclient.create_collection(create_collection).await?;\\n```\"\n    }\n  ]\n}","type":"text"}],"isError":false},"id":3}
[2m2025-05-01T07:08:09.910991Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"queryText":"Rust PointStruct named sparse vector example","limit":5,"branchName":"v1.13.0","repositoryName":"rust-client"}},"jsonrpc":"2.0","id":4}
[2m2025-05-01T07:08:09.911103Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("Rust PointStruct named sparse vector example"), "repositoryName": String("rust-client")}, "name": String("query")}), id: Some(Number(4)) } [3mrequest_id[0m[2m=[0mSome(Number(4)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("Rust PointStruct named sparse vector example"), "repositoryName": String("rust-client")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "rust-client", query_text: "Rust PointStruct named sparse vector example", limit: 5, branch_name: Some("v1.13.0"), lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mrust-client [3mquery[0m[2m=[0mRust PointStruct named sparse vector example[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_rust-client [3mbranch[0m[2m=[0mv1.13.0 [3mlimit[0m[2m=[0m5
[2m2025-05-01T07:08:09.916305Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("Rust PointStruct named sparse vector example"), "repositoryName": String("rust-client")}, "name": String("query")}), id: Some(Number(4)) } [3mrequest_id[0m[2m=[0mSome(Number(4)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("Rust PointStruct named sparse vector example"), "repositoryName": String("rust-client")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "rust-client", query_text: "Rust PointStruct named sparse vector example", limit: 5, branch_name: Some("v1.13.0"), lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mrust-client [3mquery[0m[2m=[0mRust PointStruct named sparse vector example[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Returning query results [3mcount[0m[2m=[0m5
[2m2025-05-01T07:08:09.916359Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"results\": [\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 1,\n      \"endLine\": 25,\n      \"score\": 0.7646355,\n      \"content\": \"# Qdrant Rust client\\n\\nThe [Qdrant](https://qdrant.tech/) - High-Performance Vector Search at Scale - client for Rust.\\n\\n[![Crates.io][crates-badge]][crates-url]\\n[![docs.rs][docs-badge]][docs-url]\\n[![Apache 2.0 licensed][apache2-badge]][apache2-url]\\n\\n[crates-badge]: https://img.shields.io/crates/v/qdrant-client.svg\\n\\n[crates-url]: https://crates.io/crates/qdrant-client\\n\\n[docs-badge]: https://img.shields.io/docsrs/qdrant-client.svg\\n\\n[docs-url]: https://docs.rs/qdrant-client\\n\\n[apache2-badge]: https://img.shields.io/badge/license-apache2-blue.svg\\n\\n[apache2-url]: https://github.com/qdrant/rust-client/blob/master/LICENSE\\n\\nDocumentation:\\n- Qdrant documentation: <https://qdrant.tech/documentation/>\\n- Crate documentation: <https://docs.rs/qdrant-client>\"\n    },\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 66,\n      \"endLine\": 170,\n      \"score\": 0.7640474,\n      \"content\": \"# Qdrant Rust client\\n\\n## Usage\\n\\n### Making requests\\n\\nAdd necessary dependencies:\\n\\n```bash\\ncargo add qdrant-client anyhow tonic tokio serde-json --features tokio/rt-multi-thread\\n```\\n\\nAdd search example from [`examples/search.rs`](./examples/search.rs) to your `src/main.rs`:\\n\\n```rust\\nuse qdrant_client::qdrant::{\\n    Condition, CreateCollectionBuilder, Distance, Filter, PointStruct, ScalarQuantizationBuilder,\\n    SearchParamsBuilder, SearchPointsBuilder, UpsertPointsBuilder, VectorParamsBuilder,\\n};\\nuse qdrant_client::{Payload, Qdrant, QdrantError};\\n\\n#[tokio::main]\\nasync fn main() -> Result<(), QdrantError> {\\n    // Example of top level client\\n    // You may also use tonic-generated client from `src/qdrant.rs`\\n    let client = Qdrant::from_url(\\\"http://localhost:6334\\\").build()?;\\n\\n    let collections_list = client.list_collections().await?;\\n    dbg!(collections_list);\\n    // collections_list = {\\n    //   \\\"collections\\\": [\\n    //     {\\n    //       \\\"name\\\": \\\"test\\\"\\n    //     }\\n    //   ]\\n    // }\\n\\n    let collection_name = \\\"test\\\";\\n    client.delete_collection(collection_name).await?;\\n\\n    client\\n        .create_collection(\\n            CreateCollectionBuilder::new(collection_name)\\n                .vectors_config(VectorParamsBuilder::new(10, Distance::Cosine))\\n                .quantization_config(ScalarQuantizationBuilder::default()),\\n        )\\n        .await?;\\n\\n    let collection_info = client.collection_info(collection_name).await?;\\n    dbg!(collection_info);\\n\\n    let payload: Payload = serde_json::json!(\\n        {\\n            \\\"foo\\\": \\\"Bar\\\",\\n            \\\"bar\\\": 12,\\n            \\\"baz\\\": {\\n                \\\"qux\\\": \\\"quux\\\"\\n            }\\n        }\\n    )\\n    .try_into()\\n    .unwrap();\\n\\n    let points = vec![PointStruct::new(0, vec![12.; 10], payload)];\\n    client\\n        .upsert_points(UpsertPointsBuilder::new(collection_name, points))\\n        .await?;\\n\\n    let search_result = client\\n        .search_points(\\n            SearchPointsBuilder::new(collection_name, [11.; 10], 10)\\n                .filter(Filter::all([Condition::matches(\\\"bar\\\", 12)]))\\n                .with_payload(true)\\n                .params(SearchParamsBuilder::default().exact(true)),\\n        )\\n        .await?;\\n    dbg!(&search_result);\\n    // search_result = [\\n    //   {\\n    //     \\\"id\\\": 0,\\n    //     \\\"version\\\": 0,\\n    //     \\\"score\\\": 1.0000001,\\n    //     \\\"payload\\\": {\\n    //       \\\"bar\\\": 12,\\n    //       \\\"baz\\\": {\\n    //         \\\"qux\\\": \\\"quux\\\"\\n    //       },\\n    //       \\\"foo\\\": \\\"Bar\\\"\\n    //     }\\n    //   }\\n    // ]\\n\\n    let found_point = search_result.result.into_iter().next().unwrap();\\n    let mut payload = found_point.payload;\\n    let baz_payload = payload.remove(\\\"baz\\\").unwrap().into_json();\\n    println!(\\\"baz: {}\\\", baz_payload);\\n    // baz: {\\\"qux\\\":\\\"quux\\\"}\\n\\n    Ok(())\\n}\\n```\\n\\nOr run the example from this project directly:\\n\\n```bash\\ncargo run --example search\\n```\"\n    },\n    {\n      \"filePath\": \"rustfmt.toml\",\n      \"startLine\": 1,\n      \"endLine\": 6,\n      \"score\": 0.7493968,\n      \"content\": \"# Check https://rust-lang.github.io/rustfmt for more options\\n\\nreorder_imports = true\\nimports_granularity = \\\"Module\\\"\\ngroup_imports = \\\"StdExternalCrate\\\"\"\n    },\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 33,\n      \"endLine\": 38,\n      \"score\": 0.74667346,\n      \"content\": \"# Qdrant Rust client\\n\\n## Examples\\n\\nA list of example snippets can be found [here](https://github.com/qdrant/api-reference/tree/main/snippets/rust)\\n\\nMore examples can be found in the [examples folder](https://github.com/qdrant/rust-client/tree/master/examples)\"\n    },\n    {\n      \"filePath\": \"src/builders/mod.rs\",\n      \"startLine\": 224,\n      \"endLine\": 225,\n      \"score\": 0.74280417,\n      \"content\": \"pub use sparse_vector_builder::SparseVectorBuilder;\"\n    }\n  ]\n}","type":"text"}],"isError":false},"id":4}
[2m2025-05-01T07:08:11.636042Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"branchName":"v1.13.0","repositoryName":"rust-client","limit":5,"queryText":"Rust query named sparse vector fusion example"}},"jsonrpc":"2.0","id":5}
[2m2025-05-01T07:08:11.636101Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("Rust query named sparse vector fusion example"), "repositoryName": String("rust-client")}, "name": String("query")}), id: Some(Number(5)) } [3mrequest_id[0m[2m=[0mSome(Number(5)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("Rust query named sparse vector fusion example"), "repositoryName": String("rust-client")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "rust-client", query_text: "Rust query named sparse vector fusion example", limit: 5, branch_name: Some("v1.13.0"), lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mrust-client [3mquery[0m[2m=[0mRust query named sparse vector fusion example[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_rust-client [3mbranch[0m[2m=[0mv1.13.0 [3mlimit[0m[2m=[0m5
[2m2025-05-01T07:08:11.641058Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("Rust query named sparse vector fusion example"), "repositoryName": String("rust-client")}, "name": String("query")}), id: Some(Number(5)) } [3mrequest_id[0m[2m=[0mSome(Number(5)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("Rust query named sparse vector fusion example"), "repositoryName": String("rust-client")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "rust-client", query_text: "Rust query named sparse vector fusion example", limit: 5, branch_name: Some("v1.13.0"), lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mrust-client [3mquery[0m[2m=[0mRust query named sparse vector fusion example[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Returning query results [3mcount[0m[2m=[0m5
[2m2025-05-01T07:08:11.641106Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"results\": [\n    {\n      \"filePath\": \"rustfmt.toml\",\n      \"startLine\": 1,\n      \"endLine\": 6,\n      \"score\": 0.76752794,\n      \"content\": \"# Check https://rust-lang.github.io/rustfmt for more options\\n\\nreorder_imports = true\\nimports_granularity = \\\"Module\\\"\\ngroup_imports = \\\"StdExternalCrate\\\"\"\n    },\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 1,\n      \"endLine\": 25,\n      \"score\": 0.7671624,\n      \"content\": \"# Qdrant Rust client\\n\\nThe [Qdrant](https://qdrant.tech/) - High-Performance Vector Search at Scale - client for Rust.\\n\\n[![Crates.io][crates-badge]][crates-url]\\n[![docs.rs][docs-badge]][docs-url]\\n[![Apache 2.0 licensed][apache2-badge]][apache2-url]\\n\\n[crates-badge]: https://img.shields.io/crates/v/qdrant-client.svg\\n\\n[crates-url]: https://crates.io/crates/qdrant-client\\n\\n[docs-badge]: https://img.shields.io/docsrs/qdrant-client.svg\\n\\n[docs-url]: https://docs.rs/qdrant-client\\n\\n[apache2-badge]: https://img.shields.io/badge/license-apache2-blue.svg\\n\\n[apache2-url]: https://github.com/qdrant/rust-client/blob/master/LICENSE\\n\\nDocumentation:\\n- Qdrant documentation: <https://qdrant.tech/documentation/>\\n- Crate documentation: <https://docs.rs/qdrant-client>\"\n    },\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 66,\n      \"endLine\": 170,\n      \"score\": 0.7640878,\n      \"content\": \"# Qdrant Rust client\\n\\n## Usage\\n\\n### Making requests\\n\\nAdd necessary dependencies:\\n\\n```bash\\ncargo add qdrant-client anyhow tonic tokio serde-json --features tokio/rt-multi-thread\\n```\\n\\nAdd search example from [`examples/search.rs`](./examples/search.rs) to your `src/main.rs`:\\n\\n```rust\\nuse qdrant_client::qdrant::{\\n    Condition, CreateCollectionBuilder, Distance, Filter, PointStruct, ScalarQuantizationBuilder,\\n    SearchParamsBuilder, SearchPointsBuilder, UpsertPointsBuilder, VectorParamsBuilder,\\n};\\nuse qdrant_client::{Payload, Qdrant, QdrantError};\\n\\n#[tokio::main]\\nasync fn main() -> Result<(), QdrantError> {\\n    // Example of top level client\\n    // You may also use tonic-generated client from `src/qdrant.rs`\\n    let client = Qdrant::from_url(\\\"http://localhost:6334\\\").build()?;\\n\\n    let collections_list = client.list_collections().await?;\\n    dbg!(collections_list);\\n    // collections_list = {\\n    //   \\\"collections\\\": [\\n    //     {\\n    //       \\\"name\\\": \\\"test\\\"\\n    //     }\\n    //   ]\\n    // }\\n\\n    let collection_name = \\\"test\\\";\\n    client.delete_collection(collection_name).await?;\\n\\n    client\\n        .create_collection(\\n            CreateCollectionBuilder::new(collection_name)\\n                .vectors_config(VectorParamsBuilder::new(10, Distance::Cosine))\\n                .quantization_config(ScalarQuantizationBuilder::default()),\\n        )\\n        .await?;\\n\\n    let collection_info = client.collection_info(collection_name).await?;\\n    dbg!(collection_info);\\n\\n    let payload: Payload = serde_json::json!(\\n        {\\n            \\\"foo\\\": \\\"Bar\\\",\\n            \\\"bar\\\": 12,\\n            \\\"baz\\\": {\\n                \\\"qux\\\": \\\"quux\\\"\\n            }\\n        }\\n    )\\n    .try_into()\\n    .unwrap();\\n\\n    let points = vec![PointStruct::new(0, vec![12.; 10], payload)];\\n    client\\n        .upsert_points(UpsertPointsBuilder::new(collection_name, points))\\n        .await?;\\n\\n    let search_result = client\\n        .search_points(\\n            SearchPointsBuilder::new(collection_name, [11.; 10], 10)\\n                .filter(Filter::all([Condition::matches(\\\"bar\\\", 12)]))\\n                .with_payload(true)\\n                .params(SearchParamsBuilder::default().exact(true)),\\n        )\\n        .await?;\\n    dbg!(&search_result);\\n    // search_result = [\\n    //   {\\n    //     \\\"id\\\": 0,\\n    //     \\\"version\\\": 0,\\n    //     \\\"score\\\": 1.0000001,\\n    //     \\\"payload\\\": {\\n    //       \\\"bar\\\": 12,\\n    //       \\\"baz\\\": {\\n    //         \\\"qux\\\": \\\"quux\\\"\\n    //       },\\n    //       \\\"foo\\\": \\\"Bar\\\"\\n    //     }\\n    //   }\\n    // ]\\n\\n    let found_point = search_result.result.into_iter().next().unwrap();\\n    let mut payload = found_point.payload;\\n    let baz_payload = payload.remove(\\\"baz\\\").unwrap().into_json();\\n    println!(\\\"baz: {}\\\", baz_payload);\\n    // baz: {\\\"qux\\\":\\\"quux\\\"}\\n\\n    Ok(())\\n}\\n```\\n\\nOr run the example from this project directly:\\n\\n```bash\\ncargo run --example search\\n```\"\n    },\n    {\n      \"filePath\": \"src/builders/mod.rs\",\n      \"startLine\": 224,\n      \"endLine\": 225,\n      \"score\": 0.76106006,\n      \"content\": \"pub use sparse_vector_builder::SparseVectorBuilder;\"\n    },\n    {\n      \"filePath\": \"src/builders/mod.rs\",\n      \"startLine\": 8,\n      \"endLine\": 9,\n      \"score\": 0.74768513,\n      \"content\": \"pub use sparse_vector_params_builder::SparseVectorParamsBuilder;\"\n    }\n  ]\n}","type":"text"}],"isError":false},"id":5}
[2m2025-05-01T23:23:28.715113Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"repository_list","arguments":{}},"jsonrpc":"2.0","id":6}
[2m2025-05-01T23:23:28.715212Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"repositories\": [\n    {\n      \"name\": \"gitlab\",\n      \"remote\": \"https://gitlab.com/gitlab-org/gitlab.git\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"charts\",\n      \"remote\": \"git@gitlab.com:gitlab-org/charts/gitlab.git\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"langchain\",\n      \"remote\": \"https://github.com/langchain-ai/langchain\",\n      \"branch\": \"f14bcee5250f74504f7fedeec53377befd4aea1f\"\n    },\n    {\n      \"name\": \"spoon_knife_am3JNg\",\n      \"remote\": \"https://github.com/octocat/Spoon-Knife.git\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"e2e-query-rustbook\",\n      \"remote\": \"https://github.com/rust-lang/book\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"e2e-query-flask\",\n      \"remote\": \"https://github.com/pallets/flask\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"e2e-query-gin\",\n      \"remote\": \"https://github.com/gin-gonic/gin\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"e2e-query-tsnode\",\n      \"remote\": \"https://github.com/microsoft/TypeScript-Node-Starter\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"e2e-query-sinatra\",\n      \"remote\": \"https://github.com/sinatra/sinatra\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"test-git-url-parse-rs\",\n      \"remote\": \"https://github.com/tjtelan/git-url-parse-rs.git\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"docker-moby\",\n      \"remote\": \"https://github.com/moby/moby.git\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"docker-compose\",\n      \"remote\": \"https://github.com/docker/compose.git\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"actix-web\",\n      \"remote\": \"https://github.com/actix/actix-web.git\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"e2e-query-ripgrep\",\n      \"remote\": \"https://github.com/BurntSushi/ripgrep\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"polars\",\n      \"remote\": \"https://github.com/pola-rs/polars.git\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"rust-client\",\n      \"remote\": \"https://github.com/qdrant/rust-client\",\n      \"branch\": \"v1.13.0\"\n    },\n    {\n      \"name\": \"landing_page\",\n      \"remote\": \"https://github.com/qdrant/landing_page.git\",\n      \"branch\": \"0938fcf2507f8e1e54f18b8e063afc0df75ffd6c\"\n    },\n    {\n      \"name\": \"tfidf-rs\",\n      \"remote\": \"https://github.com/ferristseng/rust-tfidf.git\",\n      \"branch\": \"master\"\n    }\n  ]\n}","type":"text"}],"isError":false},"id":6}
[2m2025-05-01T23:23:31.434136Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"branchName":"v1.13.0","limit":5,"queryText":"How to implement hybrid search with sparse vectors in Qdrant using the Rust client?","repositoryName":"rust-client"}},"jsonrpc":"2.0","id":7}
[2m2025-05-01T23:23:31.434216Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("How to implement hybrid search with sparse vectors in Qdrant using the Rust client?"), "repositoryName": String("rust-client")}, "name": String("query")}), id: Some(Number(7)) } [3mrequest_id[0m[2m=[0mSome(Number(7)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("How to implement hybrid search with sparse vectors in Qdrant using the Rust client?"), "repositoryName": String("rust-client")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "rust-client", query_text: "How to implement hybrid search with sparse vectors in Qdrant using the Rust client?", limit: 5, branch_name: Some("v1.13.0"), lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mrust-client [3mquery[0m[2m=[0mHow to implement hybrid search with sparse vectors in Qdrant using the Rust client?[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_rust-client [3mbranch[0m[2m=[0mv1.13.0 [3mlimit[0m[2m=[0m5
[2m2025-05-01T23:23:31.448936Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("How to implement hybrid search with sparse vectors in Qdrant using the Rust client?"), "repositoryName": String("rust-client")}, "name": String("query")}), id: Some(Number(7)) } [3mrequest_id[0m[2m=[0mSome(Number(7)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("How to implement hybrid search with sparse vectors in Qdrant using the Rust client?"), "repositoryName": String("rust-client")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "rust-client", query_text: "How to implement hybrid search with sparse vectors in Qdrant using the Rust client?", limit: 5, branch_name: Some("v1.13.0"), lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mrust-client [3mquery[0m[2m=[0mHow to implement hybrid search with sparse vectors in Qdrant using the Rust client?[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Returning query results [3mcount[0m[2m=[0m5
[2m2025-05-01T23:23:31.449016Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"results\": [\n    {\n      \"filePath\": \"Cargo.toml\",\n      \"startLine\": 1,\n      \"endLine\": 50,\n      \"score\": 0.88753724,\n      \"content\": \"[package]\\nname = \\\"qdrant-client\\\"\\nversion = \\\"1.13.0\\\"\\nedition = \\\"2021\\\"\\nauthors = [\\\"Qdrant Team <team@qdrant.com>\\\"]\\ndescription = \\\"Rust client for Qdrant Vector Search Engine\\\"\\ndocumentation = \\\"https://docs.rs/qdrant-client\\\"\\nhomepage = \\\"https://qdrant.tech/\\\"\\nlicense = \\\"Apache-2.0\\\"\\nrepository = \\\"https://github.com/qdrant/rust-client\\\"\\nreadme = \\\"README.md\\\"\\ncategories = [\\\"database\\\", \\\"api-bindings\\\"]\\nkeywords = [\\\"qdrant\\\", \\\"vector-search\\\", \\\"search-engine\\\", \\\"client\\\", \\\"grpc\\\"]\\n\\n[dependencies]\\ntonic = { version = \\\"0.12.3\\\", features = [\\\"tls\\\", \\\"tls-roots\\\", \\\"gzip\\\"] }\\nprost = \\\"0.13.3\\\"\\nprost-types = \\\"0.13.3\\\"\\nanyhow = \\\"1.0.89\\\"\\nserde = { version = \\\"1.0.210\\\", features = [\\\"derive\\\"], optional = true }\\nserde_json = { version = \\\"1.0.128\\\", optional = true }\\nreqwest = { version = \\\"0.12.8\\\", optional = true, default-features = false, features = [\\\"stream\\\", \\\"rustls-tls\\\", \\\"http2\\\"] }\\nfutures = { version = \\\"0.3.31\\\" }\\ntokio = { version = \\\"1.40.0\\\", features = [\\\"rt-multi-thread\\\"] }\\nfutures-util = { version = \\\"0.3.31\\\", optional = true }\\nderive_builder = { version = \\\"0.20.2\\\" }\\nthiserror = \\\"1.0.64\\\"\\nsemver = \\\"1.0.24\\\"\\n\\n[dev-dependencies]\\ntonic-build = { version = \\\"0.12.3\\\", features = [\\\"prost\\\"] }\\n\\n[features]\\ndefault = [\\\"download_snapshots\\\", \\\"serde\\\", \\\"generate-snippets\\\"]\\ndownload_snapshots = [\\\"reqwest\\\", \\\"futures-util\\\"]\\nserde = [\\\"dep:serde\\\", \\\"dep:serde_json\\\"]\\ngenerate-snippets = []\\n\\n[[example]]\\nname = \\\"search\\\"\\nrequired-features = [\\\"serde\\\"]\\n\\n[[example]]\\nname = \\\"deprecated_search\\\"\\nrequired-features = [\\\"serde\\\"]\\n\\n[package.metadata.docs.rs]\\nfeatures = [\\\"download_snapshots\\\", \\\"serde\\\"]\\nno-default-features = true\"\n    },\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 66,\n      \"endLine\": 170,\n      \"score\": 0.86012447,\n      \"content\": \"# Qdrant Rust client\\n\\n## Usage\\n\\n### Making requests\\n\\nAdd necessary dependencies:\\n\\n```bash\\ncargo add qdrant-client anyhow tonic tokio serde-json --features tokio/rt-multi-thread\\n```\\n\\nAdd search example from [`examples/search.rs`](./examples/search.rs) to your `src/main.rs`:\\n\\n```rust\\nuse qdrant_client::qdrant::{\\n    Condition, CreateCollectionBuilder, Distance, Filter, PointStruct, ScalarQuantizationBuilder,\\n    SearchParamsBuilder, SearchPointsBuilder, UpsertPointsBuilder, VectorParamsBuilder,\\n};\\nuse qdrant_client::{Payload, Qdrant, QdrantError};\\n\\n#[tokio::main]\\nasync fn main() -> Result<(), QdrantError> {\\n    // Example of top level client\\n    // You may also use tonic-generated client from `src/qdrant.rs`\\n    let client = Qdrant::from_url(\\\"http://localhost:6334\\\").build()?;\\n\\n    let collections_list = client.list_collections().await?;\\n    dbg!(collections_list);\\n    // collections_list = {\\n    //   \\\"collections\\\": [\\n    //     {\\n    //       \\\"name\\\": \\\"test\\\"\\n    //     }\\n    //   ]\\n    // }\\n\\n    let collection_name = \\\"test\\\";\\n    client.delete_collection(collection_name).await?;\\n\\n    client\\n        .create_collection(\\n            CreateCollectionBuilder::new(collection_name)\\n                .vectors_config(VectorParamsBuilder::new(10, Distance::Cosine))\\n                .quantization_config(ScalarQuantizationBuilder::default()),\\n        )\\n        .await?;\\n\\n    let collection_info = client.collection_info(collection_name).await?;\\n    dbg!(collection_info);\\n\\n    let payload: Payload = serde_json::json!(\\n        {\\n            \\\"foo\\\": \\\"Bar\\\",\\n            \\\"bar\\\": 12,\\n            \\\"baz\\\": {\\n                \\\"qux\\\": \\\"quux\\\"\\n            }\\n        }\\n    )\\n    .try_into()\\n    .unwrap();\\n\\n    let points = vec![PointStruct::new(0, vec![12.; 10], payload)];\\n    client\\n        .upsert_points(UpsertPointsBuilder::new(collection_name, points))\\n        .await?;\\n\\n    let search_result = client\\n        .search_points(\\n            SearchPointsBuilder::new(collection_name, [11.; 10], 10)\\n                .filter(Filter::all([Condition::matches(\\\"bar\\\", 12)]))\\n                .with_payload(true)\\n                .params(SearchParamsBuilder::default().exact(true)),\\n        )\\n        .await?;\\n    dbg!(&search_result);\\n    // search_result = [\\n    //   {\\n    //     \\\"id\\\": 0,\\n    //     \\\"version\\\": 0,\\n    //     \\\"score\\\": 1.0000001,\\n    //     \\\"payload\\\": {\\n    //       \\\"bar\\\": 12,\\n    //       \\\"baz\\\": {\\n    //         \\\"qux\\\": \\\"quux\\\"\\n    //       },\\n    //       \\\"foo\\\": \\\"Bar\\\"\\n    //     }\\n    //   }\\n    // ]\\n\\n    let found_point = search_result.result.into_iter().next().unwrap();\\n    let mut payload = found_point.payload;\\n    let baz_payload = payload.remove(\\\"baz\\\").unwrap().into_json();\\n    println!(\\\"baz: {}\\\", baz_payload);\\n    // baz: {\\\"qux\\\":\\\"quux\\\"}\\n\\n    Ok(())\\n}\\n```\\n\\nOr run the example from this project directly:\\n\\n```bash\\ncargo run --example search\\n```\"\n    },\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 33,\n      \"endLine\": 38,\n      \"score\": 0.8406365,\n      \"content\": \"# Qdrant Rust client\\n\\n## Examples\\n\\nA list of example snippets can be found [here](https://github.com/qdrant/api-reference/tree/main/snippets/rust)\\n\\nMore examples can be found in the [examples folder](https://github.com/qdrant/rust-client/tree/master/examples)\"\n    },\n    {\n      \"filePath\": \"src/qdrant_client/error.rs\",\n      \"startLine\": 6,\n      \"endLine\": 42,\n      \"score\": 0.8401892,\n      \"content\": \"pub enum QdrantError {\\n    /// Qdrant server responded with an error\\n    #[error(\\\"Error in the response: {} {}\\\", .status.code(), .status.message())]\\n    ResponseError {\\n        /// gRPC status code\\n        status: tonic::Status,\\n    },\\n\\n    /// Conversion of a Rust into an API type failed\\n    ///\\n    /// Such error may include trying to convert a sparse vector into a dense vector.\\n    #[error(\\\"Error in conversion: {}\\\", .0)]\\n    ConversionError(String),\\n\\n    /// Invalid Qdrant server URI\\n    #[error(\\\"Invalid URI: {}\\\", .0)]\\n    InvalidUri(#[source] InvalidUri),\\n\\n    /// Snapshot not found\\n    #[error(\\\"No snapshot found for collection: {}\\\", .0)]\\n    NoSnapshotFound(String),\\n\\n    /// Generic IO error\\n    #[error(\\\"IO error: {}\\\", .0)]\\n    Io(#[from] std::io::Error),\\n\\n    /// API request error\\n    #[cfg(feature = \\\"reqwest\\\")]\\n    #[error(\\\"Reqwest error: {}\\\", .0)]\\n    Reqwest(#[from] reqwest::Error),\\n\\n    /// JSON to payload conversion error, only JSON objects are supported\\n    #[cfg(feature = \\\"serde\\\")]\\n    #[error(\\\"JSON cannot be converted to payload, only JSON objects are supported\\\")]\\n    JsonToPayload(serde_json::Value),\\n}\"\n    },\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 170,\n      \"endLine\": 187,\n      \"score\": 0.8380993,\n      \"content\": \"# Qdrant Rust client\\n\\n## Qdrant Cloud\\n\\n[Qdrant Cloud](https://cloud.qdrant.io) is a managed service for Qdrant.\\n\\nThe client needs to be configured properly to access the service.\\n\\n- make sure to use the correct port (6334)\\n- make sure to pass your API KEY\\n\\n```rust\\nuse qdrant_client::Qdrant;\\n\\nlet client = Qdrant::from_url(\\\"http://xxxxxxxxxx.eu-central.aws.cloud.qdrant.io:6334\\\")\\n    // Use an environment variable for the API KEY for example\\n    .api_key(std::env::var(\\\"QDRANT_API_KEY\\\"))\\n    .build()?;\\n```\"\n    }\n  ]\n}","type":"text"}],"isError":false},"id":7}
[2m2025-05-01T23:25:44.826347Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"queryText":"How to implement hybrid search with sparse vectors in Qdrant using the Rust client?","repositoryName":"rust-client","branchName":"v1.13.0","limit":5}},"jsonrpc":"2.0","id":8}
[2m2025-05-01T23:25:44.826418Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("How to implement hybrid search with sparse vectors in Qdrant using the Rust client?"), "repositoryName": String("rust-client")}, "name": String("query")}), id: Some(Number(8)) } [3mrequest_id[0m[2m=[0mSome(Number(8)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("How to implement hybrid search with sparse vectors in Qdrant using the Rust client?"), "repositoryName": String("rust-client")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "rust-client", query_text: "How to implement hybrid search with sparse vectors in Qdrant using the Rust client?", limit: 5, branch_name: Some("v1.13.0"), lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mrust-client [3mquery[0m[2m=[0mHow to implement hybrid search with sparse vectors in Qdrant using the Rust client?[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_rust-client [3mbranch[0m[2m=[0mv1.13.0 [3mlimit[0m[2m=[0m5
[2m2025-05-01T23:25:44.840315Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("How to implement hybrid search with sparse vectors in Qdrant using the Rust client?"), "repositoryName": String("rust-client")}, "name": String("query")}), id: Some(Number(8)) } [3mrequest_id[0m[2m=[0mSome(Number(8)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"branchName": String("v1.13.0"), "limit": Number(5), "queryText": String("How to implement hybrid search with sparse vectors in Qdrant using the Rust client?"), "repositoryName": String("rust-client")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "rust-client", query_text: "How to implement hybrid search with sparse vectors in Qdrant using the Rust client?", limit: 5, branch_name: Some("v1.13.0"), lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mrust-client [3mquery[0m[2m=[0mHow to implement hybrid search with sparse vectors in Qdrant using the Rust client?[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Returning query results [3mcount[0m[2m=[0m5
[2m2025-05-01T23:25:44.840395Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"results\": [\n    {\n      \"filePath\": \"Cargo.toml\",\n      \"startLine\": 1,\n      \"endLine\": 50,\n      \"score\": 0.88753724,\n      \"content\": \"[package]\\nname = \\\"qdrant-client\\\"\\nversion = \\\"1.13.0\\\"\\nedition = \\\"2021\\\"\\nauthors = [\\\"Qdrant Team <team@qdrant.com>\\\"]\\ndescription = \\\"Rust client for Qdrant Vector Search Engine\\\"\\ndocumentation = \\\"https://docs.rs/qdrant-client\\\"\\nhomepage = \\\"https://qdrant.tech/\\\"\\nlicense = \\\"Apache-2.0\\\"\\nrepository = \\\"https://github.com/qdrant/rust-client\\\"\\nreadme = \\\"README.md\\\"\\ncategories = [\\\"database\\\", \\\"api-bindings\\\"]\\nkeywords = [\\\"qdrant\\\", \\\"vector-search\\\", \\\"search-engine\\\", \\\"client\\\", \\\"grpc\\\"]\\n\\n[dependencies]\\ntonic = { version = \\\"0.12.3\\\", features = [\\\"tls\\\", \\\"tls-roots\\\", \\\"gzip\\\"] }\\nprost = \\\"0.13.3\\\"\\nprost-types = \\\"0.13.3\\\"\\nanyhow = \\\"1.0.89\\\"\\nserde = { version = \\\"1.0.210\\\", features = [\\\"derive\\\"], optional = true }\\nserde_json = { version = \\\"1.0.128\\\", optional = true }\\nreqwest = { version = \\\"0.12.8\\\", optional = true, default-features = false, features = [\\\"stream\\\", \\\"rustls-tls\\\", \\\"http2\\\"] }\\nfutures = { version = \\\"0.3.31\\\" }\\ntokio = { version = \\\"1.40.0\\\", features = [\\\"rt-multi-thread\\\"] }\\nfutures-util = { version = \\\"0.3.31\\\", optional = true }\\nderive_builder = { version = \\\"0.20.2\\\" }\\nthiserror = \\\"1.0.64\\\"\\nsemver = \\\"1.0.24\\\"\\n\\n[dev-dependencies]\\ntonic-build = { version = \\\"0.12.3\\\", features = [\\\"prost\\\"] }\\n\\n[features]\\ndefault = [\\\"download_snapshots\\\", \\\"serde\\\", \\\"generate-snippets\\\"]\\ndownload_snapshots = [\\\"reqwest\\\", \\\"futures-util\\\"]\\nserde = [\\\"dep:serde\\\", \\\"dep:serde_json\\\"]\\ngenerate-snippets = []\\n\\n[[example]]\\nname = \\\"search\\\"\\nrequired-features = [\\\"serde\\\"]\\n\\n[[example]]\\nname = \\\"deprecated_search\\\"\\nrequired-features = [\\\"serde\\\"]\\n\\n[package.metadata.docs.rs]\\nfeatures = [\\\"download_snapshots\\\", \\\"serde\\\"]\\nno-default-features = true\"\n    },\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 66,\n      \"endLine\": 170,\n      \"score\": 0.86012447,\n      \"content\": \"# Qdrant Rust client\\n\\n## Usage\\n\\n### Making requests\\n\\nAdd necessary dependencies:\\n\\n```bash\\ncargo add qdrant-client anyhow tonic tokio serde-json --features tokio/rt-multi-thread\\n```\\n\\nAdd search example from [`examples/search.rs`](./examples/search.rs) to your `src/main.rs`:\\n\\n```rust\\nuse qdrant_client::qdrant::{\\n    Condition, CreateCollectionBuilder, Distance, Filter, PointStruct, ScalarQuantizationBuilder,\\n    SearchParamsBuilder, SearchPointsBuilder, UpsertPointsBuilder, VectorParamsBuilder,\\n};\\nuse qdrant_client::{Payload, Qdrant, QdrantError};\\n\\n#[tokio::main]\\nasync fn main() -> Result<(), QdrantError> {\\n    // Example of top level client\\n    // You may also use tonic-generated client from `src/qdrant.rs`\\n    let client = Qdrant::from_url(\\\"http://localhost:6334\\\").build()?;\\n\\n    let collections_list = client.list_collections().await?;\\n    dbg!(collections_list);\\n    // collections_list = {\\n    //   \\\"collections\\\": [\\n    //     {\\n    //       \\\"name\\\": \\\"test\\\"\\n    //     }\\n    //   ]\\n    // }\\n\\n    let collection_name = \\\"test\\\";\\n    client.delete_collection(collection_name).await?;\\n\\n    client\\n        .create_collection(\\n            CreateCollectionBuilder::new(collection_name)\\n                .vectors_config(VectorParamsBuilder::new(10, Distance::Cosine))\\n                .quantization_config(ScalarQuantizationBuilder::default()),\\n        )\\n        .await?;\\n\\n    let collection_info = client.collection_info(collection_name).await?;\\n    dbg!(collection_info);\\n\\n    let payload: Payload = serde_json::json!(\\n        {\\n            \\\"foo\\\": \\\"Bar\\\",\\n            \\\"bar\\\": 12,\\n            \\\"baz\\\": {\\n                \\\"qux\\\": \\\"quux\\\"\\n            }\\n        }\\n    )\\n    .try_into()\\n    .unwrap();\\n\\n    let points = vec![PointStruct::new(0, vec![12.; 10], payload)];\\n    client\\n        .upsert_points(UpsertPointsBuilder::new(collection_name, points))\\n        .await?;\\n\\n    let search_result = client\\n        .search_points(\\n            SearchPointsBuilder::new(collection_name, [11.; 10], 10)\\n                .filter(Filter::all([Condition::matches(\\\"bar\\\", 12)]))\\n                .with_payload(true)\\n                .params(SearchParamsBuilder::default().exact(true)),\\n        )\\n        .await?;\\n    dbg!(&search_result);\\n    // search_result = [\\n    //   {\\n    //     \\\"id\\\": 0,\\n    //     \\\"version\\\": 0,\\n    //     \\\"score\\\": 1.0000001,\\n    //     \\\"payload\\\": {\\n    //       \\\"bar\\\": 12,\\n    //       \\\"baz\\\": {\\n    //         \\\"qux\\\": \\\"quux\\\"\\n    //       },\\n    //       \\\"foo\\\": \\\"Bar\\\"\\n    //     }\\n    //   }\\n    // ]\\n\\n    let found_point = search_result.result.into_iter().next().unwrap();\\n    let mut payload = found_point.payload;\\n    let baz_payload = payload.remove(\\\"baz\\\").unwrap().into_json();\\n    println!(\\\"baz: {}\\\", baz_payload);\\n    // baz: {\\\"qux\\\":\\\"quux\\\"}\\n\\n    Ok(())\\n}\\n```\\n\\nOr run the example from this project directly:\\n\\n```bash\\ncargo run --example search\\n```\"\n    },\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 33,\n      \"endLine\": 38,\n      \"score\": 0.8406365,\n      \"content\": \"# Qdrant Rust client\\n\\n## Examples\\n\\nA list of example snippets can be found [here](https://github.com/qdrant/api-reference/tree/main/snippets/rust)\\n\\nMore examples can be found in the [examples folder](https://github.com/qdrant/rust-client/tree/master/examples)\"\n    },\n    {\n      \"filePath\": \"src/qdrant_client/error.rs\",\n      \"startLine\": 6,\n      \"endLine\": 42,\n      \"score\": 0.8401892,\n      \"content\": \"pub enum QdrantError {\\n    /// Qdrant server responded with an error\\n    #[error(\\\"Error in the response: {} {}\\\", .status.code(), .status.message())]\\n    ResponseError {\\n        /// gRPC status code\\n        status: tonic::Status,\\n    },\\n\\n    /// Conversion of a Rust into an API type failed\\n    ///\\n    /// Such error may include trying to convert a sparse vector into a dense vector.\\n    #[error(\\\"Error in conversion: {}\\\", .0)]\\n    ConversionError(String),\\n\\n    /// Invalid Qdrant server URI\\n    #[error(\\\"Invalid URI: {}\\\", .0)]\\n    InvalidUri(#[source] InvalidUri),\\n\\n    /// Snapshot not found\\n    #[error(\\\"No snapshot found for collection: {}\\\", .0)]\\n    NoSnapshotFound(String),\\n\\n    /// Generic IO error\\n    #[error(\\\"IO error: {}\\\", .0)]\\n    Io(#[from] std::io::Error),\\n\\n    /// API request error\\n    #[cfg(feature = \\\"reqwest\\\")]\\n    #[error(\\\"Reqwest error: {}\\\", .0)]\\n    Reqwest(#[from] reqwest::Error),\\n\\n    /// JSON to payload conversion error, only JSON objects are supported\\n    #[cfg(feature = \\\"serde\\\")]\\n    #[error(\\\"JSON cannot be converted to payload, only JSON objects are supported\\\")]\\n    JsonToPayload(serde_json::Value),\\n}\"\n    },\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 170,\n      \"endLine\": 187,\n      \"score\": 0.8380993,\n      \"content\": \"# Qdrant Rust client\\n\\n## Qdrant Cloud\\n\\n[Qdrant Cloud](https://cloud.qdrant.io) is a managed service for Qdrant.\\n\\nThe client needs to be configured properly to access the service.\\n\\n- make sure to use the correct port (6334)\\n- make sure to pass your API KEY\\n\\n```rust\\nuse qdrant_client::Qdrant;\\n\\nlet client = Qdrant::from_url(\\\"http://xxxxxxxxxx.eu-central.aws.cloud.qdrant.io:6334\\\")\\n    // Use an environment variable for the API KEY for example\\n    .api_key(std::env::var(\\\"QDRANT_API_KEY\\\"))\\n    .build()?;\\n```\"\n    }\n  ]\n}","type":"text"}],"isError":false},"id":8}
[2m2025-05-01T23:37:53.069885Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"limit":3,"queryText":"Qdrant sparse vector hybrid search examples","repositoryName":"landing_page"}},"jsonrpc":"2.0","id":9}
[2m2025-05-01T23:37:53.069945Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(3), "queryText": String("Qdrant sparse vector hybrid search examples"), "repositoryName": String("landing_page")}, "name": String("query")}), id: Some(Number(9)) } [3mrequest_id[0m[2m=[0mSome(Number(9)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(3), "queryText": String("Qdrant sparse vector hybrid search examples"), "repositoryName": String("landing_page")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "landing_page", query_text: "Qdrant sparse vector hybrid search examples", limit: 3, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mlanding_page [3mquery[0m[2m=[0mQdrant sparse vector hybrid search examples[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_landing_page [3mbranch[0m[2m=[0m0938fcf2507f8e1e54f18b8e063afc0df75ffd6c [3mlimit[0m[2m=[0m3
[2m2025-05-01T23:37:53.108214Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(3), "queryText": String("Qdrant sparse vector hybrid search examples"), "repositoryName": String("landing_page")}, "name": String("query")}), id: Some(Number(9)) } [3mrequest_id[0m[2m=[0mSome(Number(9)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(3), "queryText": String("Qdrant sparse vector hybrid search examples"), "repositoryName": String("landing_page")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "landing_page", query_text: "Qdrant sparse vector hybrid search examples", limit: 3, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mlanding_page [3mquery[0m[2m=[0mQdrant sparse vector hybrid search examples[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Returning query results [3mcount[0m[2m=[0m0
[2m2025-05-01T23:37:53.108267Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"results\": []\n}","type":"text"}],"isError":false},"id":9}
[2m2025-05-01T23:37:55.484874Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"repositoryName":"tfidf-rs","queryText":"How to use rust-tfidf to generate sparse vectors for Qdrant?","limit":5}},"jsonrpc":"2.0","id":10}
[2m2025-05-01T23:37:55.484935Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("How to use rust-tfidf to generate sparse vectors for Qdrant?"), "repositoryName": String("tfidf-rs")}, "name": String("query")}), id: Some(Number(10)) } [3mrequest_id[0m[2m=[0mSome(Number(10)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("How to use rust-tfidf to generate sparse vectors for Qdrant?"), "repositoryName": String("tfidf-rs")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "tfidf-rs", query_text: "How to use rust-tfidf to generate sparse vectors for Qdrant?", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mtfidf-rs [3mquery[0m[2m=[0mHow to use rust-tfidf to generate sparse vectors for Qdrant?[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_tfidf-rs [3mbranch[0m[2m=[0mmaster [3mlimit[0m[2m=[0m5
[2m2025-05-01T23:37:55.510850Z[0m [31mERROR[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("How to use rust-tfidf to generate sparse vectors for Qdrant?"), "repositoryName": String("tfidf-rs")}, "name": String("query")}), id: Some(Number(10)) } [3mrequest_id[0m[2m=[0mSome(Number(10)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("How to use rust-tfidf to generate sparse vectors for Qdrant?"), "repositoryName": String("tfidf-rs")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "tfidf-rs", query_text: "How to use rust-tfidf to generate sparse vectors for Qdrant?", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mtfidf-rs [3mquery[0m[2m=[0mHow to use rust-tfidf to generate sparse vectors for Qdrant?[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Core search failed [3merror[0m[2m=[0mQdrant client error: Error in the response: Some requested entity was not found Not found: Collection `repo_tfidf-rs` doesn't exist! [3mcollection[0m[2m=[0mrepo_tfidf-rs
[2m2025-05-01T23:37:55.510896Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"Failed to execute query: Qdrant client error: Error in the response: Some requested entity was not found Not found: Collection `repo_tfidf-rs` doesn't exist!","type":"text"}],"isError":true},"id":10}
[2m2025-05-01T23:39:05.142928Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"repository_list","arguments":{}},"jsonrpc":"2.0","id":11}
[2m2025-05-01T23:39:05.143022Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"repositories\": [\n    {\n      \"name\": \"gitlab\",\n      \"remote\": \"https://gitlab.com/gitlab-org/gitlab.git\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"charts\",\n      \"remote\": \"git@gitlab.com:gitlab-org/charts/gitlab.git\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"langchain\",\n      \"remote\": \"https://github.com/langchain-ai/langchain\",\n      \"branch\": \"f14bcee5250f74504f7fedeec53377befd4aea1f\"\n    },\n    {\n      \"name\": \"spoon_knife_am3JNg\",\n      \"remote\": \"https://github.com/octocat/Spoon-Knife.git\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"e2e-query-rustbook\",\n      \"remote\": \"https://github.com/rust-lang/book\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"e2e-query-flask\",\n      \"remote\": \"https://github.com/pallets/flask\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"e2e-query-gin\",\n      \"remote\": \"https://github.com/gin-gonic/gin\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"e2e-query-tsnode\",\n      \"remote\": \"https://github.com/microsoft/TypeScript-Node-Starter\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"e2e-query-sinatra\",\n      \"remote\": \"https://github.com/sinatra/sinatra\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"test-git-url-parse-rs\",\n      \"remote\": \"https://github.com/tjtelan/git-url-parse-rs.git\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"docker-moby\",\n      \"remote\": \"https://github.com/moby/moby.git\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"docker-compose\",\n      \"remote\": \"https://github.com/docker/compose.git\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"actix-web\",\n      \"remote\": \"https://github.com/actix/actix-web.git\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"e2e-query-ripgrep\",\n      \"remote\": \"https://github.com/BurntSushi/ripgrep\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"polars\",\n      \"remote\": \"https://github.com/pola-rs/polars.git\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"rust-client\",\n      \"remote\": \"https://github.com/qdrant/rust-client\",\n      \"branch\": \"v1.13.0\"\n    },\n    {\n      \"name\": \"landing_page\",\n      \"remote\": \"https://github.com/qdrant/landing_page.git\",\n      \"branch\": \"0938fcf2507f8e1e54f18b8e063afc0df75ffd6c\"\n    },\n    {\n      \"name\": \"tfidf-rs\",\n      \"remote\": \"https://github.com/ferristseng/rust-tfidf.git\",\n      \"branch\": \"master\"\n    }\n  ]\n}","type":"text"}],"isError":false},"id":11}
[2m2025-05-01T23:39:09.323356Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"repositoryName":"tfidf-rs","limit":5,"queryText":"How to use rust-tfidf to generate sparse vectors for Qdrant?"}},"jsonrpc":"2.0","id":12}
[2m2025-05-01T23:39:09.323424Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("How to use rust-tfidf to generate sparse vectors for Qdrant?"), "repositoryName": String("tfidf-rs")}, "name": String("query")}), id: Some(Number(12)) } [3mrequest_id[0m[2m=[0mSome(Number(12)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("How to use rust-tfidf to generate sparse vectors for Qdrant?"), "repositoryName": String("tfidf-rs")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "tfidf-rs", query_text: "How to use rust-tfidf to generate sparse vectors for Qdrant?", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mtfidf-rs [3mquery[0m[2m=[0mHow to use rust-tfidf to generate sparse vectors for Qdrant?[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_tfidf-rs [3mbranch[0m[2m=[0mmaster [3mlimit[0m[2m=[0m5
[2m2025-05-01T23:39:09.335597Z[0m [31mERROR[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("How to use rust-tfidf to generate sparse vectors for Qdrant?"), "repositoryName": String("tfidf-rs")}, "name": String("query")}), id: Some(Number(12)) } [3mrequest_id[0m[2m=[0mSome(Number(12)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("How to use rust-tfidf to generate sparse vectors for Qdrant?"), "repositoryName": String("tfidf-rs")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "tfidf-rs", query_text: "How to use rust-tfidf to generate sparse vectors for Qdrant?", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mtfidf-rs [3mquery[0m[2m=[0mHow to use rust-tfidf to generate sparse vectors for Qdrant?[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Core search failed [3merror[0m[2m=[0mQdrant client error: Error in the response: Some requested entity was not found Not found: Collection `repo_tfidf-rs` doesn't exist! [3mcollection[0m[2m=[0mrepo_tfidf-rs
[2m2025-05-01T23:39:09.335654Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"Failed to execute query: Qdrant client error: Error in the response: Some requested entity was not found Not found: Collection `repo_tfidf-rs` doesn't exist!","type":"text"}],"isError":true},"id":12}
[2m2025-05-01T23:43:48.350346Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"limit":5,"queryText":"entrypoint","repositoryName":"rust-tfidf"}},"jsonrpc":"2.0","id":13}
[2m2025-05-01T23:43:48.350427Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"Repository 'rust-tfidf' not found","type":"text"}],"isError":true},"id":13}
[2m2025-05-01T23:44:12.100820Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"repository_list","arguments":{}},"jsonrpc":"2.0","id":14}
[2m2025-05-01T23:44:12.100902Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"repositories\": [\n    {\n      \"name\": \"gitlab\",\n      \"remote\": \"https://gitlab.com/gitlab-org/gitlab.git\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"charts\",\n      \"remote\": \"git@gitlab.com:gitlab-org/charts/gitlab.git\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"langchain\",\n      \"remote\": \"https://github.com/langchain-ai/langchain\",\n      \"branch\": \"f14bcee5250f74504f7fedeec53377befd4aea1f\"\n    },\n    {\n      \"name\": \"spoon_knife_am3JNg\",\n      \"remote\": \"https://github.com/octocat/Spoon-Knife.git\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"e2e-query-rustbook\",\n      \"remote\": \"https://github.com/rust-lang/book\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"e2e-query-flask\",\n      \"remote\": \"https://github.com/pallets/flask\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"e2e-query-gin\",\n      \"remote\": \"https://github.com/gin-gonic/gin\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"e2e-query-tsnode\",\n      \"remote\": \"https://github.com/microsoft/TypeScript-Node-Starter\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"e2e-query-sinatra\",\n      \"remote\": \"https://github.com/sinatra/sinatra\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"test-git-url-parse-rs\",\n      \"remote\": \"https://github.com/tjtelan/git-url-parse-rs.git\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"docker-moby\",\n      \"remote\": \"https://github.com/moby/moby.git\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"docker-compose\",\n      \"remote\": \"https://github.com/docker/compose.git\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"actix-web\",\n      \"remote\": \"https://github.com/actix/actix-web.git\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"e2e-query-ripgrep\",\n      \"remote\": \"https://github.com/BurntSushi/ripgrep\",\n      \"branch\": \"master\"\n    },\n    {\n      \"name\": \"polars\",\n      \"remote\": \"https://github.com/pola-rs/polars.git\",\n      \"branch\": \"main\"\n    },\n    {\n      \"name\": \"rust-client\",\n      \"remote\": \"https://github.com/qdrant/rust-client\",\n      \"branch\": \"v1.13.0\"\n    },\n    {\n      \"name\": \"landing_page\",\n      \"remote\": \"https://github.com/qdrant/landing_page.git\",\n      \"branch\": \"0938fcf2507f8e1e54f18b8e063afc0df75ffd6c\"\n    },\n    {\n      \"name\": \"tfidf-rs\",\n      \"remote\": \"https://github.com/ferristseng/rust-tfidf.git\",\n      \"branch\": \"master\"\n    }\n  ]\n}","type":"text"}],"isError":false},"id":14}
[2m2025-05-01T23:45:01.890975Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"repository_add","arguments":{"name":"rust-tfidf","branch":"master","url":"https://github.com/ferristseng/rust-tfidf.git"}},"jsonrpc":"2.0","id":15}
[2m2025-05-01T23:45:01.909307Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"branch": String("master"), "name": String("rust-tfidf"), "url": String("https://github.com/ferristseng/rust-tfidf.git")}, "name": String("repository_add")}), id: Some(Number(15)) } [3mrequest_id[0m[2m=[0mSome(Number(15)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "repository_add", arguments: Object {"branch": String("master"), "name": String("rust-tfidf"), "url": String("https://github.com/ferristseng/rust-tfidf.git")} } [3mtool_name[0m[2m=[0mrepository_add[1m}[0m[2m:[0m[1mhandle_repository_add[0m[1m{[0m[3mparams[0m[2m=[0mRepositoryAddParams { name: "rust-tfidf", url: Some("https://github.com/ferristseng/rust-tfidf.git"), local_path: None, branch: Some("master"), ssh_key: None, ssh_passphrase: None, target_ref: None } [3mrepo_name[0m[2m=[0m"rust-tfidf" [3murl[0m[2m=[0mSome("https://github.com/ferristseng/rust-tfidf.git")[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::repository[0m[2m:[0m Successfully added repository and saved config. [3mrepo_name[0m[2m=[0mrust-tfidf
[2m2025-05-01T23:45:01.909339Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"name\": \"rust-tfidf\",\n  \"url\": \"https://github.com/ferristseng/rust-tfidf.git\",\n  \"localPath\": \"/home/adam/repos/rust-tfidf\",\n  \"defaultBranch\": \"master\",\n  \"activeBranch\": \"master\"\n}","type":"text"}],"isError":false},"id":15}
[2m2025-05-01T23:45:14.848194Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"repository_sync","arguments":{"name":"rust-tfidf"}},"jsonrpc":"2.0","id":16}
[2m2025-05-01T23:45:15.421941Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"name": String("rust-tfidf")}, "name": String("repository_sync")}), id: Some(Number(16)) } [3mrequest_id[0m[2m=[0mSome(Number(16)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "repository_sync", arguments: Object {"name": String("rust-tfidf")} } [3mtool_name[0m[2m=[0mrepository_sync[1m}[0m[2m:[0m[1mhandle_repository_sync[0m[1m{[0m[3mparams[0m[2m=[0mRepositorySyncParams { name: "rust-tfidf" } [3mrepo_name[0m[2m=[0mrust-tfidf[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::repository[0m[2m:[0m Sync resulted in status message, no new commit to index. [3mrepo_name[0m[2m=[0mrust-tfidf [3mstatus[0m[2m=[0mBranch master already up-to-date.
[2m2025-05-01T23:45:15.422226Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"name\": \"rust-tfidf\",\n  \"status\": \"Branch master already up-to-date.\",\n  \"commitHash\": \"N/A\"\n}","type":"text"}],"isError":false},"id":16}
[2m2025-05-01T23:45:17.719579Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"limit":5,"queryText":"entrypoint","repositoryName":"rust-tfidf"}},"jsonrpc":"2.0","id":17}
[2m2025-05-01T23:45:17.719661Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("entrypoint"), "repositoryName": String("rust-tfidf")}, "name": String("query")}), id: Some(Number(17)) } [3mrequest_id[0m[2m=[0mSome(Number(17)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("entrypoint"), "repositoryName": String("rust-tfidf")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "rust-tfidf", query_text: "entrypoint", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mrust-tfidf [3mquery[0m[2m=[0mentrypoint[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_rust-tfidf [3mbranch[0m[2m=[0mmaster [3mlimit[0m[2m=[0m5
[2m2025-05-01T23:45:17.732168Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("entrypoint"), "repositoryName": String("rust-tfidf")}, "name": String("query")}), id: Some(Number(17)) } [3mrequest_id[0m[2m=[0mSome(Number(17)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("entrypoint"), "repositoryName": String("rust-tfidf")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "rust-tfidf", query_text: "entrypoint", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mrust-tfidf [3mquery[0m[2m=[0mentrypoint[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Returning query results [3mcount[0m[2m=[0m5
[2m2025-05-01T23:45:17.732236Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"results\": [\n    {\n      \"filePath\": \"src/idf.rs\",\n      \"startLine\": 133,\n      \"endLine\": 142,\n      \"score\": 0.76026875,\n      \"content\": \"fn idf_wiki_example_tests() {\\n  let mut docs = Vec::new();\\n\\n  docs.push(vec![(\\\"this\\\", 1), (\\\"is\\\", 1), (\\\"a\\\", 2), (\\\"sample\\\", 1)]);\\n  docs.push(vec![(\\\"this\\\", 1), (\\\"is\\\", 1), (\\\"another\\\", 2), (\\\"example\\\", 3)]);\\n\\n  assert_eq!(UnaryIdf::idf(\\\"this\\\", docs.iter()), 1f64);\\n  assert_eq!(InverseFrequencyIdf::idf(\\\"this\\\", docs.iter()), 0f64);\\n}\"\n    },\n    {\n      \"filePath\": \"LICENSE-MIT\",\n      \"startLine\": 1,\n      \"endLine\": 26,\n      \"score\": 0.751281,\n      \"content\": \"Copyright (c) 2016 The Rust Project Developers\\n\\nPermission is hereby granted, free of charge, to any\\nperson obtaining a copy of this software and associated\\ndocumentation files (the \\\"Software\\\"), to deal in the\\nSoftware without restriction, including without\\nlimitation the rights to use, copy, modify, merge,\\npublish, distribute, sublicense, and/or sell copies of\\nthe Software, and to permit persons to whom the Software\\nis furnished to do so, subject to the following\\nconditions:\\n\\nThe above copyright notice and this permission notice\\nshall be included in all copies or substantial portions\\nof the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF\\nANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\\nTO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\\nSHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\\nIN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\\nDEALINGS IN THE SOFTWARE.\"\n    },\n    {\n      \"filePath\": \"src/idf.rs\",\n      \"startLine\": 163,\n      \"endLine\": 180,\n      \"score\": 0.750034,\n      \"content\": \"fn idf_wiki_example_tests_btreemap() {\\n  let mut docs: Vec<std::collections::BTreeMap<&'static str, usize>> = Vec::new();\\n\\n  docs.push(\\n    vec![(\\\"this\\\", 1), (\\\"is\\\", 1), (\\\"a\\\", 2), (\\\"sample\\\", 1)]\\n      .into_iter()\\n      .collect(),\\n  );\\n  docs.push(\\n    vec![(\\\"this\\\", 1), (\\\"is\\\", 1), (\\\"another\\\", 2), (\\\"example\\\", 3)]\\n      .into_iter()\\n      .collect(),\\n  );\\n\\n  assert_eq!(UnaryIdf::idf(\\\"this\\\", docs.iter()), 1f64);\\n  assert_eq!(InverseFrequencyIdf::idf(\\\"this\\\", docs.iter()), 0f64);\\n}\"\n    },\n    {\n      \"filePath\": \"src/idf.rs\",\n      \"startLine\": 144,\n      \"endLine\": 161,\n      \"score\": 0.74705136,\n      \"content\": \"fn idf_wiki_example_tests_hashmap() {\\n  let mut docs: Vec<std::collections::HashMap<&'static str, usize>> = Vec::new();\\n\\n  docs.push(\\n    vec![(\\\"this\\\", 1), (\\\"is\\\", 1), (\\\"a\\\", 2), (\\\"sample\\\", 1)]\\n      .into_iter()\\n      .collect(),\\n  );\\n  docs.push(\\n    vec![(\\\"this\\\", 1), (\\\"is\\\", 1), (\\\"another\\\", 2), (\\\"example\\\", 3)]\\n      .into_iter()\\n      .collect(),\\n  );\\n\\n  assert_eq!(UnaryIdf::idf(\\\"this\\\", docs.iter()), 1f64);\\n  assert_eq!(InverseFrequencyIdf::idf(\\\"this\\\", docs.iter()), 0f64);\\n}\"\n    },\n    {\n      \"filePath\": \"AUTHORS\",\n      \"startLine\": 1,\n      \"endLine\": 2,\n      \"score\": 0.7309871,\n      \"content\": \"Ferris Tseng <ferristseng@gmail.com>\"\n    }\n  ]\n}","type":"text"}],"isError":false},"id":17}
[2m2025-05-01T23:46:05.233499Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"repository_sync","arguments":{"name":"landing_page"}},"jsonrpc":"2.0","id":18}
[2m2025-05-01T23:46:05.463862Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"name": String("landing_page")}, "name": String("repository_sync")}), id: Some(Number(18)) } [3mrequest_id[0m[2m=[0mSome(Number(18)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "repository_sync", arguments: Object {"name": String("landing_page")} } [3mtool_name[0m[2m=[0mrepository_sync[1m}[0m[2m:[0m[1mhandle_repository_sync[0m[1m{[0m[3mparams[0m[2m=[0mRepositorySyncParams { name: "landing_page" } [3mrepo_name[0m[2m=[0mlanding_page[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::repository[0m[2m:[0m Sync successful, proceeding to index. [3mrepo_name[0m[2m=[0mlanding_page [3mcommit[0m[2m=[0m0938fcf2507f8e1e54f18b8e063afc0df75ffd6c
[2m2025-05-01T23:46:05.464143Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"name": String("landing_page")}, "name": String("repository_sync")}), id: Some(Number(18)) } [3mrequest_id[0m[2m=[0mSome(Number(18)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "repository_sync", arguments: Object {"name": String("landing_page")} } [3mtool_name[0m[2m=[0mrepository_sync[1m}[0m[2m:[0m[1mhandle_repository_sync[0m[1m{[0m[3mparams[0m[2m=[0mRepositorySyncParams { name: "landing_page" } [3mrepo_name[0m[2m=[0mlanding_page[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::repository[0m[2m:[0m Starting indexing stage. [3mrepo_name[0m[2m=[0mlanding_page [3mcommit[0m[2m=[0m0938fcf2507f8e1e54f18b8e063afc0df75ffd6c
[2m2025-05-01T23:46:05.477205Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"name": String("landing_page")}, "name": String("repository_sync")}), id: Some(Number(18)) } [3mrequest_id[0m[2m=[0mSome(Number(18)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "repository_sync", arguments: Object {"name": String("landing_page")} } [3mtool_name[0m[2m=[0mrepository_sync[1m}[0m[2m:[0m[1mhandle_repository_sync[0m[1m{[0m[3mparams[0m[2m=[0mRepositorySyncParams { name: "landing_page" } [3mrepo_name[0m[2m=[0mlanding_page[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::repository[0m[2m:[0m Found files to index [3mrepo_name[0m[2m=[0mlanding_page [3mcount[0m[2m=[0m4293
[2m2025-05-01T23:46:32.359780Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"name": String("landing_page")}, "name": String("repository_sync")}), id: Some(Number(18)) } [3mrequest_id[0m[2m=[0mSome(Number(18)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "repository_sync", arguments: Object {"name": String("landing_page")} } [3mtool_name[0m[2m=[0mrepository_sync[1m}[0m[2m:[0m[1mhandle_repository_sync[0m[1m{[0m[3mparams[0m[2m=[0mRepositorySyncParams { name: "landing_page" } [3mrepo_name[0m[2m=[0mlanding_page[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::repository[0m[2m:[0m Successfully indexed files. [3mrepo_name[0m[2m=[0mlanding_page [3mcount[0m[2m=[0m19829
[2m2025-05-01T23:46:32.360132Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"name\": \"landing_page\",\n  \"status\": \"Indexed static ref '0938fcf2507f8e1e54f18b8e063afc0df75ffd6c'\",\n  \"commitHash\": \"0938fcf2507f8e1e54f18b8e063afc0df75ffd6c\"\n}","type":"text"}],"isError":false},"id":18}
[2m2025-05-01T23:46:35.196797Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"queryText":"sparse vector hybrid search examples","repositoryName":"landing_page","limit":3}},"jsonrpc":"2.0","id":19}
[2m2025-05-01T23:46:35.196937Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(3), "queryText": String("sparse vector hybrid search examples"), "repositoryName": String("landing_page")}, "name": String("query")}), id: Some(Number(19)) } [3mrequest_id[0m[2m=[0mSome(Number(19)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(3), "queryText": String("sparse vector hybrid search examples"), "repositoryName": String("landing_page")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "landing_page", query_text: "sparse vector hybrid search examples", limit: 3, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mlanding_page [3mquery[0m[2m=[0msparse vector hybrid search examples[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_landing_page [3mbranch[0m[2m=[0m0938fcf2507f8e1e54f18b8e063afc0df75ffd6c [3mlimit[0m[2m=[0m3
[2m2025-05-01T23:46:35.226720Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(3), "queryText": String("sparse vector hybrid search examples"), "repositoryName": String("landing_page")}, "name": String("query")}), id: Some(Number(19)) } [3mrequest_id[0m[2m=[0mSome(Number(19)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(3), "queryText": String("sparse vector hybrid search examples"), "repositoryName": String("landing_page")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "landing_page", query_text: "sparse vector hybrid search examples", limit: 3, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mlanding_page [3mquery[0m[2m=[0msparse vector hybrid search examples[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Returning query results [3mcount[0m[2m=[0m3
[2m2025-05-01T23:46:35.226772Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"results\": [\n    {\n      \"filePath\": \"qdrant-landing/content/documentation/frameworks/langchain.md\",\n      \"startLine\": 103,\n      \"endLine\": 106,\n      \"score\": 0.92745495,\n      \"content\": \"- Dense Vector Search(Default)\\n- Sparse Vector Search\\n- Hybrid Search\"\n    },\n    {\n      \"filePath\": \"qdrant-landing/content/articles/qdrant-1.8.x.md\",\n      \"startLine\": 56,\n      \"endLine\": 57,\n      \"score\": 0.9223357,\n      \"content\": \"This performance increase can have a dramatic effect on hybrid search implementations. [Read more about how to set this up.](/articles/sparse-vectors/)\"\n    },\n    {\n      \"filePath\": \"qdrant-landing/content/articles/sparse-vectors.md\",\n      \"startLine\": 409,\n      \"endLine\": 410,\n      \"score\": 0.9218087,\n      \"content\": \"## Hybrid search: combining sparse and dense vectors\"\n    }\n  ]\n}","type":"text"}],"isError":false},"id":19}
[2m2025-05-01T23:46:38.233996Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"limit":5,"repositoryName":"rust-tfidf","queryText":"Calculate term frequency or represent documents"}},"jsonrpc":"2.0","id":20}
[2m2025-05-01T23:46:38.234075Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("Calculate term frequency or represent documents"), "repositoryName": String("rust-tfidf")}, "name": String("query")}), id: Some(Number(20)) } [3mrequest_id[0m[2m=[0mSome(Number(20)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("Calculate term frequency or represent documents"), "repositoryName": String("rust-tfidf")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "rust-tfidf", query_text: "Calculate term frequency or represent documents", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mrust-tfidf [3mquery[0m[2m=[0mCalculate term frequency or represent documents[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_rust-tfidf [3mbranch[0m[2m=[0mmaster [3mlimit[0m[2m=[0m5
[2m2025-05-01T23:46:38.238990Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("Calculate term frequency or represent documents"), "repositoryName": String("rust-tfidf")}, "name": String("query")}), id: Some(Number(20)) } [3mrequest_id[0m[2m=[0mSome(Number(20)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("Calculate term frequency or represent documents"), "repositoryName": String("rust-tfidf")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "rust-tfidf", query_text: "Calculate term frequency or represent documents", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mrust-tfidf [3mquery[0m[2m=[0mCalculate term frequency or represent documents[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Returning query results [3mcount[0m[2m=[0m5
[2m2025-05-01T23:46:38.239036Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"results\": [\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 13,\n      \"endLine\": 31,\n      \"score\": 0.86820376,\n      \"content\": \"# Document Types\\n\\nA document is defined as a collection of terms. The documents don't make \\nassumptions about the term types (the terms are not normalized in any way).\\n\\nThese document types are of my design. The terminology isn't standard, but \\nthey are fairly straight forward to understand.\\n\\n  * `NaiveDocument` - A document is 'naive' if it only knows if a term is \\n    contained within it or not, but does not know HOW MANY of the instances \\n    of the term it contains.\\n\\n  * `ProcessedDocument` - A document is 'processed' if it knows how many \\n    instances of each term is contained within it.\\n\\n  * `ExpandableDocument` - A document is 'expandable' if provides a way to \\n    access each term contained within it.\"\n    },\n    {\n      \"filePath\": \"src/prelude.rs\",\n      \"startLine\": 28,\n      \"endLine\": 39,\n      \"score\": 0.8566722,\n      \"content\": \"pub trait ProcessedDocument: Document {\\n  /// Returns the number of times a (non-normalized) term exists\\n  /// within the document.\\n  fn term_frequency<K>(&self, term: K) -> usize\\n  where\\n    K: Borrow<Self::Term>;\\n\\n  /// Returns the term with the highest frequency, or tied for the highest\\n  /// frequency.\\n  fn max(&self) -> Option<&Self::Term>;\\n}\"\n    },\n    {\n      \"filePath\": \"src/prelude.rs\",\n      \"startLine\": 80,\n      \"endLine\": 92,\n      \"score\": 0.85435426,\n      \"content\": \"pub trait Idf<T>\\nwhere\\n  T: NaiveDocument,\\n{\\n  /// Returns the weighted or unweighted inverse document frequency (idf)\\n  /// for a single term within a corpus of documents.\\n  fn idf<'a, I, K>(term: K, docs: I) -> f64\\n  where\\n    I: Iterator<Item = &'a T>,\\n    K: Borrow<T::Term>,\\n    T: 'a;\\n}\"\n    },\n    {\n      \"filePath\": \"README.md\",\n      \"startLine\": 31,\n      \"endLine\": 77,\n      \"score\": 0.8278127,\n      \"content\": \"# Example\\n\\nThe most simple way to calculate the TfIdf of a document is with the default \\nimplementation. Note, the library provides implementation of \\n`ProcessedDocument`, for a `Vec<(T, usize)>`.\\n\\n```rust\\nuse tfidf::{TfIdf, TfIdfDefault};\\n\\nlet mut docs = Vec::new();\\nlet doc1 = vec![(\\\"a\\\", 3), (\\\"b\\\", 2), (\\\"c\\\", 4)];\\nlet doc2 = vec![(\\\"a\\\", 2), (\\\"d\\\", 5)];\\n\\ndocs.push(doc1);\\ndocs.push(doc2);\\n\\nassert_eq!(0f64, TfIdfDefault::tfidf(\\\"a\\\", &docs[0], docs.iter()));\\nassert!(TfIdfDefault::tfidf(\\\"c\\\", &docs[0], docs.iter()) > 0.5);\\n```\\n\\nYou can also roll your own strategies to calculate tf-idf using some strategies\\nincluded in the library. \\n\\n```rust\\nuse tfidf::{TfIdf, ProcessedDocument};\\nuse tfidf::tf::{RawFrequencyTf};\\nuse tfidf::idf::{InverseFrequencySmoothIdf};\\n\\n#[derive(Copy, Clone)] struct MyTfIdfStrategy;\\n\\nimpl<T> TfIdf<T> for MyTfIdfStrategy where T : ProcessedDocument {\\n  type Tf = RawFrequencyTf;\\n  type Idf = InverseFrequencySmoothIdf; \\n}\\n\\nlet mut docs = Vec::new();\\nlet doc1 = vec![(\\\"a\\\", 3), (\\\"b\\\", 2), (\\\"c\\\", 4)];\\nlet doc2 = vec![(\\\"a\\\", 2), (\\\"d\\\", 5)];\\n\\ndocs.push(doc1);\\ndocs.push(doc2);\\n\\nassert!(MyTfIdfStrategy::tfidf(\\\"a\\\", &docs[0], docs.iter()) > 0f64);\\nassert!(MyTfIdfStrategy::tfidf(\\\"c\\\", &docs[0], docs.iter()) > 0f64);\\n```\"\n    },\n    {\n      \"filePath\": \"src/prelude.rs\",\n      \"startLine\": 67,\n      \"endLine\": 77,\n      \"score\": 0.81708944,\n      \"content\": \"pub trait Tf<T>\\nwhere\\n  T: NaiveDocument,\\n{\\n  /// Returns the weighted or unweighted term frequency (tf) for a single\\n  /// term within a document.\\n  fn tf<K>(term: K, doc: &T) -> f64\\n  where\\n    K: Borrow<T::Term>;\\n}\"\n    }\n  ]\n}","type":"text"}],"isError":false},"id":20}
[2m2025-05-01T23:47:57.859491Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"repository_remove","arguments":{"name":"rust-tfidf"}},"jsonrpc":"2.0","id":21}
[2m2025-05-01T23:47:57.865559Z[0m [31mERROR[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"name": String("rust-tfidf")}, "name": String("repository_remove")}), id: Some(Number(21)) } [3mrequest_id[0m[2m=[0mSome(Number(21)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "repository_remove", arguments: Object {"name": String("rust-tfidf")} } [3mtool_name[0m[2m=[0mrepository_remove[1m}[0m[2m:[0m[1mhandle_repository_remove[0m[1m{[0m[3mparams[0m[2m=[0mRepositoryRemoveParams { name: "rust-tfidf" } [3mrepo_name[0m[2m=[0mrust-tfidf[1m}[0m[2m:[0m [2mvectordb_core::repo_helpers::repo_indexing[0m[2m:[0m Path '/home/adam/repos/rust-tfidf' appears to be a system directory. Refusing to delete for safety.
[2m2025-05-01T23:47:57.866013Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"name\": \"rust-tfidf\",\n  \"status\": \"Removed\"\n}","type":"text"}],"isError":false},"id":21}
[2m2025-05-01T23:51:45.442255Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"repository_add","arguments":{"name":"manish-tokenizer","url":"https://github.com/manishmeganathan/tokenizer"}},"jsonrpc":"2.0","id":22}
Cloning into '/home/adam/repos/manish-tokenizer'...
[2m2025-05-01T23:51:46.446288Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"name": String("manish-tokenizer"), "url": String("https://github.com/manishmeganathan/tokenizer")}, "name": String("repository_add")}), id: Some(Number(22)) } [3mrequest_id[0m[2m=[0mSome(Number(22)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "repository_add", arguments: Object {"name": String("manish-tokenizer"), "url": String("https://github.com/manishmeganathan/tokenizer")} } [3mtool_name[0m[2m=[0mrepository_add[1m}[0m[2m:[0m[1mhandle_repository_add[0m[1m{[0m[3mparams[0m[2m=[0mRepositoryAddParams { name: "manish-tokenizer", url: Some("https://github.com/manishmeganathan/tokenizer"), local_path: None, branch: None, ssh_key: None, ssh_passphrase: None, target_ref: None } [3mrepo_name[0m[2m=[0m"manish-tokenizer" [3murl[0m[2m=[0mSome("https://github.com/manishmeganathan/tokenizer")[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::repository[0m[2m:[0m Successfully added repository and saved config. [3mrepo_name[0m[2m=[0mmanish-tokenizer
[2m2025-05-01T23:51:46.446348Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"name\": \"manish-tokenizer\",\n  \"url\": \"https://github.com/manishmeganathan/tokenizer\",\n  \"localPath\": \"/home/adam/repos/manish-tokenizer\",\n  \"defaultBranch\": \"main\",\n  \"activeBranch\": \"main\"\n}","type":"text"}],"isError":false},"id":22}
[2m2025-05-01T23:51:48.880704Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"repository_sync","arguments":{"name":"manish-tokenizer"}},"jsonrpc":"2.0","id":23}
[2m2025-05-01T23:51:49.428087Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"name": String("manish-tokenizer")}, "name": String("repository_sync")}), id: Some(Number(23)) } [3mrequest_id[0m[2m=[0mSome(Number(23)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "repository_sync", arguments: Object {"name": String("manish-tokenizer")} } [3mtool_name[0m[2m=[0mrepository_sync[1m}[0m[2m:[0m[1mhandle_repository_sync[0m[1m{[0m[3mparams[0m[2m=[0mRepositorySyncParams { name: "manish-tokenizer" } [3mrepo_name[0m[2m=[0mmanish-tokenizer[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::repository[0m[2m:[0m Sync resulted in status message, no new commit to index. [3mrepo_name[0m[2m=[0mmanish-tokenizer [3mstatus[0m[2m=[0mBranch main already up-to-date.
[2m2025-05-01T23:51:49.428532Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"name\": \"manish-tokenizer\",\n  \"status\": \"Branch main already up-to-date.\",\n  \"commitHash\": \"N/A\"\n}","type":"text"}],"isError":false},"id":23}
[2m2025-05-01T23:51:51.978479Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Received request [3mrequest[0m[2m=[0m{"method":"tools/call","params":{"name":"query","arguments":{"limit":5,"repositoryName":"manish-tokenizer","queryText":"tokenizer for source code or custom rules"}},"jsonrpc":"2.0","id":24}
[2m2025-05-01T23:51:51.978581Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("tokenizer for source code or custom rules"), "repositoryName": String("manish-tokenizer")}, "name": String("query")}), id: Some(Number(24)) } [3mrequest_id[0m[2m=[0mSome(Number(24)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("tokenizer for source code or custom rules"), "repositoryName": String("manish-tokenizer")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "manish-tokenizer", query_text: "tokenizer for source code or custom rules", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mmanish-tokenizer [3mquery[0m[2m=[0mtokenizer for source code or custom rules[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Preparing query [3mcollection[0m[2m=[0mrepo_manish-tokenizer [3mbranch[0m[2m=[0mmain [3mlimit[0m[2m=[0m5
[2m2025-05-01T23:51:51.991208Z[0m [32m INFO[0m [1mhandle_request[0m[1m{[0m[3mrequest[0m[2m=[0mRequest { jsonrpc: "2.0", method: "tools/call", params: Some(Object {"arguments": Object {"limit": Number(5), "queryText": String("tokenizer for source code or custom rules"), "repositoryName": String("manish-tokenizer")}, "name": String("query")}), id: Some(Number(24)) } [3mrequest_id[0m[2m=[0mSome(Number(24)) [3mmethod[0m[2m=[0mtools/call[1m}[0m[2m:[0m[1mhandle_tools_call[0m[1m{[0m[3mparams[0m[2m=[0mCallToolParams { name: "query", arguments: Object {"limit": Number(5), "queryText": String("tokenizer for source code or custom rules"), "repositoryName": String("manish-tokenizer")} } [3mtool_name[0m[2m=[0mquery[1m}[0m[2m:[0m[1mhandle_query[0m[1m{[0m[3mparams[0m[2m=[0mQueryParams { repository_name: "manish-tokenizer", query_text: "tokenizer for source code or custom rules", limit: 5, branch_name: None, lang: None, entity_type: None } [3mrepo_name[0m[2m=[0mmanish-tokenizer [3mquery[0m[2m=[0mtokenizer for source code or custom rules[1m}[0m[2m:[0m [2mvectordb_mcp::handlers::query[0m[2m:[0m Returning query results [3mcount[0m[2m=[0m0
[2m2025-05-01T23:51:51.991247Z[0m [32m INFO[0m [2mvectordb_mcp::server[0m[2m:[0m Sending response [3mresponse[0m[2m=[0m{"jsonrpc":"2.0","result":{"content":[{"text":"{\n  \"results\": []\n}","type":"text"}],"isError":false},"id":24}
Binary exited with code: 143
