logo

    Qdrant
    Cloud
    Build
    Learn
    API Reference

Log in
Start Free
Getting Started
What is Qdrant?

Local Quickstart
API & SDKs
Qdrant Web UI
User Manual
Concepts

Guides

Tutorials
Vector Search Basics

Advanced Retrieval

Using the Database

Support
FAQ

Release Notes

    Documentation
    Local Quickstart

How to Get Started with Qdrant Locally

In this short example, you will use the Python Client to create a Collection, load data into it and run a basic search query.
Before you start, please make sure Docker is installed and running on your system.
Download and run

First, download the latest Qdrant image from Dockerhub:

docker pull qdrant/qdrant

Then, run the service:

docker run -p 6333:6333 -p 6334:6334 \
    -v "$(pwd)/qdrant_storage:/qdrant/storage:z" \
    qdrant/qdrant

Under the default configuration all data will be stored in the ./qdrant_storage directory. This will also be the only directory that both the Container and the host machine can both see.

Qdrant is now accessible:

    REST API: localhost:6333
    Web UI: localhost:6333/dashboard
    GRPC API: localhost:6334

Initialize the client
python
typescript
rust
java
csharp
go

use qdrant_client::Qdrant;

// The Rust client uses Qdrant's gRPC interface
let client = Qdrant::from_url("http://localhost:6334").build()?;

By default, Qdrant starts with no encryption or authentication . This means anyone with network access to your machine can access your Qdrant container instance. Please read Security carefully for details on how to secure your instance.
Create a collection

You will be storing all of your vector data in a Qdrant collection. Let’s call it test_collection. This collection will be using a dot product distance metric to compare vectors.
python
typescript
rust
java
csharp
go

use qdrant_client::qdrant::{CreateCollectionBuilder, VectorParamsBuilder};

client
    .create_collection(
        CreateCollectionBuilder::new("test_collection")
            .vectors_config(VectorParamsBuilder::new(4, Distance::Dot)),
    )
    .await?;

Add vectors

Let’s now add a few vectors with a payload. Payloads are other data you want to associate with the vector:
python
typescript
rust
java
csharp
go

use qdrant_client::qdrant::{PointStruct, UpsertPointsBuilder};

let points = vec![
    PointStruct::new(1, vec![0.05, 0.61, 0.76, 0.74], [("city", "Berlin".into())]),
    PointStruct::new(2, vec![0.19, 0.81, 0.75, 0.11], [("city", "London".into())]),
    PointStruct::new(3, vec![0.36, 0.55, 0.47, 0.94], [("city", "Moscow".into())]),
    // ..truncated
];

let response = client
    .upsert_points(UpsertPointsBuilder::new("test_collection", points).wait(true))
    .await?;

dbg!(response);

Response:
python
typescript
rust
java
csharp
go

operation_id=0 status=<UpdateStatus.COMPLETED: 'completed'>

Run a query

Let’s ask a basic question - Which of our stored vectors are most similar to the query vector [0.2, 0.1, 0.9, 0.7]?
python
typescript
rust
java
csharp
go

use qdrant_client::qdrant::QueryPointsBuilder;

let search_result = client
    .query(
        QueryPointsBuilder::new("test_collection")
            .query(vec![0.2, 0.1, 0.9, 0.7])
    )
    .await?;

dbg!(search_result);

Response:

[
  {
    "id": 4,
    "version": 0,
    "score": 1.362,
    "payload": null,
    "vector": null
  },
  {
    "id": 1,
    "version": 0,
    "score": 1.273,
    "payload": null,
    "vector": null
  },
  {
    "id": 3,
    "version": 0,
    "score": 1.208,
    "payload": null,
    "vector": null
  }
]

The results are returned in decreasing similarity order. Note that payload and vector data is missing in these results by default. See payload and vector in the result on how to enable it.
Add a filter

We can narrow down the results further by filtering by payload. Let’s find the closest results that include “London”.
python
typescript
rust
java
csharp
go

use qdrant_client::qdrant::{Condition, Filter, QueryPointsBuilder};

let search_result = client
    .query(
        QueryPointsBuilder::new("test_collection")
            .query(vec![0.2, 0.1, 0.9, 0.7])
            .filter(Filter::must([Condition::matches(
                "city",
                "London".to_string(),
            )]))
            .with_payload(true),
    )
    .await?;

dbg!(search_result);

Response:

[
    {
        "id": 2,
        "version": 0,
        "score": 0.871,
        "payload": {
            "city": "London"
        },
        "vector": null
    }
]

To make filtered search fast on real datasets, we highly recommend to create payload indexes!

You have just conducted vector search. You loaded vectors into a database and queried the database with a vector of your own. Qdrant found the closest results and presented you with a similarity score.
Next steps

Now you know how Qdrant works. Getting started with Qdrant Cloud is just as easy. Create an account and use our SaaS completely free. We will take care of infrastructure maintenance and software updates.

To move onto some more complex examples of vector search, read our Tutorials and create your own app with the help of our Examples.

Note: There is another way of running Qdrant locally. If you are a Python developer, we recommend that you try Local Mode in Qdrant Client, as it only takes a few moments to get setup.
Was this page useful?

On this page:

    How to Get Started with Qdrant Locally
        Download and run
        Initialize the client
        Create a collection
        Add vectors
        Run a query
        Add a filter
        Next steps

Edit on Github

    Create an issue

Ready to get started with Qdrant?
Start Free
© 2025 Qdrant. All Rights Reserved
Terms
Privacy Policy
Impressum

We use cookies to learn more about you. At any time you can delete or block cookies through your browser settings.
Learn more
I accept
