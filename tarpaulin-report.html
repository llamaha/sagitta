<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","adam","repos","vectordb-cli","src","bin","onnx_benchmark.rs"],"content":"use anyhow::Result;\nuse clap::{Parser, ValueEnum};\nuse std::path::PathBuf;\nuse std::time::{Duration, Instant};\nuse vectordb_cli::vectordb::provider::onnx::{\n    OnnxEmbeddingProvider,\n};\nuse vectordb_cli::vectordb::provider::EmbeddingProvider;\nuse std::path::Path;\nuse std::env;\nuse vectordb_cli::vectordb::embedding::EmbeddingModel;\n\n/// Command line arguments\n#[derive(Parser, Debug)]\n#[clap(author, version, about = \"Benchmark for ONNX embedding optimizations\")]\nstruct Args {\n    /// Path to ONNX model file\n    #[clap(long, default_value = \"onnx/all-minilm-l12-v2.onnx\")]\n    model_path: String,\n\n    /// Path to tokenizer directory\n    #[clap(long, default_value = \"onnx/minilm_tokenizer\")]\n    tokenizer_path: String,\n\n    /// Number of warmup iterations\n    #[clap(long, default_value = \"3\")]\n    warmup_iterations: usize,\n\n    /// Number of benchmark iterations\n    #[clap(long, default_value = \"10\")]\n    bench_iterations: usize,\n\n    /// Batch sizes to test\n    #[clap(long, default_value = \"1,4,8,16,32\")]\n    batch_sizes: String,\n\n    /// Provider to benchmark\n    #[clap(long, value_enum, default_value = \"basic\")]\n    provider: ProviderType,\n\n    /// Text file with sample inputs (one per line)\n    #[clap(long, default_value = \"samples.txt\")]\n    samples_file: String,\n\n    /// Whether to pre-warm the session pool\n    #[clap(long, default_value = \"true\")]\n    pre_warm: bool,\n\n    /// Whether to use dynamic batching\n    #[clap(long, default_value = \"false\")]\n    dynamic_batching: bool,\n\n    /// Output results in CSV format\n    #[clap(long, default_value = \"false\")]\n    csv: bool,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, Debug, ValueEnum)]\nenum ProviderType {\n    /// Basic ONNX provider\n    Basic,\n}\n\n/// Create sample texts with varying lengths\nfn create_sample_texts() -\u003e Vec\u003cString\u003e {\n    // Short texts\n    let short_texts = vec![\n        \"This is a short text\".to_string(),\n        \"Another short text example\".to_string(),\n        \"Hello, world!\".to_string(),\n        \"ONNX Runtime is fast\".to_string(),\n    ];\n\n    // Medium texts\n    let medium_texts = vec![\n        \"This is a medium length text that should have more tokens than the shorter examples above. It contains multiple sentences to ensure adequate length.\".to_string(),\n        \"Embedding models like MiniLM are designed to produce fixed-length vector representations of text that capture semantic meaning. These vectors can be used for similarity search.\".to_string(),\n        \"The Rust programming language offers memory safety without a garbage collector, making it suitable for performance-critical applications like embedding generation.\".to_string(),\n    ];\n\n    // Long texts\n    let long_texts = vec![\n        \"This is a longer text that will require more tokens to process. It contains multiple sentences and paragraphs to ensure that batch processing logic can be properly tested. Batch processing is an important optimization when working with ONNX models and transformer-based architectures. By grouping multiple inputs together, we can better utilize the parallel processing capabilities of modern hardware. This should have significantly more tokens than the short and medium examples.\".to_string(),\n        \"The ONNX Runtime provides an optimized inference engine for ONNX models. It includes various optimization capabilities such as operator fusion, memory planning, and parallelization across multiple compute resources. When working with embedding models, efficient batching and tokenization are critical for achieving good performance. The RunTime also supports hardware acceleration through CUDA, DirectML, and other platform-specific acceleration technologies. This longer text will require more tokens and serve as a good test case for batching efficiency.\".to_string(),\n    ];\n\n    // Combine all texts\n    let mut all_texts = Vec::new();\n    all_texts.extend(short_texts);\n    all_texts.extend(medium_texts);\n    all_texts.extend(long_texts);\n\n    // Create repeated sets to have sufficient data\n    let mut result = Vec::new();\n    for _ in 0..5 {\n        result.extend(all_texts.clone());\n    }\n\n    result\n}\n\n/// Load sample texts from a file\nfn load_sample_texts(path: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    match std::fs::read_to_string(path) {\n        Ok(content) =\u003e {\n            let lines: Vec\u003cString\u003e = content\n                .lines()\n                .map(|line| line.trim().to_string())\n                .filter(|line| !line.is_empty())\n                .collect();\n\n            if lines.is_empty() {\n                println!(\"Warning: No samples found in file. Using generated samples.\");\n                Ok(create_sample_texts())\n            } else {\n                println!(\"Loaded {} sample texts from {}\", lines.len(), path);\n                Ok(lines)\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"Warning: Failed to load samples file ({}): {}\", path, e);\n            println!(\"Using generated samples instead.\");\n            Ok(create_sample_texts())\n        }\n    }\n}\n\n/// Run benchmark with the basic ONNX provider\nfn benchmark_basic(\n    model_path: \u0026str,\n    tokenizer_path: \u0026str,\n    samples: \u0026[String],\n    batch_size: usize,\n    iterations: usize,\n) -\u003e Result\u003cVec\u003cDuration\u003e\u003e {\n    // Create the provider\n    let model_path = PathBuf::from(model_path);\n    let tokenizer_path = PathBuf::from(tokenizer_path);\n    let provider = OnnxEmbeddingProvider::new(\u0026model_path, \u0026tokenizer_path)?;\n\n    // Prepare batches\n    let mut results = Vec::with_capacity(iterations);\n    for _ in 0..iterations {\n        // Select a random subset of samples for this iteration\n        let batch_start = fastrand::usize(0..samples.len().saturating_sub(batch_size));\n        let batch_texts: Vec\u003c\u0026str\u003e = samples[batch_start..batch_start + batch_size]\n            .iter()\n            .map(|s| s.as_str())\n            .collect();\n\n        // Time the embedding generation\n        let start = Instant::now();\n        let embeddings = provider.embed_batch(\u0026batch_texts)?;\n        let duration = start.elapsed();\n\n        // Verify the embeddings\n        assert_eq!(embeddings.len(), batch_size);\n\n        results.push(duration);\n    }\n\n    Ok(results)\n}\n\n/// Format a duration as milliseconds with 2 decimal places\nfn format_ms(duration: Duration) -\u003e String {\n    let ms = duration.as_secs_f64() * 1000.0;\n    format!(\"{:.2}\", ms)\n}\n\n/// Calculate statistics for a set of durations\nfn calculate_stats(durations: \u0026[Duration]) -\u003e (Duration, Duration, Duration) {\n    let mut sorted = durations.to_vec();\n    sorted.sort();\n\n    let total = sorted.iter().sum::\u003cDuration\u003e();\n    let mean = total / durations.len() as u32;\n\n    let median = if sorted.is_empty() {\n        Duration::from_secs(0)\n    } else if sorted.len() % 2 == 1 {\n        sorted[sorted.len() / 2]\n    } else {\n        (sorted[sorted.len() / 2 - 1] + sorted[sorted.len() / 2]) / 2\n    };\n\n    (mean, median, total)\n}\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Parse arguments\n    let args = Args::parse();\n\n    // Load sample texts\n    let samples = load_sample_texts(\u0026args.samples_file)?;\n    println!(\"Using {} sample texts for benchmarking\", samples.len());\n\n    // Parse batch sizes\n    let batch_sizes: Vec\u003cusize\u003e = args\n        .batch_sizes\n        .split(',')\n        .map(|s| s.trim().parse::\u003cusize\u003e())\n        .collect::\u003cstd::result::Result\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n    // Print configuration\n    println!(\"\\nBenchmark Configuration:\");\n    println!(\"------------------------\");\n    println!(\n        \"Provider:         {}\",\n        match args.provider {\n            ProviderType::Basic =\u003e \"Basic ONNX\",\n        }\n    );\n    println!(\"Model:            {}\", args.model_path);\n    println!(\"Tokenizer:        {}\", args.tokenizer_path);\n    println!(\"Warmup iterations: {}\", args.warmup_iterations);\n    println!(\"Bench iterations:  {}\", args.bench_iterations);\n    println!(\"Batch sizes:       {}\", args.batch_sizes);\n    println!(\"Pre-warm pool:     {}\", args.pre_warm);\n    println!(\"Dynamic batching:  {}\", args.dynamic_batching);\n\n    if args.csv {\n        // CSV header\n        println!(\"\\nprovider,batch_size,mean_ms,median_ms,total_ms,throughput\");\n    } else {\n        println!(\"\\nResults:\");\n        println!(\"--------\");\n    }\n\n    // Run benchmarks for each batch size\n    for batch_size in batch_sizes {\n        if batch_size \u003e samples.len() {\n            println!(\n                \"Warning: Batch size {} exceeds number of samples {}. Skipping.\",\n                batch_size,\n                samples.len()\n            );\n            continue;\n        }\n\n        // Run warmup iterations first\n        println!(\n            \"Running {} warmup iterations with batch size {}...\",\n            args.warmup_iterations, batch_size\n        );\n        let warmup_result = match args.provider {\n            ProviderType::Basic =\u003e benchmark_basic(\n                \u0026args.model_path,\n                \u0026args.tokenizer_path,\n                \u0026samples,\n                batch_size,\n                args.warmup_iterations,\n            ),\n        };\n\n        if warmup_result.is_err() {\n            println!(\"Error during warmup: {:?}\", warmup_result.err());\n            continue;\n        }\n\n        // Run actual benchmark\n        println!(\n            \"Running {} benchmark iterations with batch size {}...\",\n            args.bench_iterations, batch_size\n        );\n        let bench_result = match args.provider {\n            ProviderType::Basic =\u003e benchmark_basic(\n                \u0026args.model_path,\n                \u0026args.tokenizer_path,\n                \u0026samples,\n                batch_size,\n                args.bench_iterations,\n            ),\n        };\n\n        match bench_result {\n            Ok(durations) =\u003e {\n                // Calculate statistics\n                let (mean, median, total) = calculate_stats(\u0026durations);\n                let throughput =\n                    batch_size as f64 * args.bench_iterations as f64 / total.as_secs_f64();\n\n                // Output results\n                if args.csv {\n                    let provider_name = match args.provider {\n                        ProviderType::Basic =\u003e \"basic\",\n                    };\n                    println!(\n                        \"{},{},{},{},{},{:.2}\",\n                        provider_name,\n                        batch_size,\n                        format_ms(mean),\n                        format_ms(median),\n                        format_ms(total),\n                        throughput\n                    );\n                } else {\n                    println!(\"Batch size {}:\", batch_size);\n                    println!(\"  Mean time:   {} ms\", format_ms(mean));\n                    println!(\"  Median time: {} ms\", format_ms(median));\n                    println!(\"  Total time:  {} ms\", format_ms(total));\n                    println!(\"  Throughput:  {:.2} samples/sec\", throughput);\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"Error benchmarking batch size {}: {}\", batch_size, e);\n            }\n        }\n    }\n\n    // --- Create model to get dimension ---\n    let model_path_str = env::var(\"VECTORDB_ONNX_MODEL\")\n        .unwrap_or_else(|_| \"onnx/all-minilm-l12-v2.onnx\".to_string());\n    let tokenizer_path_str = env::var(\"VECTORDB_ONNX_TOKENIZER\")\n        .unwrap_or_else(|_| \"onnx\".to_string());\n\n    let model_path = Path::new(\u0026model_path_str);\n    let tokenizer_path = Path::new(\u0026tokenizer_path_str);\n\n    println!(\n        \"Starting ONNX benchmark with model: {} and tokenizer: {}\",\n        model_path.display(),\n        tokenizer_path.display()\n    );\n\n    let model = EmbeddingModel::new_onnx(model_path, tokenizer_path)?;\n    let embedding_dim = model.dim();\n    println!(\"Detected Embedding Dimension: {}\", embedding_dim);\n\n    Ok(())\n}\n","traces":[{"line":65,"address":[2707689,2707752,2705744],"length":1,"stats":{"Line":0}},{"line":67,"address":[2705834,2705761,2706026,2706247,2705893,2705958,2707781],"length":1,"stats":{"Line":0}},{"line":68,"address":[2705805],"length":1,"stats":{"Line":0}},{"line":69,"address":[2705866],"length":1,"stats":{"Line":0}},{"line":70,"address":[2705931],"length":1,"stats":{"Line":0}},{"line":71,"address":[2705999],"length":1,"stats":{"Line":0}},{"line":75,"address":[2707747,2706314,2706230,2706416,2706357,2706484],"length":1,"stats":{"Line":0}},{"line":76,"address":[2706322],"length":1,"stats":{"Line":0}},{"line":77,"address":[2706389],"length":1,"stats":{"Line":0}},{"line":78,"address":[2706457],"length":1,"stats":{"Line":0}},{"line":82,"address":[2706758,2706860,2706700,2706801,2707720],"length":1,"stats":{"Line":0}},{"line":83,"address":[2706766],"length":1,"stats":{"Line":0}},{"line":84,"address":[2706833],"length":1,"stats":{"Line":0}},{"line":88,"address":[2707042],"length":1,"stats":{"Line":0}},{"line":89,"address":[2707102],"length":1,"stats":{"Line":0}},{"line":90,"address":[2707211],"length":1,"stats":{"Line":0}},{"line":91,"address":[2707285],"length":1,"stats":{"Line":0}},{"line":94,"address":[2707359],"length":1,"stats":{"Line":0}},{"line":95,"address":[2707456,2707378],"length":1,"stats":{"Line":0}},{"line":96,"address":[2707650,2707579],"length":1,"stats":{"Line":0}},{"line":99,"address":[2707537],"length":1,"stats":{"Line":0}},{"line":103,"address":[2708845,2707792],"length":1,"stats":{"Line":0}},{"line":104,"address":[2707819],"length":1,"stats":{"Line":0}},{"line":105,"address":[2707880],"length":1,"stats":{"Line":0}},{"line":106,"address":[2707905,2708103],"length":1,"stats":{"Line":0}},{"line":108,"address":[2789472,2789525],"length":1,"stats":{"Line":0}},{"line":109,"address":[2789568,2789593],"length":1,"stats":{"Line":0}},{"line":112,"address":[2708249,2708793,2708184],"length":1,"stats":{"Line":0}},{"line":113,"address":[2708719,2708276],"length":1,"stats":{"Line":0}},{"line":114,"address":[2708746],"length":1,"stats":{"Line":0}},{"line":116,"address":[2708255,2708310,2708529],"length":1,"stats":{"Line":0}},{"line":117,"address":[2708619],"length":1,"stats":{"Line":0}},{"line":120,"address":[2707925],"length":1,"stats":{"Line":0}},{"line":121,"address":[2709018],"length":1,"stats":{"Line":0}},{"line":122,"address":[2709103],"length":1,"stats":{"Line":0}},{"line":123,"address":[2709156],"length":1,"stats":{"Line":0}},{"line":129,"address":[2711616,2709232,2711514],"length":1,"stats":{"Line":0}},{"line":137,"address":[2709375],"length":1,"stats":{"Line":0}},{"line":138,"address":[2709404],"length":1,"stats":{"Line":0}},{"line":139,"address":[2709905,2711595,2709463,2709567],"length":1,"stats":{"Line":0}},{"line":142,"address":[2709875],"length":1,"stats":{"Line":0}},{"line":143,"address":[2710074,2709990],"length":1,"stats":{"Line":0}},{"line":145,"address":[2710378,2710258],"length":1,"stats":{"Line":0}},{"line":146,"address":[2710409,2710758],"length":1,"stats":{"Line":0}},{"line":148,"address":[2789616,2789641],"length":1,"stats":{"Line":0}},{"line":152,"address":[2710861,2710934],"length":1,"stats":{"Line":0}},{"line":153,"address":[2711173,2710949],"length":1,"stats":{"Line":0}},{"line":154,"address":[2711137,2711259],"length":1,"stats":{"Line":0}},{"line":157,"address":[2711295],"length":1,"stats":{"Line":0}},{"line":159,"address":[2711451],"length":1,"stats":{"Line":0}},{"line":162,"address":[2710176],"length":1,"stats":{"Line":0}},{"line":166,"address":[2711632],"length":1,"stats":{"Line":0}},{"line":167,"address":[2711658],"length":1,"stats":{"Line":0}},{"line":168,"address":[2711787,2712051],"length":1,"stats":{"Line":0}},{"line":172,"address":[2712192,2713186],"length":1,"stats":{"Line":0}},{"line":173,"address":[2712255],"length":1,"stats":{"Line":0}},{"line":174,"address":[2712347,2712268],"length":1,"stats":{"Line":0}},{"line":176,"address":[2712362],"length":1,"stats":{"Line":0}},{"line":177,"address":[2712520],"length":1,"stats":{"Line":0}},{"line":179,"address":[2712602],"length":1,"stats":{"Line":0}},{"line":180,"address":[2713166,2712656],"length":1,"stats":{"Line":0}},{"line":181,"address":[2712675,2712637],"length":1,"stats":{"Line":0}},{"line":182,"address":[2712738,2712703],"length":1,"stats":{"Line":0}},{"line":184,"address":[2712905,2712723],"length":1,"stats":{"Line":0}},{"line":187,"address":[2712840],"length":1,"stats":{"Line":0}},{"line":190,"address":[2724754,2717582,2713216],"length":1,"stats":{"Line":0}},{"line":192,"address":[2713238],"length":1,"stats":{"Line":0}},{"line":195,"address":[2713518,2713362,2713267,2724736],"length":1,"stats":{"Line":0}},{"line":196,"address":[2713491,2713619,2713737],"length":1,"stats":{"Line":0}},{"line":199,"address":[2713806,2714096,2724681,2714079],"length":1,"stats":{"Line":0}},{"line":202,"address":[2789717,2789664],"length":1,"stats":{"Line":0}},{"line":206,"address":[2714053,2714170],"length":1,"stats":{"Line":0}},{"line":207,"address":[2714189],"length":1,"stats":{"Line":0}},{"line":208,"address":[2714341],"length":1,"stats":{"Line":0}},{"line":214,"address":[2714520],"length":1,"stats":{"Line":0}},{"line":215,"address":[2714687,2714589],"length":1,"stats":{"Line":0}},{"line":216,"address":[2714854,2714756],"length":1,"stats":{"Line":0}},{"line":217,"address":[2715021,2714923],"length":1,"stats":{"Line":0}},{"line":218,"address":[2715188,2715090],"length":1,"stats":{"Line":0}},{"line":219,"address":[2715257,2715355],"length":1,"stats":{"Line":0}},{"line":220,"address":[2715424,2715522],"length":1,"stats":{"Line":0}},{"line":222,"address":[2715591],"length":1,"stats":{"Line":0}},{"line":224,"address":[2715627,2715789],"length":1,"stats":{"Line":0}},{"line":226,"address":[2715656,2715601],"length":1,"stats":{"Line":0}},{"line":227,"address":[2715675],"length":1,"stats":{"Line":0}},{"line":231,"address":[2715810,2715722,2724118,2716015,2715969],"length":1,"stats":{"Line":0}},{"line":232,"address":[2717699,2716031],"length":1,"stats":{"Line":0}},{"line":233,"address":[2724406],"length":1,"stats":{"Line":0}},{"line":242,"address":[2717709,2718034],"length":1,"stats":{"Line":0}},{"line":248,"address":[2718127],"length":1,"stats":{"Line":0}},{"line":249,"address":[2718182],"length":1,"stats":{"Line":0}},{"line":250,"address":[2718245],"length":1,"stats":{"Line":0}},{"line":252,"address":[2718328],"length":1,"stats":{"Line":0}},{"line":256,"address":[2718389,2718451],"length":1,"stats":{"Line":0}},{"line":257,"address":[2718557,2724259,2724131],"length":1,"stats":{"Line":0}},{"line":262,"address":[2718457,2718733],"length":1,"stats":{"Line":0}},{"line":268,"address":[2718826],"length":1,"stats":{"Line":0}},{"line":269,"address":[2718881],"length":1,"stats":{"Line":0}},{"line":270,"address":[2718938],"length":1,"stats":{"Line":0}},{"line":272,"address":[2719003],"length":1,"stats":{"Line":0}},{"line":276,"address":[2719048],"length":1,"stats":{"Line":0}},{"line":277,"address":[2719083],"length":1,"stats":{"Line":0}},{"line":279,"address":[2719123,2719332],"length":1,"stats":{"Line":0}},{"line":280,"address":[2719447],"length":1,"stats":{"Line":0}},{"line":284,"address":[2719574],"length":1,"stats":{"Line":0}},{"line":286,"address":[2719699],"length":1,"stats":{"Line":0}},{"line":288,"address":[2721688],"length":1,"stats":{"Line":0}},{"line":298,"address":[2719841],"length":1,"stats":{"Line":0}},{"line":299,"address":[2719927,2720046],"length":1,"stats":{"Line":0}},{"line":300,"address":[2720195,2720314],"length":1,"stats":{"Line":0}},{"line":301,"address":[2720446,2720588],"length":1,"stats":{"Line":0}},{"line":302,"address":[2720830,2721094],"length":1,"stats":{"Line":0}},{"line":305,"address":[2719143],"length":1,"stats":{"Line":0}},{"line":306,"address":[2724003],"length":1,"stats":{"Line":0}},{"line":312,"address":[2716061],"length":1,"stats":{"Line":0}},{"line":313,"address":[2789760,2789776],"length":1,"stats":{"Line":0}},{"line":314,"address":[2716197,2716122],"length":1,"stats":{"Line":0}},{"line":315,"address":[2789888,2789872],"length":1,"stats":{"Line":0}},{"line":317,"address":[2716319,2716227],"length":1,"stats":{"Line":0}},{"line":318,"address":[2716357],"length":1,"stats":{"Line":0}},{"line":320,"address":[2716808],"length":1,"stats":{"Line":0}},{"line":326,"address":[2716925,2717161,2717607],"length":1,"stats":{"Line":0}},{"line":327,"address":[2717134,2717262],"length":1,"stats":{"Line":0}},{"line":328,"address":[2717380],"length":1,"stats":{"Line":0}},{"line":330,"address":[2717449],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":125},{"path":["/","home","adam","repos","vectordb-cli","src","cli","commands.rs"],"content":"// use crate::vectordb::embedding::EmbeddingModelType;\nuse crate::vectordb::error::VectorDBError;\n// use crate::vectordb::search::Search; // Removed\nuse crate::vectordb::VectorDB;\n// use crate::vectordb::cache::CacheCheckResult; // Removed\nuse anyhow::{anyhow, Result};\nuse clap::Parser;\nuse log::{debug, error, warn};\nuse num_cpus;\nuse rayon;\nuse std::path::{Path, PathBuf};\nuse std::time::Instant;\n// use crate::vectordb::search::result::SearchResult; // Removed\n// use crate::vectordb::search::{chunking, snippet}; // Removed\n// use std::collections::HashMap; // Removed\nuse std::fs;\n// use std::collections::HashSet; // Removed\n// use crate::vectordb::utils::cosine_distance; // Removed\n// use walkdir::WalkDir; // Removed\n// use chrono::{DateTime, Utc, TimeZone, Local}; // Removed DateTime, TimeZone, Local\nuse chrono::{Utc, Local, TimeZone}; // Add back Local and TimeZone\n\n// Global flag for handling interrupts\npub static mut INTERRUPT_RECEIVED: bool = false;\n\n#[derive(Parser, Debug)]\npub enum Command {\n    /// Index files in one or more directories\n    Index {\n        /// Directories to index (provide one or more paths)\n        #[arg(required = true)]\n        dirs: Vec\u003cString\u003e,\n\n        /// File types to index (e.g. rs,rb,go,js,ts,yaml,md)\n        #[arg(short = 't', long = \"file-types\", value_delimiter = ',')]\n        file_types: Vec\u003cString\u003e,\n\n        /// Number of threads to use for indexing (defaults to available CPUs)\n        #[arg(short = 'j', long = \"threads\")]\n        threads: Option\u003cusize\u003e,\n\n        /// Path to ONNX model file (required if not set via env var)\n        #[arg(long = \"onnx-model\")]\n        onnx_model: Option\u003cString\u003e,\n\n        /// Path to ONNX tokenizer file (required if not set via env var)\n        #[arg(long = \"onnx-tokenizer\")]\n        onnx_tokenizer: Option\u003cString\u003e,\n    },\n\n    /// Search across indexed text chunks using semantic similarity\n    Query {\n        /// Search query string\n        #[arg(required = true)]\n        query: String,\n\n        /// Maximum number of relevant chunks to return (default: 20)\n        #[arg(short = 'l', long = \"limit\")]\n        max_results: Option\u003cusize\u003e,\n\n        /// Only show chunks from files with these extensions (e.g. rs,md,py)\n        #[arg(short = 't', long = \"file-types\", value_delimiter = ',')]\n        file_types: Option\u003cVec\u003cString\u003e\u003e,\n    },\n\n    /// Show database statistics\n    Stats,\n\n    /// Clear the database\n    Clear {},\n\n    /// List the unique top-level directories found in the index\n    List,\n}\n\npub fn execute_command(command: Command, mut db: VectorDB) -\u003e Result\u003c()\u003e {\n    match command {\n        Command::Index {\n            dirs,\n            file_types,\n            threads,\n            onnx_model,\n            onnx_tokenizer,\n        } =\u003e {\n            debug!(\"Executing Index command for directories: {:?}\", dirs);\n            println!(\"Indexing files in {:?}...\", dirs);\n\n            // Try to set paths from args or env vars\n            let model_path_opt = onnx_model.or_else(|| std::env::var(\"VECTORDB_ONNX_MODEL\").ok());\n            let tokenizer_path_opt = onnx_tokenizer.or_else(|| std::env::var(\"VECTORDB_ONNX_TOKENIZER\").ok());\n\n            if let (Some(mp), Some(tp)) = (\u0026model_path_opt, \u0026tokenizer_path_opt) {\n                match db.set_onnx_paths(Some(PathBuf::from(mp)), Some(PathBuf::from(tp))) {\n                    Ok(_) =\u003e {\n                        // Setting paths implies using ONNX, no need to set type explicitly\n                        debug!(\"Successfully set ONNX model paths.\");\n                        println!(\"Using ONNX embedding model:\");\n                        println!(\"  - Model: {}\", mp);\n                        println!(\"  - Tokenizer: {}\", tp);\n                    }\n                    Err(e) =\u003e {\n                        // Error during path setting likely means validation failed (e.g., file not found)\n                        error!(\"Failed to validate ONNX model/tokenizer paths: {}\", e);\n                        eprintln!(\"Error configuring ONNX model: {}\", e);\n                        eprintln!(\"Please ensure the specified ONNX model and tokenizer files exist and are valid.\");\n                        return Err(e.into()); // Return error\n                    }\n                }\n            } else {\n                // Paths not provided via args or env vars\n                error!(\"ONNX model and tokenizer paths are required but not set.\");\n                eprintln!(\"Error: ONNX model and tokenizer paths must be provided either via --onnx-model/--onnx-tokenizer arguments or VECTORDB_ONNX_MODEL/VECTORDB_ONNX_TOKENIZER environment variables.\");\n                // Return an appropriate error\n                return Err(VectorDBError::EmbeddingError(\"ONNX paths not configured\".to_string()).into());\n            }\n            \n            // Setup thread pool\n            let num_threads = threads.unwrap_or_else(num_cpus::get);\n            rayon::ThreadPoolBuilder::new()\n                .num_threads(num_threads)\n                .build_global()\n                .map_err(|e| anyhow::anyhow!(\"Failed to build thread pool: {}\", e))?;\n\n            let start = Instant::now();\n            let mut overall_result = Ok(()); // Track overall success\n\n            // Determine file types to use based on input flags\n            let file_types_to_use = if file_types.is_empty() {\n                let supported = VectorDB::get_supported_file_types();\n                println!(\n                    \"No file types specified, using all supported types: {}\",\n                    supported.join(\", \")\n                );\n                supported\n            } else {\n                println!(\"Indexing file types: {}\", file_types.join(\", \"));\n                file_types\n            };\n\n            // Loop through each directory provided\n            for dir_path_str in dirs {\n                 // Canonicalize the input path string\n                 let canonical_dir = match fs::canonicalize(\u0026dir_path_str) {\n                     Ok(path) =\u003e path,\n                     Err(e) =\u003e {\n                         error!(\"Failed to find or canonicalize directory '{}': {}\", dir_path_str, e);\n                         eprintln!(\"Error: Invalid directory '{}': {}\", dir_path_str, e);\n                         if overall_result.is_ok() {\n                             overall_result = Err(anyhow!(\"Invalid directory: {}\", dir_path_str));\n                         }\n                         continue; // Skip to the next directory\n                     }\n                 };\n                 let canonical_dir_str = canonical_dir.to_string_lossy().to_string();\n\n                 println!(\"Starting indexing for: {}\", canonical_dir_str);\n                 debug!(\n                    \"Starting directory indexing: {}, file types: {:?}\",\n                    canonical_dir_str,\n                    \u0026file_types_to_use\n                 );\n                // Index the current canonical directory\n                match db.index_directory(\u0026canonical_dir_str, \u0026file_types_to_use) {\n                    Ok(_) =\u003e {\n                        if unsafe { INTERRUPT_RECEIVED } {\n                            debug!(\"Indexing interrupted for {}, data saved safely\", canonical_dir_str);\n                            println!(\"Indexing interrupted for {}, data saved safely.\", canonical_dir_str);\n                            // Set overall result to error if interrupted\n                            overall_result = Err(anyhow!(\"Indexing interrupted\"));\n                            break; // Stop processing more directories if interrupted\n                        } else {\n                            debug!(\n                                \"Indexing for {} completed successfully\",\n                                canonical_dir_str\n                            );\n                            println!(\"Finished indexing for: {}\", canonical_dir_str);\n                            // Get current UTC timestamp and update\n                            let now_ts = Utc::now().timestamp() as u64;\n                            db.update_indexed_root_timestamp(canonical_dir_str, now_ts); \n                        }\n                    }\n                    Err(e) =\u003e {\n                        if unsafe { INTERRUPT_RECEIVED } {\n                            debug!(\"Indexing interrupted for {}, data saved safely\", canonical_dir_str);\n                            println!(\"Indexing interrupted for {}, data saved safely.\", canonical_dir_str);\n                             overall_result = Err(anyhow!(\"Indexing interrupted\"));\n                            break; // Stop processing more directories\n                        } else {\n                            error!(\"Indexing failed for {}: {}\", canonical_dir_str, e);\n                            eprintln!(\"Error indexing {}: {}\", canonical_dir_str, e);\n                            // Store the first error encountered, but continue if possible\n                            if overall_result.is_ok() {\n                                overall_result = Err(e.into());\n                            }\n                            // Do not break here, allow indexing other directories if requested\n                        }\n                    }\n                }\n            }\n\n            // Save db once after all directories are processed (save includes HNSW rebuild)\n             if overall_result.is_ok() {\n                  if let Err(e) = db.save() {\n                      error!(\"Failed to save database after indexing: {}\", e);\n                      overall_result = Err(e.into());\n                  }\n              }\n            \n            // Final summary message based on overall result\n            let duration = start.elapsed();\n            if overall_result.is_ok() {\n                debug!(\n                    \"All indexing tasks completed successfully in {:.2} seconds\",\n                    duration.as_secs_f32()\n                );\n                println!(\n                    \"\\nTotal indexing time: {:.2} seconds!\",\n                    duration.as_secs_f32()\n                );\n            } else if unsafe { INTERRUPT_RECEIVED } {\n                // Message already printed during the loop for interruption\n                println!(\"\\nTotal time before interruption: {:.2} seconds.\", duration.as_secs_f32());\n            } else {\n                // Report that some errors occurred\n                eprintln!(\n                    \"\\nIndexing completed with errors in {:.2} seconds. Check logs for details.\",\n                    duration.as_secs_f32()\n                );\n            }\n\n            return overall_result; // Return the final result (Ok or the first error)\n        }\n        Command::Query {\n            query,\n            max_results,\n            file_types,\n        } =\u003e {\n            debug!(\"Executing Query command with query: '{}'\", query);\n            let start_time = Instant::now();\n\n            // --- Define QueryResultChunk struct ---\n            #[derive(Debug)] // Added Debug derive for easier printing/logging\n            struct QueryResultChunk {\n                file_path: String,\n                start_line: usize,\n                end_line: usize,\n                text: String,\n                score: f32,\n            }\n\n            // Get search limit\n            let limit = max_results.unwrap_or(20);\n\n            // --- New Chunk-Based Query Logic ---\n\n            // 1. Create Embedding Model\n            let model = match db.create_embedding_model() {\n                Ok(m) =\u003e m,\n                Err(e) =\u003e {\n                    error!(\"Failed to create embedding model for query: {}\", e);\n                    eprintln!(\"Error initializing embedding model: {}. Have you indexed any data?\", e);\n                    return Err(e.into());\n                }\n            };\n\n            // 2. Generate Query Embedding\n            let query_embedding = match model.embed(\u0026query) {\n                Ok(emb) =\u003e emb,\n                Err(e) =\u003e {\n                    error!(\"Failed to generate embedding for query '{}': {}\", query, e);\n                    eprintln!(\"Error generating query embedding: {}\", e);\n                    return Err(e.into());\n                }\n            };\n            debug!(\"Query embedding generated (dim={})\", query_embedding.len());\n\n            // 3. Access HNSW Index\n            let hnsw_index = match db.hnsw_index() {\n                Some(index) =\u003e index,\n                None =\u003e {\n                    warn!(\"HNSW index is not available. No search results can be returned.\");\n                    eprintln!(\"Search index is not built. Please run the 'index' command first.\");\n                    return Ok(()); // Or return an error?\n                }\n            };\n\n            // Verify index dimension matches query embedding dimension\n            if hnsw_index.get_config().dimension != query_embedding.len() {\n                error!(\n                    \"Query embedding dimension ({}) does not match HNSW index dimension ({}).\",\n                    query_embedding.len(),\n                    hnsw_index.get_config().dimension\n                );\n                eprintln!(\n                    \"Error: Query embedding dimension ({}) does not match the index dimension ({}). \\\\\n                     The index might be corrupted or built with a different model. Please re-index.\",\n                    query_embedding.len(),\n                    hnsw_index.get_config().dimension\n                );\n                return Err(anyhow!(\"Index dimension mismatch\"));\n            }\n\n            // 4. Perform HNSW Search\n            // TODO: Make ef_search configurable?\n            let ef_search = 100; // Example value\n            debug!(\"Performing HNSW search with k={}, ef_search={}\", limit, ef_search);\n            let search_results = hnsw_index.search_parallel(\u0026query_embedding, limit, ef_search)?;\n            debug!(\"HNSW search returned {} results\", search_results.len());\n\n            // 5. Process HNSW Results\n            let mut chunk_results: Vec\u003cQueryResultChunk\u003e = Vec::with_capacity(search_results.len());\n            for (node_id, distance) in search_results {\n                if let Some(chunk_data) = db.indexed_chunks.get(node_id) {\n                    let similarity = 1.0 - distance;\n                    // Basic filtering (optional, can add more like file_type filtering here if needed)\n                    if similarity \u003c 0.0 { continue; } // Skip results with negative similarity (highly dissimilar)\n\n                    // Filter by file type if specified\n                    if let Some(ref allowed_types) = file_types {\n                        if !allowed_types.is_empty() {\n                             if let Some(extension) = Path::new(\u0026chunk_data.file_path).extension().and_then(|ext| ext.to_str()) {\n                                 if !allowed_types.iter().any(|ft| ft.eq_ignore_ascii_case(extension)) {\n                                     debug!(\"Skipping chunk from file {} due to file type filter\", chunk_data.file_path);\n                                     continue; // Skip chunk if file type doesn't match\n                                 }\n                             } else {\n                                 continue; // Skip files with no extension if filtering\n                             }\n                        }\n                    }\n\n                    chunk_results.push(QueryResultChunk {\n                        file_path: chunk_data.file_path.clone(),\n                        start_line: chunk_data.start_line,\n                        end_line: chunk_data.end_line,\n                        text: chunk_data.text.clone(),\n                        score: similarity,\n                    });\n                } else {\n                    error!(\"Invalid node ID {} returned from HNSW search, data mismatch!\", node_id);\n                    // This indicates a potential corruption or bug\n                }\n            }\n\n            // 6. Display Results\n            let elapsed = start_time.elapsed();\n            if chunk_results.is_empty() {\n                println!(\"No relevant chunks found for query '{}'\", query);\n            } else {\n                println!(\"Found {} relevant chunks ({:.2} seconds):\", chunk_results.len(), elapsed.as_secs_f32());\n                println!(\"---\");\n                for (i, result) in chunk_results.iter().enumerate() {\n                    // Use canonicalize to try and resolve symlinks/relative paths\n                    let display_path = match fs::canonicalize(\u0026result.file_path) {\n                         Ok(p) =\u003e p.to_string_lossy().into_owned(),\n                         Err(_) =\u003e result.file_path.clone(), // Fallback to original path if canonicalization fails\n                    };\n                    println!(\n                        \"{}. {} (Lines {}-{}) (score: {:.4})\",\n                        i + 1,\n                        display_path,\n                        result.start_line,\n                        result.end_line,\n                        result.score\n                    );\n                    // Indent the chunk text slightly\n                    for line in result.text.lines() {\n                        println!(\"  {}\", line);\n                    }\n                    println!(\"---\");\n                }\n            }\n            debug!(\"Query processing took {:.4} seconds\", elapsed.as_secs_f32());\n\n            Ok(())\n        }\n        Command::Stats =\u003e {\n            let stats = db.stats();\n            println!(\"Database Statistics:\");\n            println!(\"  DB Path: {}\", stats.db_path);\n            println!(\"  Model Type: {}\", stats.embedding_model_type);\n            println!(\"  Embedding Dimension: {}\", stats.embedding_dimension);\n            println!(\"  Unique Files Indexed: {}\", stats.unique_files);\n            println!(\"  Total Chunks Indexed: {}\", stats.indexed_chunks);\n            println!(\"  Cached Files (hashes): {}\", stats.cached_files);\n            if let Some(hnsw_stats) = stats.hnsw_stats {\n                println!(\"  HNSW Index:\");\n                println!(\"    Total Nodes: {}\", hnsw_stats.total_nodes);\n                println!(\"    Layers: {}\", hnsw_stats.layers);\n                // Add more HNSW stats if desired\n            } else {\n                println!(\"  HNSW Index: Not built\");\n            }\n            Ok(())\n        }\n        Command::Clear {} =\u003e {\n            println!(\"Clearing database...\");\n            db.clear()?;\n            println!(\"Database cleared successfully.\");\n            Ok(())\n        }\n        Command::List =\u003e {\n            debug!(\"Executing List command\");\n            println!(\"Retrieving indexed directories...\");\n\n            let indexed_roots_map = db.indexed_roots();\n\n            if indexed_roots_map.is_empty() {\n                println!(\"  No directories have been explicitly indexed yet.\");\n                return Ok(());\n            }\n\n            // Convert HashMap to Vec for sorting\n            let mut sorted_roots: Vec\u003c(String, u64)\u003e = indexed_roots_map.iter()\n                                                    .map(|(k, v)| (k.clone(), *v))\n                                                    .collect();\n            // Sort by path (the String key)\n            sorted_roots.sort_by(|a, b| a.0.cmp(\u0026b.0));\n\n            println!(\"Indexed Directories (Last Indexed):\");\n\n            // Print path and formatted timestamp\n            for (root_path_str, timestamp) in sorted_roots {\n                 // Convert UNIX timestamp to DateTime\u003cLocal\u003e\n                let dt = match Utc.timestamp_opt(timestamp as i64, 0) {\n                    chrono::LocalResult::Single(dt) =\u003e dt.with_timezone(\u0026Local),\n                    _ =\u003e { // Handle potential invalid timestamp\n                         warn!(\"Invalid timestamp ({}) found for directory {}\", timestamp, root_path_str);\n                         // Print placeholder or skip?\n                         println!(\"  - {} (Invalid Timestamp)\", root_path_str);\n                         continue;\n                    }\n                 };\n                 // Format the timestamp\n                 let formatted_time = dt.format(\"%Y-%m-%d %H:%M:%S\").to_string();\n                 println!(\"  - {} ({})\", root_path_str, formatted_time);\n            }\n            Ok(())\n        }\n    }\n}\n","traces":[{"line":76,"address":[3981808,4017517,3985601],"length":1,"stats":{"Line":0}},{"line":77,"address":[4109043],"length":1,"stats":{"Line":0}},{"line":78,"address":[3803364],"length":1,"stats":{"Line":0}},{"line":85,"address":[3982598,3982935,3982251,3982767],"length":1,"stats":{"Line":0}},{"line":86,"address":[3983114],"length":1,"stats":{"Line":0}},{"line":89,"address":[3804459],"length":1,"stats":{"Line":0}},{"line":90,"address":[3625565,3625552],"length":1,"stats":{"Line":0}},{"line":92,"address":[3804629,3804785],"length":1,"stats":{"Line":0}},{"line":93,"address":[4124535,4110689,4110756],"length":1,"stats":{"Line":0}},{"line":96,"address":[3805337,3805254,3805098],"length":1,"stats":{"Line":0}},{"line":97,"address":[3805260,3805550],"length":1,"stats":{"Line":0}},{"line":98,"address":[3984423],"length":1,"stats":{"Line":0}},{"line":99,"address":[3805858],"length":1,"stats":{"Line":0}},{"line":101,"address":[4111015],"length":1,"stats":{"Line":0}},{"line":103,"address":[3983943,3996926,3996757,3997094],"length":1,"stats":{"Line":0}},{"line":104,"address":[4124288],"length":1,"stats":{"Line":0}},{"line":105,"address":[3997342],"length":1,"stats":{"Line":0}},{"line":106,"address":[4124402],"length":1,"stats":{"Line":0}},{"line":111,"address":[3997640,3983469,3997557],"length":1,"stats":{"Line":0}},{"line":112,"address":[3818698,3818988],"length":1,"stats":{"Line":0}},{"line":114,"address":[4124879],"length":1,"stats":{"Line":0}},{"line":118,"address":[3805943],"length":1,"stats":{"Line":0}},{"line":119,"address":[3817839,3806211,3805981],"length":1,"stats":{"Line":0}},{"line":122,"address":[3625616,3625736,3625871],"length":1,"stats":{"Line":0}},{"line":124,"address":[3806251,3806169],"length":1,"stats":{"Line":0}},{"line":125,"address":[3985026],"length":1,"stats":{"Line":0}},{"line":128,"address":[3986029,3985046,3985120],"length":1,"stats":{"Line":0}},{"line":129,"address":[3806409],"length":1,"stats":{"Line":0}},{"line":130,"address":[3985849],"length":1,"stats":{"Line":0}},{"line":134,"address":[4113089],"length":1,"stats":{"Line":0}},{"line":136,"address":[4112451,4112307,4112238],"length":1,"stats":{"Line":0}},{"line":137,"address":[3985475],"length":1,"stats":{"Line":0}},{"line":141,"address":[3806767,3807314,3807449,3807506],"length":1,"stats":{"Line":0}},{"line":143,"address":[4113477,4113426],"length":1,"stats":{"Line":0}},{"line":144,"address":[3807640],"length":1,"stats":{"Line":0}},{"line":145,"address":[3986503],"length":1,"stats":{"Line":0}},{"line":146,"address":[4122569,4113623,4122847,4122400],"length":1,"stats":{"Line":0}},{"line":147,"address":[3817280],"length":1,"stats":{"Line":0}},{"line":148,"address":[3817786,3817373],"length":1,"stats":{"Line":0}},{"line":149,"address":[4123525,4123404],"length":1,"stats":{"Line":0}},{"line":154,"address":[3807867,3807712],"length":1,"stats":{"Line":0}},{"line":156,"address":[3808119],"length":1,"stats":{"Line":0}},{"line":157,"address":[4114368],"length":1,"stats":{"Line":0}},{"line":163,"address":[3987022,3987617],"length":1,"stats":{"Line":0}},{"line":165,"address":[3808965],"length":1,"stats":{"Line":0}},{"line":166,"address":[4116116,4114945,4115779,4115948],"length":1,"stats":{"Line":0}},{"line":167,"address":[3989205],"length":1,"stats":{"Line":0}},{"line":169,"address":[3810492],"length":1,"stats":{"Line":0}},{"line":172,"address":[3988116,3988284,3987806,3987947],"length":1,"stats":{"Line":0}},{"line":176,"address":[4115557],"length":1,"stats":{"Line":0}},{"line":178,"address":[4115626],"length":1,"stats":{"Line":0}},{"line":179,"address":[3809824],"length":1,"stats":{"Line":0}},{"line":182,"address":[4114848],"length":1,"stats":{"Line":0}},{"line":183,"address":[3809010],"length":1,"stats":{"Line":0}},{"line":184,"address":[3989531,3991047,3990878,3991215],"length":1,"stats":{"Line":0}},{"line":185,"address":[3991394],"length":1,"stats":{"Line":0}},{"line":186,"address":[4118533],"length":1,"stats":{"Line":0}},{"line":189,"address":[4116572,4117160,4116882,4116713],"length":1,"stats":{"Line":0}},{"line":190,"address":[3990379],"length":1,"stats":{"Line":0}},{"line":192,"address":[4117796,4117558],"length":1,"stats":{"Line":0}},{"line":193,"address":[4117604],"length":1,"stats":{"Line":0}},{"line":202,"address":[3812932,3813890],"length":1,"stats":{"Line":0}},{"line":203,"address":[3992675,3991818],"length":1,"stats":{"Line":0}},{"line":204,"address":[3991935,3992378,3992210,3992063],"length":1,"stats":{"Line":0}},{"line":205,"address":[3992069,3992565],"length":1,"stats":{"Line":0}},{"line":210,"address":[3991773,3992759],"length":1,"stats":{"Line":0}},{"line":211,"address":[3813948],"length":1,"stats":{"Line":0}},{"line":212,"address":[4121156],"length":1,"stats":{"Line":0}},{"line":216,"address":[4122170,4121906],"length":1,"stats":{"Line":0}},{"line":220,"address":[4119847],"length":1,"stats":{"Line":0}},{"line":222,"address":[3814638,3814757,3814066,3815021],"length":1,"stats":{"Line":0}},{"line":225,"address":[3993054,3993318],"length":1,"stats":{"Line":0}},{"line":231,"address":[4120455],"length":1,"stats":{"Line":0}},{"line":233,"address":[3803611],"length":1,"stats":{"Line":0}},{"line":238,"address":[4109547,4125621,4125370,4125453],"length":1,"stats":{"Line":0}},{"line":239,"address":[3819959,3819504],"length":1,"stats":{"Line":0}},{"line":252,"address":[4125846],"length":1,"stats":{"Line":0}},{"line":257,"address":[3998896],"length":1,"stats":{"Line":0}},{"line":258,"address":[3998954],"length":1,"stats":{"Line":0}},{"line":259,"address":[4126110],"length":1,"stats":{"Line":0}},{"line":260,"address":[3820294,3833046,3833215,3833377],"length":1,"stats":{"Line":0}},{"line":261,"address":[3833550],"length":1,"stats":{"Line":0}},{"line":262,"address":[3833619],"length":1,"stats":{"Line":0}},{"line":267,"address":[3999090,3999280],"length":1,"stats":{"Line":0}},{"line":268,"address":[3999333],"length":1,"stats":{"Line":0}},{"line":269,"address":[4126431],"length":1,"stats":{"Line":0}},{"line":270,"address":[4138451,4138004,4138173,4126487],"length":1,"stats":{"Line":0}},{"line":271,"address":[4011821],"length":1,"stats":{"Line":0}},{"line":272,"address":[3832843],"length":1,"stats":{"Line":0}},{"line":275,"address":[3999684,3999600,3999895,3999397],"length":1,"stats":{"Line":0}},{"line":278,"address":[3821188,3820728],"length":1,"stats":{"Line":0}},{"line":279,"address":[4000164],"length":1,"stats":{"Line":0}},{"line":281,"address":[4000217,4000300,4000119],"length":1,"stats":{"Line":0}},{"line":282,"address":[4000513,4000223],"length":1,"stats":{"Line":0}},{"line":283,"address":[4000532],"length":1,"stats":{"Line":0}},{"line":288,"address":[4127174,4127540],"length":1,"stats":{"Line":0}},{"line":289,"address":[4137024],"length":1,"stats":{"Line":0}},{"line":294,"address":[3831763],"length":1,"stats":{"Line":0}},{"line":300,"address":[4137837],"length":1,"stats":{"Line":0}},{"line":305,"address":[3821728],"length":1,"stats":{"Line":0}},{"line":306,"address":[4000642,4001112,4000834,4000742],"length":1,"stats":{"Line":0}},{"line":307,"address":[3821854,3822631,3822425,3830978],"length":1,"stats":{"Line":0}},{"line":308,"address":[3822720,3822586,3823007,3822800],"length":1,"stats":{"Line":0}},{"line":311,"address":[4001644,4002120],"length":1,"stats":{"Line":0}},{"line":312,"address":[3823216,3823446,3823480,3823319],"length":1,"stats":{"Line":0}},{"line":313,"address":[3823523,3829153],"length":1,"stats":{"Line":0}},{"line":314,"address":[4008265],"length":1,"stats":{"Line":0}},{"line":316,"address":[4008295],"length":1,"stats":{"Line":0}},{"line":319,"address":[3829346],"length":1,"stats":{"Line":0}},{"line":320,"address":[3829397,3829452],"length":1,"stats":{"Line":0}},{"line":321,"address":[3099390,3099376],"length":1,"stats":{"Line":0}},{"line":322,"address":[3625984,3626016],"length":1,"stats":{"Line":0}},{"line":323,"address":[3829962,3829853,3830114],"length":1,"stats":{"Line":0}},{"line":332,"address":[4009436],"length":1,"stats":{"Line":0}},{"line":333,"address":[4008434],"length":1,"stats":{"Line":0}},{"line":334,"address":[4136173],"length":1,"stats":{"Line":0}},{"line":335,"address":[4009332],"length":1,"stats":{"Line":0}},{"line":336,"address":[3830325],"length":1,"stats":{"Line":0}},{"line":340,"address":[4008309,4009796,4009571,4009628],"length":1,"stats":{"Line":0}},{"line":346,"address":[4129421],"length":1,"stats":{"Line":0}},{"line":347,"address":[4002567],"length":1,"stats":{"Line":0}},{"line":348,"address":[3828142],"length":1,"stats":{"Line":0}},{"line":350,"address":[4003542,4003026,4003310,4002756,4002606,4002882],"length":1,"stats":{"Line":0}},{"line":351,"address":[4003676],"length":1,"stats":{"Line":0}},{"line":352,"address":[4130943,4130639],"length":1,"stats":{"Line":0}},{"line":354,"address":[4130999],"length":1,"stats":{"Line":0}},{"line":355,"address":[4131041,4131134],"length":1,"stats":{"Line":0}},{"line":356,"address":[4004226,4004469],"length":1,"stats":{"Line":0}},{"line":358,"address":[4004929,4004831,4005497,4005937,4005027,4005117,4005717,4006389,4006157],"length":1,"stats":{"Line":0}},{"line":367,"address":[4006859,4006627],"length":1,"stats":{"Line":0}},{"line":368,"address":[4007044],"length":1,"stats":{"Line":0}},{"line":370,"address":[3828009,3827836],"length":1,"stats":{"Line":0}},{"line":373,"address":[4007309,4007783,4007519,4007221,4004005],"length":1,"stats":{"Line":0}},{"line":375,"address":[4007227],"length":1,"stats":{"Line":0}},{"line":378,"address":[4109611,4139640],"length":1,"stats":{"Line":0}},{"line":379,"address":[4139718,4139648],"length":1,"stats":{"Line":0}},{"line":380,"address":[4139847],"length":1,"stats":{"Line":0}},{"line":381,"address":[3834142,3834044],"length":1,"stats":{"Line":0}},{"line":382,"address":[4013274,4013372],"length":1,"stats":{"Line":0}},{"line":383,"address":[3834476,3834378],"length":1,"stats":{"Line":0}},{"line":384,"address":[4140515,4140417],"length":1,"stats":{"Line":0}},{"line":385,"address":[4013775,4013873],"length":1,"stats":{"Line":0}},{"line":386,"address":[3834879],"length":1,"stats":{"Line":0}},{"line":387,"address":[4140842,4140937],"length":1,"stats":{"Line":0}},{"line":388,"address":[3835182,3835084],"length":1,"stats":{"Line":0}},{"line":389,"address":[4014416,4014318],"length":1,"stats":{"Line":0}},{"line":392,"address":[4141336,4140868],"length":1,"stats":{"Line":0}},{"line":394,"address":[4141305],"length":1,"stats":{"Line":0}},{"line":397,"address":[3835723,3803749],"length":1,"stats":{"Line":0}},{"line":398,"address":[4141828,4141630,4141712],"length":1,"stats":{"Line":0}},{"line":399,"address":[4014905,4015010],"length":1,"stats":{"Line":0}},{"line":400,"address":[3835934],"length":1,"stats":{"Line":0}},{"line":403,"address":[3836053,3835976,3803778],"length":1,"stats":{"Line":0}},{"line":404,"address":[4015077,4015346],"length":1,"stats":{"Line":0}},{"line":406,"address":[4142150],"length":1,"stats":{"Line":0}},{"line":408,"address":[3836303],"length":1,"stats":{"Line":0}},{"line":409,"address":[4015451,4017481],"length":1,"stats":{"Line":0}},{"line":410,"address":[4017500],"length":1,"stats":{"Line":0}},{"line":414,"address":[4142265,4142201],"length":1,"stats":{"Line":0}},{"line":415,"address":[3099535,3099488],"length":1,"stats":{"Line":0}},{"line":418,"address":[3626192,3626235],"length":1,"stats":{"Line":0}},{"line":420,"address":[4015633],"length":1,"stats":{"Line":0}},{"line":423,"address":[3836799,3836559,3836749],"length":1,"stats":{"Line":0}},{"line":425,"address":[4015982,4016101],"length":1,"stats":{"Line":0}},{"line":426,"address":[4016114],"length":1,"stats":{"Line":0}},{"line":428,"address":[4016907,4017179,4016744,4016176],"length":1,"stats":{"Line":0}},{"line":430,"address":[4017368],"length":1,"stats":{"Line":0}},{"line":435,"address":[4016221],"length":1,"stats":{"Line":0}},{"line":436,"address":[4016614],"length":1,"stats":{"Line":0}},{"line":438,"address":[4016016],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":170},{"path":["/","home","adam","repos","vectordb-cli","src","cli","mod.rs"],"content":"pub mod commands;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","lib.rs"],"content":"// Module exports\npub mod cli;\npub mod utils;\npub mod vectordb;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","main.rs"],"content":"#![allow(dead_code)]\n\nuse anyhow::Result;\nuse clap::Parser;\nuse dirs::data_local_dir;\nuse log::debug;\nuse std::path::PathBuf;\nuse tracing_subscriber;\nuse std::fs;\n\nmod cli;\nmod utils;\nmod vectordb;\n\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    #[command(subcommand)]\n    command: cli::commands::Command,\n\n    /// Optional path to the database file (defaults to system's local data dir)\n    #[arg(long = \"db-path\", global = true)]\n    db_path: Option\u003cString\u003e,\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), anyhow::Error\u003e {\n    tracing_subscriber::fmt::init();\n    // Initialize the logger\n\n    let cli = Cli::parse();\n\n    debug!(\"Initializing vectordb-cli with command: {:?}\", cli.command);\n\n    // Get the database path\n    let base_db_path = match cli.db_path {\n        Some(path) =\u003e PathBuf::from(path),\n        None =\u003e {\n            // Default path logic\n            let default_dir = data_local_dir()\n                .unwrap_or_else(|| PathBuf::from(\".\")) // Fallback to current dir if data_local_dir fails\n                .join(\"vectordb-cli\");\n\n            // Ensure the default directory exists\n            fs::create_dir_all(\u0026default_dir)?;\n            default_dir.join(\"db.json\")\n        }\n    };\n\n    // Ensure the directory for the specified or default db file exists\n    if let Some(parent_dir) = base_db_path.parent() {\n         if !parent_dir.exists() { // Only create if it doesn't exist\n              debug!(\"Creating database directory: {}\", parent_dir.display());\n              fs::create_dir_all(parent_dir)?;\n         }\n    }\n\n    let db_path_str = base_db_path.to_string_lossy().to_string();\n    debug!(\"Using database path: {}\", db_path_str);\n\n    // Create or load the database using the determined path\n    let db = vectordb::VectorDB::new(db_path_str)?;\n\n    // Execute the command\n    let result = cli::commands::execute_command(cli.command, db.clone());\n\n    // Clean up\n    if !matches!(result, Ok(())) {\n        // Handle cleanup on error if needed in the future\n        debug!(\"Command execution resulted in an error: {:?}\", result.as_ref().err());\n    }\n\n    result\n}\n","traces":[{"line":27,"address":[4226272,4226642],"length":1,"stats":{"Line":0}},{"line":28,"address":[3704017],"length":1,"stats":{"Line":0}},{"line":31,"address":[3704136],"length":1,"stats":{"Line":0}},{"line":33,"address":[3704183,3704390,3704558,3704292],"length":1,"stats":{"Line":0}},{"line":36,"address":[3704298],"length":1,"stats":{"Line":0}},{"line":37,"address":[3705409,3704756],"length":1,"stats":{"Line":0}},{"line":40,"address":[3704737,3704822,3704943],"length":1,"stats":{"Line":0}},{"line":41,"address":[3708524,3708512],"length":1,"stats":{"Line":0}},{"line":45,"address":[3705046,3705164,3705364],"length":1,"stats":{"Line":0}},{"line":46,"address":[3705141,3705265],"length":1,"stats":{"Line":0}},{"line":51,"address":[3705471,3705324],"length":1,"stats":{"Line":0}},{"line":52,"address":[3705662,3706302,3705607],"length":1,"stats":{"Line":0}},{"line":53,"address":[3705812,3705668,3706051],"length":1,"stats":{"Line":0}},{"line":54,"address":[3706238,3706307,3705742],"length":1,"stats":{"Line":0}},{"line":58,"address":[3705629,3706442],"length":1,"stats":{"Line":0}},{"line":59,"address":[3706747,3706581,3706909],"length":1,"stats":{"Line":0}},{"line":62,"address":[3707367,3707098,3708318,3706639],"length":1,"stats":{"Line":0}},{"line":65,"address":[3708285,3707224,3707445],"length":1,"stats":{"Line":0}},{"line":68,"address":[3707543],"length":1,"stats":{"Line":0}},{"line":70,"address":[3707768,3707600,3707720,3707990],"length":1,"stats":{"Line":0}},{"line":73,"address":[3707642],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","home","adam","repos","vectordb-cli","src","model_inspector.rs"],"content":"use std::path::Path;\nuse anyhow::{Result, Context};\nuse ort::{GraphOptimizationLevel, Session};\n\nfn main() -\u003e Result\u003c()\u003e {\n    // Path to ONNX model\n    let model_path = Path::new(\"onnx/all-minilm-l12-v2.onnx\");\n    println!(\"Analyzing model: {}\", model_path.display());\n    \n    // Load model without optimization to inspect raw structure\n    let session = Session::builder()?\n        .with_optimization_level(GraphOptimizationLevel::Disable)?\n        .commit_from_file(model_path)\n        .context(\"Failed to load ONNX model\")?;\n    \n    // Print model metadata\n    println!(\"\\nModel Metadata:\");\n    if let Some(metadata) = session.metadata() {\n        println!(\"  Name: {}\", metadata.name().unwrap_or(\"Unknown\"));\n        println!(\"  Producer: {}\", metadata.producer().unwrap_or(\"Unknown\"));\n        println!(\"  Domain: {}\", metadata.domain().unwrap_or(\"Unknown\"));\n        println!(\"  Description: {}\", metadata.description().unwrap_or(\"Unknown\"));\n        println!(\"  Version: {}\", metadata.version());\n    } else {\n        println!(\"  No metadata available\");\n    }\n    \n    // Print input information\n    println!(\"\\nInput Nodes:\");\n    for (i, input) in session.inputs.iter().enumerate() {\n        let shape_str = format_shape(\u0026input.dimensions);\n        println!(\"  [{}] Name: {}\", i, input.name);\n        println!(\"      Shape: {}\", shape_str);\n        println!(\"      Type: {:?}\", input.input_type);\n    }\n    \n    // Print output information\n    println!(\"\\nOutput Nodes:\");\n    for (i, output) in session.outputs.iter().enumerate() {\n        let shape_str = format_shape(\u0026output.dimensions);\n        println!(\"  [{}] Name: {}\", i, output.name);\n        println!(\"      Shape: {}\", shape_str);\n        println!(\"      Type: {:?}\", output.output_type);\n    }\n    \n    println!(\"\\nAnalysis complete.\");\n    Ok(())\n}\n\n// Helper function to format shape information\nfn format_shape(dimensions: \u0026Option\u003cVec\u003ci64\u003e\u003e) -\u003e String {\n    match dimensions {\n        Some(dims) =\u003e {\n            let dims_str: Vec\u003cString\u003e = dims.iter()\n                .map(|d| if *d \u003c 0 { \"?\".to_string() } else { d.to_string() })\n                .collect();\n            format!(\"[{}]\", dims_str.join(\", \"))\n        },\n        None =\u003e \"[unknown]\".to_string(),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","utils","mod.rs"],"content":"// Utility functions will be added here as needed\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","cache.rs"],"content":"use crate::vectordb::embedding::EmbeddingModelType;\nuse crate::vectordb::error::{Result, VectorDBError};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct CacheEntry {\n    // embedding: Vec\u003cf32\u003e, // Removed embedding\n    timestamp: u64,\n    file_hash: u64,\n    model_type: EmbeddingModelType,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct CacheFile {\n    entries: HashMap\u003cString, CacheEntry\u003e,\n}\n\npub enum CacheCheckResult {\n    // Hit(Vec\u003cf32\u003e), // Removed Hit variant with embedding\n    Hit,             // Simplified Hit variant\n    Miss(Option\u003cu64\u003e), // Cache miss, contains Option\u003cfile_hash\u003e\n}\n\n/// Cache structure\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct EmbeddingCache {\n    entries: HashMap\u003cString, CacheEntry\u003e,\n    #[serde(skip)]\n    cache_path: String,\n    #[serde(skip)]\n    ttl: u64, // Time-to-live in seconds\n    #[serde(skip)]\n    current_model_type: EmbeddingModelType, // Track current model type\n}\n\nimpl EmbeddingCache {\n    pub fn new(cache_path: String) -\u003e Result\u003cSelf\u003e {\n        let ttl = 86400 * 7; // Default TTL: 7 days\n\n        if Path::new(\u0026cache_path).exists() {\n            let contents = fs::read_to_string(\u0026cache_path)\n                .map_err(|e| VectorDBError::CacheError(e.to_string()))?;\n            let mut cache: Self = serde_json::from_str(\u0026contents)\n                .map_err(|e| VectorDBError::CacheError(e.to_string()))?;\n            cache.cache_path = cache_path;\n            cache.ttl = ttl;\n            // Default model type on load, user should set it via db\n            cache.current_model_type = EmbeddingModelType::Onnx; // Default to Onnx\n            Ok(cache)\n        } else {\n            Ok(Self {\n                entries: HashMap::new(),\n                cache_path,\n                ttl,\n                current_model_type: EmbeddingModelType::Onnx, // Default to Onnx\n            })\n        }\n    }\n\n    /// Set the current model type\n    pub fn set_model_type(\u0026mut self, model_type: EmbeddingModelType) {\n        self.current_model_type = model_type;\n    }\n\n    pub fn clear(\u0026mut self) -\u003e Result\u003c()\u003e {\n        self.entries.clear();\n        self.save()?;\n        Ok(())\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.entries.len()\n    }\n\n    pub fn save(\u0026self) -\u003e Result\u003c()\u003e {\n        if let Some(parent) = Path::new(\u0026self.cache_path).parent() {\n            std::fs::create_dir_all(parent).map_err(|e| VectorDBError::DirectoryCreationError {\n                path: parent.to_path_buf(),\n                source: e,\n            })?;\n        }\n\n        let cache_file = CacheFile {\n            entries: self.entries.clone(),\n        };\n\n        // Create a temporary file first\n        let temp_path = format!(\"{}.tmp\", self.cache_path);\n\n        // Write to temporary file first\n        let contents =\n            serde_json::to_string_pretty(\u0026cache_file).map_err(VectorDBError::SerializationError)?;\n        std::fs::write(\u0026temp_path, contents).map_err(|e| VectorDBError::FileWriteError {\n            path: Path::new(\u0026temp_path).to_path_buf(),\n            source: e,\n        })?;\n\n        // Atomically rename the temporary file to the actual file\n        std::fs::rename(\u0026temp_path, \u0026self.cache_path).map_err(|e| {\n            VectorDBError::FileWriteError {\n                path: Path::new(\u0026self.cache_path).to_path_buf(),\n                source: e,\n            }\n        })?;\n\n        Ok(())\n    }\n\n    pub fn get_file_hash(path: \u0026Path) -\u003e Result\u003cu64\u003e {\n        let metadata = std::fs::metadata(path).map_err(|e| VectorDBError::MetadataError {\n            path: path.to_path_buf(),\n            source: e,\n        })?;\n\n        let modified = metadata\n            .modified()\n            .map_err(|e| VectorDBError::MetadataError {\n                path: path.to_path_buf(),\n                source: e,\n            })?\n            .duration_since(UNIX_EPOCH)\n            .map_err(|e| VectorDBError::CacheError(e.to_string()))?\n            .as_secs();\n\n        let size = metadata.len();\n\n        Ok(modified.wrapping_mul(31).wrapping_add(size as u64))\n    }\n\n    /// Cleans the cache by removing entries whose model type doesn't match the current one.\n    pub fn invalidate_different_model_types(\u0026mut self) {\n        self.entries\n            .retain(|_, entry| entry.model_type == self.current_model_type);\n    }\n\n    /// Checks the cache for a file, considering TTL, model type, and file modification.\n    /// Returns Hit if valid, or Miss(Option\u003cfile_hash\u003e) if missed or invalid.\n    pub fn check_cache_and_get_hash(\n        \u0026self,\n        file_path_str: \u0026str,\n        file_path: \u0026Path,\n    ) -\u003e Result\u003cCacheCheckResult\u003e {\n        if let Some(entry) = self.entries.get(file_path_str) {\n            let now = SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .map_err(|e| VectorDBError::CacheError(format!(\"System time error: {}\", e)))?\n                .as_secs();\n\n            // 1. Check TTL\n            if now.saturating_sub(entry.timestamp) \u003e= self.ttl {\n                // TTL expired, treat as miss but calculate hash\n                let hash = Self::get_file_hash(file_path)?;\n                return Ok(CacheCheckResult::Miss(Some(hash)));\n            }\n\n            // 2. Check model type\n            if entry.model_type != self.current_model_type {\n                // Model mismatch, treat as miss but calculate hash\n                let hash = Self::get_file_hash(file_path)?;\n                return Ok(CacheCheckResult::Miss(Some(hash)));\n            }\n\n            // 3. Check file hash (modification check)\n            match Self::get_file_hash(file_path) {\n                Ok(current_hash) =\u003e {\n                    if entry.file_hash == current_hash {\n                        // Cache hit and valid\n                        // Ok(CacheCheckResult::Hit(entry.embedding.clone())) // Removed embedding\n                        Ok(CacheCheckResult::Hit) // Simplified Hit\n                    } else {\n                        // File modified, treat as miss, return new hash\n                        Ok(CacheCheckResult::Miss(Some(current_hash)))\n                    }\n                }\n                Err(e) =\u003e {\n                    // Error getting current hash (e.g., file deleted), treat as cache miss\n                    // Log the error for debugging\n                    eprintln!(\n                        \"Warning: Could not get file hash for cache check {}: {}\",\n                        file_path.display(),\n                        e\n                    );\n                    Ok(CacheCheckResult::Miss(None)) // Indicate hash couldn't be determined\n                }\n            }\n        } else {\n            // Not in cache map, treat as miss\n            let hash_opt = Self::get_file_hash(file_path).ok();\n            Ok(CacheCheckResult::Miss(hash_opt))\n        }\n    }\n\n    /// Insert a file hash entry. Used after successful processing of a file's chunks.\n    /// Does not save immediately.\n    pub fn insert_file_hash(\n        \u0026mut self,\n        file_path: String,\n        file_hash: u64,\n    ) -\u003e Result\u003c()\u003e {\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map_err(|e| VectorDBError::CacheError(e.to_string()))?\n            .as_secs();\n\n        let entry = CacheEntry {\n            // embedding, // Removed\n            timestamp: now,\n            file_hash,\n            model_type: self.current_model_type.clone(),\n        };\n\n        self.entries.insert(file_path, entry);\n        // No save here - intended for batch inserts\n        Ok(())\n    }\n\n    /// Removes an entry from the cache if it exists.\n    #[allow(dead_code)] // Suppress warning, used by VectorDB::remove\n    pub fn remove(\u0026mut self, key: \u0026str) -\u003e Result\u003cOption\u003cCacheEntry\u003e\u003e {\n        let removed = self.entries.remove(key);\n        if removed.is_some() {\n            // Save the cache if an entry was actually removed\n            self.save()?;\n        }\n        Ok(removed)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_cache_basic() -\u003e Result\u003c()\u003e {\n        let dir = tempdir()?;\n        let cache_path = dir.path().join(\"cache.json\").to_string_lossy().to_string();\n\n        let mut cache = EmbeddingCache::new(cache_path.clone())?;\n        assert_eq!(cache.len(), 0);\n\n        // Insert an item\n        // let embedding = vec![1.0, 2.0, 3.0]; // Removed\n        let file_hash = 12345u64; // Example hash\n        // cache.insert_with_hash(\"test\".to_string(), embedding.clone(), file_hash)?; // Removed\n        cache.insert_file_hash(\"test\".to_string(), file_hash)?; // Use new method\n        assert_eq!(cache.len(), 1);\n\n        // Check cache hit\n        let temp_file = dir.path().join(\"test_file.txt\");\n        fs::write(\u0026temp_file, \"content\")?;\n        let file_hash_check = EmbeddingCache::get_file_hash(\u0026temp_file)?;\n        // Need to insert again with the actual hash for check to work\n        cache.insert_file_hash(\"test_file.txt\".to_string(), file_hash_check)?;\n\n        let check_result = cache.check_cache_and_get_hash(\"test_file.txt\", \u0026temp_file)?;\n        match check_result {\n            // CacheCheckResult::Hit(cached_embedding) =\u003e assert_eq!(cached_embedding, embedding),\n            CacheCheckResult::Hit =\u003e { /* Correct */ },\n            CacheCheckResult::Miss(_) =\u003e panic!(\"Expected cache hit\"),\n        }\n\n        // Save and reload\n        cache.save()?;\n        let reloaded_cache = EmbeddingCache::new(cache_path)?;\n        assert_eq!(reloaded_cache.len(), 2); // test and test_file.txt\n        Ok(())\n    }\n\n    #[test]\n    fn test_cache_ttl() -\u003e Result\u003c()\u003e {\n        let dir = tempdir()?;\n        let cache_path = dir.path().join(\"cache.json\").to_string_lossy().to_string();\n        let mut cache = EmbeddingCache::new(cache_path.clone())?;\n        cache.ttl = 1; // Set TTL to 1 second for testing\n\n        let file_path = \"ttl_test.txt\".to_string();\n        let temp_file_path = dir.path().join(\u0026file_path);\n        fs::write(\u0026temp_file_path, \"some data\")?;\n        let file_hash = EmbeddingCache::get_file_hash(\u0026temp_file_path)?;\n\n        // Insert entry\n        cache.insert_file_hash(file_path.clone(), file_hash)?;\n\n        // Check immediately (should be hit)\n        match cache.check_cache_and_get_hash(\u0026file_path, \u0026temp_file_path)? {\n            CacheCheckResult::Hit =\u003e { /* OK */ }\n            _ =\u003e panic!(\"Expected immediate cache hit\"),\n        }\n\n        // Wait for TTL to expire\n        std::thread::sleep(std::time::Duration::from_secs(2));\n\n        // Check again (should be miss)\n        match cache.check_cache_and_get_hash(\u0026file_path, \u0026temp_file_path)? {\n            CacheCheckResult::Miss(Some(h)) =\u003e assert_eq!(h, file_hash),\n            _ =\u003e panic!(\"Expected cache miss due to TTL expiry\"),\n        }\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_cache_model_type() -\u003e Result\u003c()\u003e {\n        let dir = tempdir()?;\n        let cache_path = dir.path().join(\"cache.json\").to_string_lossy().to_string();\n        let mut cache = EmbeddingCache::new(cache_path.clone())?;\n\n        let file_path = \"model_test.txt\".to_string();\n        let temp_file_path = dir.path().join(\u0026file_path);\n        fs::write(\u0026temp_file_path, \"data\")?;\n        let file_hash = EmbeddingCache::get_file_hash(\u0026temp_file_path)?;\n\n        // Set initial model type (e.g., Onnx) and insert\n        cache.set_model_type(EmbeddingModelType::Onnx);\n        cache.insert_file_hash(file_path.clone(), file_hash)?;\n        assert_eq!(cache.len(), 1);\n\n        // Check (should be hit)\n        match cache.check_cache_and_get_hash(\u0026file_path, \u0026temp_file_path)? {\n            CacheCheckResult::Hit =\u003e { /* OK */ }\n            _ =\u003e panic!(\"Expected cache hit with matching model type\"),\n        }\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_file_hash_consistency() -\u003e Result\u003c()\u003e {\n        let dir = tempdir()?;\n        let file_path = dir.path().join(\"hash_test.txt\");\n\n        // Create file\n        fs::write(\u0026file_path, \"initial content\")?;\n        let hash1 = EmbeddingCache::get_file_hash(\u0026file_path)?;\n\n        // Check hash again without modification\n        let hash2 = EmbeddingCache::get_file_hash(\u0026file_path)?;\n        assert_eq!(hash1, hash2);\n\n        // Modify content\n        fs::write(\u0026file_path, \"modified content\")?;\n        let hash3 = EmbeddingCache::get_file_hash(\u0026file_path)?;\n        assert_ne!(hash1, hash3);\n\n        // Modify timestamp (tricky to do precisely, but changing content changes timestamp)\n        // Let's just assert hash changes after modification\n\n        Ok(())\n    }\n}\n","traces":[{"line":41,"address":[3683923,3683966,3682576],"length":1,"stats":{"Line":6}},{"line":42,"address":[3647414,3647492],"length":1,"stats":{"Line":6}},{"line":44,"address":[3647563,3647471],"length":1,"stats":{"Line":12}},{"line":45,"address":[3648820,3647805,3648003,3647608],"length":1,"stats":{"Line":4}},{"line":46,"address":[3962537],"length":1,"stats":{"Line":0}},{"line":47,"address":[3963026,3962515,3962663],"length":1,"stats":{"Line":4}},{"line":48,"address":[3962978],"length":1,"stats":{"Line":0}},{"line":49,"address":[3962920,3963051,3963133],"length":1,"stats":{"Line":4}},{"line":50,"address":[3648613],"length":1,"stats":{"Line":2}},{"line":53,"address":[3963173],"length":1,"stats":{"Line":2}},{"line":55,"address":[3682854],"length":1,"stats":{"Line":6}},{"line":56,"address":[3647584],"length":1,"stats":{"Line":6}},{"line":57,"address":[3962219],"length":1,"stats":{"Line":6}},{"line":65,"address":[3648864],"length":1,"stats":{"Line":2}},{"line":69,"address":[3684016],"length":1,"stats":{"Line":2}},{"line":70,"address":[3648918],"length":1,"stats":{"Line":2}},{"line":71,"address":[3648933,3648997],"length":1,"stats":{"Line":2}},{"line":72,"address":[3648988],"length":1,"stats":{"Line":2}},{"line":75,"address":[3684192],"length":1,"stats":{"Line":2}},{"line":76,"address":[3963605],"length":1,"stats":{"Line":2}},{"line":79,"address":[3965025,3963616,3965054],"length":1,"stats":{"Line":2}},{"line":80,"address":[3684246],"length":1,"stats":{"Line":2}},{"line":81,"address":[3684344,3684584],"length":1,"stats":{"Line":2}},{"line":82,"address":[3708941],"length":1,"stats":{"Line":0}},{"line":83,"address":[3048849],"length":1,"stats":{"Line":0}},{"line":88,"address":[3684420],"length":1,"stats":{"Line":2}},{"line":92,"address":[3964065],"length":1,"stats":{"Line":2}},{"line":95,"address":[3649666,3649737,3649970,3650563],"length":1,"stats":{"Line":4}},{"line":97,"address":[3709252,3709209,3709088],"length":1,"stats":{"Line":4}},{"line":98,"address":[3709179,3709111],"length":1,"stats":{"Line":0}},{"line":99,"address":[3049044],"length":1,"stats":{"Line":0}},{"line":103,"address":[3964678,3964972,3964784,3964932],"length":1,"stats":{"Line":4}},{"line":104,"address":[3049241],"length":1,"stats":{"Line":0}},{"line":105,"address":[3709303,3709371],"length":1,"stats":{"Line":0}},{"line":106,"address":[3709396],"length":1,"stats":{"Line":0}},{"line":110,"address":[3964845],"length":1,"stats":{"Line":2}},{"line":113,"address":[3965072],"length":1,"stats":{"Line":2}},{"line":114,"address":[3331494,3331537,3331392],"length":1,"stats":{"Line":2}},{"line":115,"address":[3709501],"length":1,"stats":{"Line":0}},{"line":116,"address":[3331489],"length":1,"stats":{"Line":0}},{"line":119,"address":[3685852,3686014,3686191,3686403],"length":1,"stats":{"Line":4}},{"line":121,"address":[3709648,3709750,3709793],"length":1,"stats":{"Line":0}},{"line":122,"address":[3709677],"length":1,"stats":{"Line":0}},{"line":123,"address":[3709745],"length":1,"stats":{"Line":0}},{"line":126,"address":[3686372],"length":1,"stats":{"Line":0}},{"line":129,"address":[3965694],"length":1,"stats":{"Line":2}},{"line":131,"address":[3965767],"length":1,"stats":{"Line":2}},{"line":135,"address":[3651392],"length":1,"stats":{"Line":2}},{"line":136,"address":[3651411,3651400],"length":1,"stats":{"Line":4}},{"line":137,"address":[3965871],"length":1,"stats":{"Line":2}},{"line":142,"address":[3651424,3652992],"length":1,"stats":{"Line":6}},{"line":147,"address":[3651530,3651820],"length":1,"stats":{"Line":6}},{"line":148,"address":[3966431,3966056,3966284],"length":1,"stats":{"Line":12}},{"line":150,"address":[3709984,3710111,3710224],"length":1,"stats":{"Line":0}},{"line":154,"address":[3966395,3966351],"length":1,"stats":{"Line":12}},{"line":156,"address":[3688327,3687091,3688223],"length":1,"stats":{"Line":4}},{"line":157,"address":[3653201],"length":1,"stats":{"Line":2}},{"line":161,"address":[3652008],"length":1,"stats":{"Line":6}},{"line":163,"address":[3652175,3653123,3653019],"length":1,"stats":{"Line":0}},{"line":164,"address":[3967482],"length":1,"stats":{"Line":0}},{"line":168,"address":[3966578],"length":1,"stats":{"Line":6}},{"line":169,"address":[3687295],"length":1,"stats":{"Line":6}},{"line":170,"address":[3652272,3652455],"length":1,"stats":{"Line":6}},{"line":173,"address":[3652462],"length":1,"stats":{"Line":6}},{"line":176,"address":[3687416],"length":1,"stats":{"Line":0}},{"line":179,"address":[3687338],"length":1,"stats":{"Line":0}},{"line":182,"address":[3687848],"length":1,"stats":{"Line":0}},{"line":187,"address":[3967346],"length":1,"stats":{"Line":0}},{"line":192,"address":[3651721],"length":1,"stats":{"Line":0}},{"line":193,"address":[3686824],"length":1,"stats":{"Line":0}},{"line":199,"address":[3688384,3688939,3688910],"length":1,"stats":{"Line":2}},{"line":204,"address":[3688518,3688724,3688432],"length":1,"stats":{"Line":10}},{"line":206,"address":[3710295,3710272],"length":1,"stats":{"Line":0}},{"line":213,"address":[3968175],"length":1,"stats":{"Line":6}},{"line":216,"address":[3688814],"length":1,"stats":{"Line":6}},{"line":218,"address":[3968285],"length":1,"stats":{"Line":6}},{"line":223,"address":[3968368],"length":1,"stats":{"Line":0}},{"line":224,"address":[3653997],"length":1,"stats":{"Line":0}},{"line":225,"address":[3654012],"length":1,"stats":{"Line":0}},{"line":227,"address":[3654072],"length":1,"stats":{"Line":0}},{"line":229,"address":[3654032],"length":1,"stats":{"Line":0}}],"covered":51,"coverable":81},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","db.rs"],"content":"use crate::vectordb::cache::{CacheCheckResult, EmbeddingCache};\nuse crate::vectordb::embedding::{EmbeddingModel, EmbeddingModelType};\nuse crate::vectordb::error::{Result, VectorDBError};\nuse crate::vectordb::hnsw::{HNSWConfig, HNSWIndex, HNSWStats};\nuse indicatif::{ProgressBar, ProgressStyle};\nuse indicatif::style::TemplateError;\nuse log::{debug, error, warn};\nuse rayon::iter::ParallelIterator;\nuse rayon::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse std::collections::{HashMap, HashSet};\nuse std::fs::{self, canonicalize};\nuse std::path::{Path, PathBuf};\nuse std::sync::mpsc::{self};\nuse std::sync::{Arc, Mutex};\nuse walkdir::WalkDir;\nuse std::time::Instant;\nuse chrono::{Utc};\nuse crate::vectordb::search::chunking::{chunk_by_paragraphs};\n\n// Add From implementation here\nimpl From\u003cTemplateError\u003e for VectorDBError {\n    fn from(error: TemplateError) -\u003e Self {\n        VectorDBError::GeneralError(format!(\"Progress bar template error: {}\", error))\n    }\n}\n\n/// Relevance feedback data for a query-file pair\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct FeedbackEntry {\n    pub relevant_count: usize,\n    pub irrelevant_count: usize,\n    pub relevance_score: f32,\n}\n\n/// Collection of query feedback data\n#[derive(Serialize, Deserialize, Clone, Debug, Default)]\npub struct FeedbackData {\n    pub query_feedback: HashMap\u003cString, HashMap\u003cString, FeedbackEntry\u003e\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct IndexedChunk {\n    pub file_path: String,\n    pub start_line: usize,\n    pub end_line: usize,\n    pub text: String,\n    // Embedding vector is stored in HNSW, not duplicated here by default\n    pub embedding: Vec\u003cf32\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct DBFile {\n    indexed_chunks: Vec\u003cIndexedChunk\u003e,\n    hnsw_config: Option\u003cHNSWConfig\u003e,\n    feedback: Option\u003cFeedbackData\u003e,\n    embedding_model_type: Option\u003cEmbeddingModelType\u003e,\n    onnx_model_path: Option\u003cString\u003e,\n    onnx_tokenizer_path: Option\u003cString\u003e,\n    #[serde(default)]\n    indexed_roots: HashMap\u003cString, u64\u003e,\n}\n\npub struct VectorDB {\n    pub indexed_chunks: Vec\u003cIndexedChunk\u003e,\n    db_path: String,\n    pub cache: EmbeddingCache,\n    pub hnsw_index: Option\u003cHNSWIndex\u003e,\n    feedback: FeedbackData,\n    pub embedding_model_type: EmbeddingModelType,\n    onnx_model_path: Option\u003cPathBuf\u003e,\n    onnx_tokenizer_path: Option\u003cPathBuf\u003e,\n    indexed_roots: HashMap\u003cString, u64\u003e,\n}\n\nimpl Clone for VectorDB {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            indexed_chunks: self.indexed_chunks.clone(),\n            db_path: self.db_path.clone(),\n            cache: self.cache.clone(),\n            hnsw_index: self.hnsw_index.clone(),\n            feedback: self.feedback.clone(),\n            embedding_model_type: self.embedding_model_type.clone(),\n            onnx_model_path: self.onnx_model_path.clone(),\n            onnx_tokenizer_path: self.onnx_tokenizer_path.clone(),\n            indexed_roots: self.indexed_roots.clone(),\n        }\n    }\n}\n\nimpl VectorDB {\n    pub fn new(db_path: String) -\u003e Result\u003cSelf\u003e {\n        debug!(\"Creating VectorDB with database path: {}\", db_path);\n\n        let (\n            indexed_chunks,\n            hnsw_config,\n            feedback,\n            embedding_model_type,\n            onnx_model_path,\n            onnx_tokenizer_path,\n            indexed_roots,\n        ) = if Path::new(\u0026db_path).exists() {\n            debug!(\"Database file exists, attempting to load\");\n            match fs::read_to_string(\u0026db_path) {\n                Ok(contents) =\u003e {\n                    debug!(\"Database file read successfully, parsing JSON\");\n                    let db_file: DBFile = serde_json::from_str(\u0026contents)?;\n\n                    // Determine model type - default to Onnx if missing or if Fast is found (treat Fast as Onnx now)\n                    let loaded_model_type = db_file.embedding_model_type.unwrap_or(EmbeddingModelType::Onnx);\n                    // if loaded_model_type == EmbeddingModelType::Fast { // Remove this check\n                    //     warn!(\"Loaded DB file used deprecated Fast model type. Treating as Onnx.\");\n                    //     loaded_model_type = EmbeddingModelType::Onnx;\n                    // }\n\n                    debug!(\n                        \"Database parsed successfully: {} indexed chunks, {} indexed roots\",\n                        db_file.indexed_chunks.len(),\n                        db_file.indexed_roots.len()\n                    );\n                    (\n                        db_file.indexed_chunks,\n                        db_file.hnsw_config,\n                        db_file.feedback.unwrap_or_default(),\n                        loaded_model_type,\n                        db_file.onnx_model_path.map(PathBuf::from),\n                        db_file.onnx_tokenizer_path.map(PathBuf::from),\n                        db_file.indexed_roots,\n                    )\n                }\n                Err(e) =\u003e {\n                    error!(\"Couldn't read database file: {}\", e);\n                    eprintln!(\"Warning: Couldn't read database file: {}\", e);\n                    eprintln!(\"Creating a new empty database.\");\n                    debug!(\"Creating a new empty database\");\n                    (\n                        Vec::new(),\n                        Some(HNSWConfig::default()),\n                        FeedbackData::default(),\n                        EmbeddingModelType::Onnx,\n                        None,\n                        None,\n                        HashMap::new(),\n                    )\n                }\n            }\n        } else {\n            debug!(\"Database file doesn't exist, creating new database\");\n            (\n                Vec::new(),\n                Some(HNSWConfig::default()),\n                FeedbackData::default(),\n                EmbeddingModelType::Onnx,\n                None,\n                None,\n                HashMap::new(),\n            )\n        };\n\n        let cache_path = Path::new(\u0026db_path)\n            .parent()\n            .unwrap_or_else(|| Path::new(\".\"))\n            .join(\"cache.json\")\n            .to_string_lossy()\n            .to_string();\n        debug!(\"Creating embedding cache at: {}\", cache_path);\n\n        let mut cache = match EmbeddingCache::new(cache_path.clone()) {\n            Ok(cache) =\u003e {\n                debug!(\"Cache loaded successfully\");\n                cache\n            }\n            Err(e) =\u003e {\n                error!(\"Couldn't load cache: {}\", e);\n                eprintln!(\"Warning: Couldn't load cache: {}\", e);\n                eprintln!(\"Creating a new empty cache.\");\n                let _ = fs::remove_file(\u0026cache_path);\n                debug!(\"Creating a new empty cache\");\n                EmbeddingCache::new(cache_path)?\n            }\n        };\n\n        debug!(\"Setting cache model type to: {:?}\", embedding_model_type);\n        cache.set_model_type(embedding_model_type.clone());\n\n        let hnsw_path = Path::new(\u0026db_path)\n            .parent()\n            .unwrap_or_else(|| Path::new(\".\"))\n            .join(\"hnsw_index.json\");\n        debug!(\"Looking for HNSW index at: {}\", hnsw_path.display());\n\n        let hnsw_index = if hnsw_path.exists() {\n            debug!(\"HNSW index file exists, attempting to load\");\n            match HNSWIndex::load_from_file(\u0026hnsw_path) {\n                Ok(index) =\u003e {\n                    // ** Check dimension compatibility with loaded embeddings/model type **\n                    // We need the expected dimension here. Let's try getting it from the potentially loaded hnsw_config\n                    // or fall back to the dimension associated with the loaded embedding_model_type.\n                    // NOTE: This might still be imperfect if db.json/hnsw_config is missing/wrong,\n                    // the definitive check will happen during indexing.\n                    let expected_dim = hnsw_config.map(|c| c.dimension)\n                        .unwrap_or_else(|| embedding_model_type.default_dimension()); // Helper needed\n\n                    if index.get_config().dimension == expected_dim {\n                         debug!(\"HNSW index loaded successfully with matching dimension {}\", expected_dim);\n                         Some(index)\n                    } else {\n                        warn!(\n                            \"Loaded HNSW index dimension ({}) does not match expected dimension ({}) based on db.json/model type. Discarding loaded index.\",\n                            index.get_config().dimension, expected_dim\n                        );\n                         let _ = fs::remove_file(\u0026hnsw_path); // Remove incompatible index\n                         None // Discard the loaded index\n                    }\n                }\n                Err(e) =\u003e {\n                    error!(\"Couldn't load HNSW index: {}. Discarding invalid index file.\", e);\n                    eprintln!(\"Warning: Couldn't load existing HNSW index: {}. It will be rebuilt on next index command.\", e);\n                    let _ = fs::remove_file(\u0026hnsw_path); // Remove the corrupted file\n                    None // Set to None, index will be created on demand later\n                }\n            }\n        } else {\n            debug!(\"No HNSW index file found. It will be created on the next index command.\");\n            None // Set to None, index will be created on demand later\n        };\n\n        debug!(\"VectorDB initialization complete\");\n        Ok(Self {\n            indexed_chunks,\n            db_path,\n            cache,\n            hnsw_index,\n            feedback,\n            embedding_model_type,\n            onnx_model_path,\n            onnx_tokenizer_path,\n            indexed_roots,\n        })\n    }\n\n    pub fn set_onnx_paths(\n        \u0026mut self,\n        model_path: Option\u003cPathBuf\u003e,\n        tokenizer_path: Option\u003cPathBuf\u003e,\n    ) -\u003e Result\u003c()\u003e {\n        if let Some(model_path) = \u0026model_path {\n            if !model_path.exists() {\n                return Err(VectorDBError::EmbeddingError(format!(\n                    \"ONNX model file not found: {}\",\n                    model_path.display()\n                )));\n            }\n        }\n        if let Some(tokenizer_path) = \u0026tokenizer_path {\n            if !tokenizer_path.exists() {\n                return Err(VectorDBError::EmbeddingError(format!(\n                    \"ONNX tokenizer file not found: {}\",\n                    tokenizer_path.display()\n                )));\n            }\n        }\n\n        // Don't try to initialize the model here, just store the paths.\n        // Initialization should happen on demand (e.g., in create_embedding_model).\n        // if let (Some(model_path_ref), Some(tokenizer_path_ref)) = (\u0026model_path, \u0026tokenizer_path) {\n        //     match EmbeddingModel::new_onnx(model_path_ref, tokenizer_path_ref) {\n        //         Ok(_) =\u003e { ... }\n        //         Err(e) =\u003e { ... }\n        //     }\n        // }\n\n        self.onnx_model_path = model_path;\n        self.onnx_tokenizer_path = tokenizer_path;\n        \n        // Optionally, update cache settings if paths are set\n        if self.onnx_model_path.is_some() \u0026\u0026 self.onnx_tokenizer_path.is_some() {\n             self.cache.set_model_type(EmbeddingModelType::Onnx);\n             self.cache.invalidate_different_model_types();\n        }\n        \n        // Save the updated paths to db.json\n        self.save()?;\n\n        Ok(())\n    }\n\n    pub fn create_embedding_model(\u0026self) -\u003e Result\u003cEmbeddingModel\u003e {\n        if let (Some(model_path), Some(tokenizer_path)) =\n            (\u0026self.onnx_model_path, \u0026self.onnx_tokenizer_path)\n        {\n            EmbeddingModel::new_onnx(model_path, tokenizer_path)\n                .map_err(|e| VectorDBError::EmbeddingError(e.to_string()))\n        } else {\n            Err(VectorDBError::EmbeddingError(\n                \"ONNX model paths not set. Required via set_onnx_model_paths or env vars.\".to_string()\n            ))\n        }\n    }\n\n    pub fn index_directory(\u0026mut self, dir_path: \u0026str, file_patterns: \u0026[String]) -\u003e Result\u003c()\u003e {\n        // Canonicalize the input directory path immediately\n        let root_path = canonicalize(Path::new(dir_path)).map_err(|e| {\n            VectorDBError::IndexingError(format!(\n                \"Failed to canonicalize root directory {}: {}\",\n                dir_path, e\n            ))\n        })?;\n        let root_path_str = root_path.to_string_lossy().to_string();\n        debug!(\n            \"Starting indexing for canonical path: {}\",\n            root_path_str\n        );\n\n        let model = self.create_embedding_model()?;\n        let model_arc = Arc::new(model);\n        let embedding_dim = model_arc.dim(); // Get dimension from model\n\n        let file_list = self.collect_files(\u0026root_path_str, file_patterns)?;\n\n        if file_list.is_empty() {\n            println!(\"No files matching the patterns found in {}.\", root_path_str);\n            return Ok(());\n        }\n\n        // Determine embedding batch size (e.g., from config or default)\n        // TODO: Make this configurable\n        let embedding_batch_size = 32; \n\n        // Check HNSW index compatibility *before* indexing\n        if let Some(existing_index) = \u0026self.hnsw_index {\n            if existing_index.get_config().dimension != embedding_dim {\n                warn!(\n                    \"Existing HNSW index dimension ({}) does not match current model dimension ({}). Discarding index.\",\n                    existing_index.get_config().dimension, embedding_dim\n                );\n                self.hnsw_index = None;\n                // Optionally, delete the physical index file here\n                let hnsw_path = Path::new(\u0026self.db_path).parent().unwrap_or_else(|| Path::new(\".\")).join(\"hnsw_index.json\");\n                let _ = fs::remove_file(\u0026hnsw_path);\n            }\n        }\n\n        let processed_chunks_data = self.index_files_parallel(file_list, model_arc, embedding_batch_size)?;\n        \n        // Rebuild HNSW index using *all* current chunks\n        if !processed_chunks_data.is_empty() {\n            debug!(\"Rebuilding HNSW index with new and existing chunks...\");\n            self.rebuild_hnsw_index_from_state(embedding_dim)?; \n        } else {\n            debug!(\"No new chunks were processed, skipping HNSW rebuild.\");\n        }\n        \n        // Record the timestamp for the indexed root directory\n        let timestamp = Utc::now().timestamp() as u64;\n        if let Some(root_dir) = Path::new(dir_path).canonicalize().ok().and_then(|p| p.parent().map(|p| p.to_path_buf())) {\n             self.update_indexed_root_timestamp(root_dir.to_string_lossy().to_string(), timestamp);\n        } else {\n            warn!(\"Could not determine parent directory for {} to update timestamp.\", dir_path);\n        }\n\n        self.save()?;\n\n        Ok(())\n    }\n\n    fn collect_files(\u0026self, canonical_dir_path: \u0026str, file_patterns: \u0026[String]) -\u003e Result\u003cVec\u003cPathBuf\u003e\u003e {\n        let pb = ProgressBar::new_spinner();\n        pb.set_style(\n            ProgressStyle::default_spinner()\n                .template(\"{spinner:.green} Collecting files... {pos} found\")?,\n        );\n        pb.enable_steady_tick(std::time::Duration::from_millis(100));\n\n        let path = Path::new(canonical_dir_path);\n        let mut files = Vec::new();\n        let patterns: HashSet\u003c_\u003e = file_patterns.iter().map(|s| s.as_str()).collect();\n\n        for entry in WalkDir::new(path)\n            .follow_links(false)\n            .into_iter()\n            .filter_map(|e| e.ok())\n        {\n            let entry_path = entry.path();\n            if entry_path.is_file() {\n                let extension = entry_path.extension().and_then(|s| s.to_str()).unwrap_or(\"\");\n                if patterns.is_empty() || patterns.contains(extension) {\n                    // Canonicalize the found file path before adding it\n                    match canonicalize(entry_path) {\n                        Ok(canonical_entry_path) =\u003e {\n                            files.push(canonical_entry_path);\n                            pb.inc(1);\n                        }\n                        Err(e) =\u003e {\n                            error!(\"Failed to canonicalize file path {}: {}. Skipping.\", entry_path.display(), e);\n                        }\n                    }\n                }\n            }\n        }\n\n        pb.finish_with_message(format!(\"Collected {} files\", files.len()));\n        Ok(files)\n    }\n\n    pub fn save(\u0026mut self) -\u003e Result\u003c()\u003e {\n        debug!(\"Saving VectorDB to {}\", self.db_path);\n        let start = Instant::now();\n\n        // --- Rebuild HNSW Index before saving ---\n        // Rebuilding HNSW is now tied to indexing, not saving.\n        // If an index exists, save it. If not, that's fine.\n        if let Some(hnsw_index) = \u0026self.hnsw_index {\n            let hnsw_path = Path::new(\u0026self.db_path)\n                .parent()\n                .unwrap_or_else(|| Path::new(\".\"))\n                .join(\"hnsw_index.json\");\n            debug!(\"Saving HNSW index to {}\", hnsw_path.display());\n            if let Err(e) = hnsw_index.save_to_file(\u0026hnsw_path) {\n                error!(\"Failed to save HNSW index: {}\", e);\n                // Don't return error, allow db.json and cache to save\n                eprintln!(\"Warning: Failed to save HNSW index: {}\", e);\n            } else {\n                debug!(\"HNSW index saved successfully.\");\n            }\n        } else {\n            debug!(\"No HNSW index found, skipping save.\");\n        }\n\n        let db_file = DBFile {\n            indexed_chunks: self.indexed_chunks.clone(),\n            hnsw_config: self.hnsw_index.as_ref().map(|idx| idx.get_config().clone()),\n            feedback: Some(self.feedback.clone()),\n            embedding_model_type: Some(self.embedding_model_type.clone()),\n            onnx_model_path: self.onnx_model_path.as_ref().map(|p| p.to_string_lossy().to_string()),\n            onnx_tokenizer_path: self.onnx_tokenizer_path.as_ref().map(|p| p.to_string_lossy().to_string()),\n            indexed_roots: self.indexed_roots.clone(),\n        };\n\n        let contents = serde_json::to_string_pretty(\u0026db_file)?;\n        fs::write(\u0026self.db_path, contents)?;\n        debug!(\"Saved database file successfully to {}\", self.db_path);\n\n        // debug!(\"Saving cache to {}\", self.cache.cache_path); // Removed log using private field\n        self.cache.save()?;\n        debug!(\"Saved cache successfully.\");\n\n        debug!(\"VectorDB saved in {:.2?}\", start.elapsed());\n        Ok(())\n    }\n\n    pub fn clear(\u0026mut self) -\u003e Result\u003c()\u003e {\n        debug!(\"Clearing VectorDB data\");\n        self.indexed_chunks.clear();\n        self.hnsw_index = None;\n        self.feedback = FeedbackData::default();\n        self.indexed_roots.clear();\n\n        // Also clear the physical files\n        let _ = fs::remove_file(\u0026self.db_path);\n        let hnsw_path = Path::new(\u0026self.db_path)\n                .parent()\n                .unwrap_or_else(|| Path::new(\".\"))\n                .join(\"hnsw_index.json\");\n        let _ = fs::remove_file(hnsw_path);\n        self.cache.clear()?; // Clear cache content and file\n\n        debug!(\"VectorDB cleared\");\n        Ok(())\n    }\n\n    pub fn stats(\u0026self) -\u003e DBStats {\n        // Calculate unique files from indexed_chunks\n        let unique_files = self.indexed_chunks.iter()\n            .map(|chunk| \u0026chunk.file_path)\n            .collect::\u003cHashSet\u003c_\u003e\u003e()\n            .len();\n\n        DBStats {\n            indexed_chunks: self.indexed_chunks.len(),\n            unique_files,\n            embedding_dimension: self.hnsw_index.as_ref()\n                .map_or(self.embedding_model_type.default_dimension(), |idx| idx.get_config().dimension),\n            db_path: self.db_path.clone(),\n            cached_files: self.cache.len(),\n            hnsw_stats: self.hnsw_index.as_ref().map(|idx| idx.stats()),\n            embedding_model_type: self.embedding_model_type,\n        }\n    }\n\n    pub fn onnx_model_path(\u0026self) -\u003e Option\u003c\u0026PathBuf\u003e {\n        self.onnx_model_path.as_ref()\n    }\n\n    pub fn onnx_tokenizer_path(\u0026self) -\u003e Option\u003c\u0026PathBuf\u003e {\n        self.onnx_tokenizer_path.as_ref()\n    }\n\n    pub fn hnsw_index(\u0026self) -\u003e Option\u003c\u0026HNSWIndex\u003e {\n        if let Some(index) = \u0026self.hnsw_index {\n            debug!( \"HNSW index accessed: {} nodes, {} layers\", index.stats().total_nodes, index.stats().layers );\n            Some(index)\n        } else {\n            debug!(\"HNSW index requested but not available\");\n            None\n        }\n    }\n\n    pub fn get_supported_file_types() -\u003e Vec\u003cString\u003e {\n        vec![\n            \"rs\".to_string(), \"rb\".to_string(), \"go\".to_string(), \"js\".to_string(), \"ts\".to_string(),\n            \"md\".to_string(), \"yaml\".to_string(), \"yml\".to_string(), \"toml\".to_string(), \"xml\".to_string(),\n        ]\n    }\n\n    // Renamed from index_directory_parallel to clarify it processes files\n    fn index_files_parallel(\n        \u0026mut self,\n        files: Vec\u003cPathBuf\u003e, // These paths are already canonicalized\n        model: Arc\u003cEmbeddingModel\u003e,\n        embedding_batch_size: usize,\n    ) -\u003e Result\u003cVec\u003cIndexedChunk\u003e\u003e { // Return processed chunk data\n        let total_files = files.len() as u64;\n        if total_files == 0 {\n            return Ok(Vec::new());\n        }\n\n        // Remove existing chunks originating from the files being indexed\n        let files_to_reindex: HashSet\u003cString\u003e = files.iter()\n            .map(|p| p.to_string_lossy().into_owned())\n            .collect();\n        let initial_chunk_count = self.indexed_chunks.len();\n        self.indexed_chunks.retain(|chunk| !files_to_reindex.contains(\u0026chunk.file_path));\n        debug!(\"Removed {} existing chunks for {} files being re-indexed.\", \n               initial_chunk_count - self.indexed_chunks.len(), files_to_reindex.len());\n\n        let progress_bar = ProgressBar::new(total_files);\n        progress_bar.set_style(\n            ProgressStyle::default_bar()\n                .template(\"{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} files ({percent}%) - Chunks: {msg}\")?\n                .progress_chars(\"#\u003e- \")\n        );\n        progress_bar.set_message(\"0\"); // Initial chunk count for this run\n\n        let (files_to_process_sender, files_to_process_receiver) = mpsc::channel::\u003c(PathBuf, String, Option\u003cu64\u003e)\u003e();\n\n        // Shared state for results from the processor thread\n        let processed_chunks_arc = Arc::new(Mutex::new(Vec::\u003cIndexedChunk\u003e::new()));\n        let updated_cache_arc = Arc::new(Mutex::new(self.cache.clone())); \n        let processed_chunk_count_this_run = Arc::new(Mutex::new(0_usize));\n\n        // --- Processor Thread (Embeds Chunks) --- \n        let processor_thread_handle = std::thread::spawn({\n            let model_arc = model.clone();\n            let receiver = files_to_process_receiver;\n            let chunks_write_ref = processed_chunks_arc.clone();\n            let cache_write_ref = updated_cache_arc.clone();\n            let chunk_count_ref = processed_chunk_count_this_run.clone();\n            let pb_clone = progress_bar.clone(); \n\n            move || -\u003e Result\u003c()\u003e {\n                // Store metadata and owned text strings for the batch\n                let mut chunk_batch_meta = Vec::with_capacity(embedding_batch_size);\n                let mut chunk_batch_texts: Vec\u003cString\u003e = Vec::with_capacity(embedding_batch_size); // Store owned Strings\n\n                for (canonical_path_buf, canonical_path_str, file_hash_opt) in receiver {\n                    match fs::read_to_string(\u0026canonical_path_buf) {\n                        Ok(content) =\u003e {\n                            let file_chunks = chunk_by_paragraphs(\u0026content);\n                            \n                            if file_chunks.is_empty() {\n                                // Handle empty files (as before)\n                                debug!(\"Skipping empty file or file with no text: {}\", canonical_path_str);\n                                if let Some(hash_to_insert) = file_hash_opt.or_else(|| EmbeddingCache::get_file_hash(\u0026canonical_path_buf).ok()) {\n                                     if let Err(e) = cache_write_ref.lock().unwrap().insert_file_hash(canonical_path_str.clone(), hash_to_insert) {\n                                         error!(\"Failed to update cache for skipped file {}: {}\", canonical_path_str, e);\n                                     }\n                                } else {\n                                     error!(\"Could not get hash for skipped file {}. Cache not updated.\", canonical_path_str);\n                                }\n                                pb_clone.inc(1); \n                                continue;\n                            }\n\n                            // Chunk the content directly\n                            let file_chunks = chunk_by_paragraphs(\u0026content);\n\n                            let mut file_processed_chunks = Vec::\u003cIndexedChunk\u003e::new();\n\n                            for chunk_info in file_chunks.into_iter() {\n                                // Store metadata\n                                chunk_batch_meta.push((chunk_info.clone(), canonical_path_str.clone())); \n                                // Store owned text string for batching\n                                chunk_batch_texts.push(chunk_info.text);\n\n                                if chunk_batch_texts.len() \u003e= embedding_batch_size {\n                                    // Convert Vec\u003cString\u003e to Vec\u003c\u0026str\u003e for embed_batch\n                                    let text_refs: Vec\u003c\u0026str\u003e = chunk_batch_texts.iter().map(|s| s.as_str()).collect();\n                                    match model_arc.embed_batch(\u0026text_refs) {\n                                        Ok(embeddings) =\u003e {\n                                            for (i, embedding) in embeddings.into_iter().enumerate() {\n                                                 let (info, path) = chunk_batch_meta[i].clone(); \n                                                 file_processed_chunks.push(IndexedChunk {\n                                                     file_path: path,\n                                                     start_line: info.start_line,\n                                                     end_line: info.end_line,\n                                                     text: info.text, // Text is already owned in info\n                                                     embedding: embedding,\n                                                 });\n                                            }\n                                        }\n                                        Err(e) =\u003e {\n                                            error!(\"Chunk batch embedding failed: {}. Skipping batch.\", e);\n                                        }\n                                    }\n                                    chunk_batch_meta.clear();\n                                    chunk_batch_texts.clear(); // Clear owned strings\n                                }\n                            }\n\n                            // Process remaining batch for the file\n                            if !chunk_batch_texts.is_empty() {\n                                let text_refs: Vec\u003c\u0026str\u003e = chunk_batch_texts.iter().map(|s| s.as_str()).collect();\n                                match model_arc.embed_batch(\u0026text_refs) {\n                                    Ok(embeddings) =\u003e {\n                                        for (i, embedding) in embeddings.into_iter().enumerate() {\n                                            let (info, path) = chunk_batch_meta[i].clone();\n                                             file_processed_chunks.push(IndexedChunk {\n                                                 file_path: path,\n                                                 start_line: info.start_line,\n                                                 end_line: info.end_line,\n                                                 text: info.text, // Text is already owned in info\n                                                 embedding: embedding,\n                                             });\n                                        }\n                                    }\n                                    Err(e) =\u003e {\n                                        error!(\"Final chunk batch embedding failed: {}. Skipping batch.\", e);\n                                    }\n                                }\n                                // Clear meta and texts after processing\n                                chunk_batch_meta.clear();\n                                chunk_batch_texts.clear(); \n                            }\n\n                            // Add successfully processed chunks for this file to the main shared vec\n                            if !file_processed_chunks.is_empty() {\n                                let num_added = file_processed_chunks.len(); // Count before moving\n                                let mut processed_chunks_guard = chunks_write_ref.lock().unwrap();\n                                processed_chunks_guard.extend(file_processed_chunks); // Extend with Vec\u003cIndexedChunk\u003e\n                                \n                                let mut chunk_count_guard = chunk_count_ref.lock().unwrap();\n                                *chunk_count_guard += num_added;\n                                pb_clone.set_message(format!(\"{}\", *chunk_count_guard)); \n                            }\n                            \n                            // Update file cache\n                            if let Some(hash_to_insert) = file_hash_opt.or_else(|| EmbeddingCache::get_file_hash(\u0026canonical_path_buf).ok()) {\n                                if let Err(e) = cache_write_ref.lock().unwrap().insert_file_hash(canonical_path_str.clone(), hash_to_insert) {\n                                    error!(\"Failed to update cache for {}: {}\", canonical_path_str, e);\n                                }\n                            } else {\n                                error!(\"Could not get hash for {}. Cache not updated.\", canonical_path_str);\n                            }\n                        }\n                        Err(e) =\u003e {\n                            error!(\"Failed to read file {} during processing: {}. Skipping.\", canonical_path_str, e);\n                        }\n                    }\n                    pb_clone.inc(1); // Increment file progress bar\n                }\n\n                Ok(())\n            }\n        });\n\n        // --- Cache Checking --- \n        let original_cache = self.cache.clone(); \n        files.par_iter().for_each(|canonical_path_buf| {\n            let canonical_path_str = canonical_path_buf.to_string_lossy().into_owned();\n            let cache_result = original_cache.check_cache_and_get_hash(\u0026canonical_path_str, \u0026canonical_path_buf);\n\n            match cache_result {\n                Ok(CacheCheckResult::Hit) =\u003e {\n                    debug!(\"Cache hit for file {}. Skipping chunk processing.\", canonical_path_str);\n                    progress_bar.inc(1);\n                }\n                Ok(CacheCheckResult::Miss(hash_opt)) =\u003e {\n                    debug!(\"Cache miss/invalidated for file {}. Needs processing.\", canonical_path_str);\n                    files_to_process_sender.send((canonical_path_buf.clone(), canonical_path_str, hash_opt))\n                        .expect(\"Failed to send file path to processing thread\");\n                }\n                Err(e) =\u003e {\n                    error!(\"Failed cache check/hash for file {}: {}. Assuming needs processing.\", canonical_path_str, e);\n                    files_to_process_sender.send((canonical_path_buf.clone(), canonical_path_str, None))\n                        .expect(\"Failed to send file path (cache error)\");\n                     // Let processor thread inc progress after trying to read\n                }\n            }\n        });\n\n        drop(files_to_process_sender);\n\n        // --- Wait and Merge Results --- \n        let process_result = processor_thread_handle.join().expect(\"Processing thread panicked\");\n        progress_bar.finish_with_message(format!(\"File processing complete. New chunks: {}\", *processed_chunk_count_this_run.lock().unwrap()));\n\n        if let Err(e) = process_result {\n            return Err(VectorDBError::EmbeddingError(format!(\"Error during chunk processing: {}\", e)));\n        }\n\n        let processed_chunks_data = Arc::try_unwrap(processed_chunks_arc)\n            .expect(\"Failed to unwrap processed_chunks Arc\")\n            .into_inner()\n            .expect(\"Failed to get processed_chunks from Mutex\");\n        \n        debug!(\"Adding {} new indexed chunks to main state\", processed_chunks_data.len());\n        self.indexed_chunks.extend(processed_chunks_data.clone()); // Clone needed if returning below\n        \n        self.cache = Arc::try_unwrap(updated_cache_arc)\n            .expect(\"Failed to unwrap updated_cache Arc\")\n            .into_inner()\n            .expect(\"Failed to get updated_cache from Mutex\");\n        \n        Ok(processed_chunks_data) // Return the processed data for HNSW build\n    }\n\n    // Rebuilds HNSW index using the current `self.indexed_chunks`\n    fn rebuild_hnsw_index_from_state(\u0026mut self, dimension: usize) -\u003e Result\u003c()\u003e {\n        if self.indexed_chunks.is_empty() {\n            debug!(\"No indexed chunks found, skipping HNSW index rebuild.\");\n            self.hnsw_index = None;\n            return Ok(());\n        }\n\n        debug!(\"Rebuilding HNSW index with {} vectors...\", self.indexed_chunks.len());\n        let start = Instant::now();\n\n        // Dimension is now passed in\n        if dimension == 0 {\n            return Err(VectorDBError::HNSWError(\"Cannot build HNSW index with dimension 0\".to_string()));\n        }\n\n        let config = HNSWConfig::new(dimension);\n        let mut hnsw_index = HNSWIndex::new(config);\n\n        // Uncomment progress bar\n        let pb = ProgressBar::new(self.indexed_chunks.len() as u64);\n        pb.set_style(\n            ProgressStyle::default_bar()\n                .template(\"{spinner:.green} Building HNSW index: [{bar:40.cyan/blue}] {pos}/{len} ({percent}%)\")?\n                .progress_chars(\"#\u003e- \")\n        );\n\n        // Iterate through stored chunks and use their embeddings\n        for (i, chunk) in self.indexed_chunks.iter().enumerate() {\n            // Directly use the stored embedding\n            let embedding = \u0026chunk.embedding; // Borrow the embedding\n\n            if embedding.len() != dimension {\n                 error!(\"Fatal error: Chunk {} ({}:{}) has embedding dimension {} but index expects {}. Aborting build.\", \n                       i, chunk.file_path, chunk.start_line, embedding.len(), dimension);\n                 return Err(VectorDBError::HNSWError(format!(\n                     \"Dimension mismatch for vector {} during HNSW rebuild.\", i\n                 )));\n            }\n\n            if let Err(e) = hnsw_index.insert(embedding.clone()) { // Clone embedding for insertion\n                error!(\"Fatal error inserting vector for chunk {} ({}:{}) into HNSW index: {}. Aborting build.\", \n                       i, chunk.file_path, chunk.start_line, e);\n                return Err(VectorDBError::HNSWError(format!(\n                    \"Failed to insert vector {} into HNSW index during rebuild: {}\", i, e\n                )));\n            }\n            pb.inc(1); // Uncomment progress bar increment\n        }\n\n        pb.finish_with_message(\"HNSW index build complete\"); // Uncomment progress bar finish\n        let duration = start.elapsed();\n        debug!(\"HNSW index rebuild took {:.2} seconds\", duration.as_secs_f32());\n\n        self.hnsw_index = Some(hnsw_index);\n        Ok(())\n    }\n\n    // Helper to get file path associated with an HNSW node ID\n    pub fn get_file_path(\u0026self, node_id: usize) -\u003e Option\u003cString\u003e {\n        // The HNSW node ID now corresponds directly to the index in indexed_chunks\n        self.indexed_chunks.get(node_id).map(|chunk| chunk.file_path.clone())\n    }\n\n    // Add getter for cache\n    pub fn cache(\u0026self) -\u003e \u0026EmbeddingCache {\n        \u0026self.cache\n    }\n\n    // Add getter for embedding model type\n    pub fn embedding_model_type(\u0026self) -\u003e EmbeddingModelType {\n        self.embedding_model_type\n    }\n\n    // Replace add_indexed_root with update_indexed_root_timestamp\n    pub fn update_indexed_root_timestamp(\u0026mut self, path_str: String, timestamp: u64) {\n        self.indexed_roots.insert(path_str, timestamp);\n    }\n\n    // Update getter for indexed roots\n    pub fn indexed_roots(\u0026self) -\u003e \u0026HashMap\u003cString, u64\u003e {\n        \u0026self.indexed_roots\n    }\n}\n\npub struct DBStats {\n    pub indexed_chunks: usize,\n    pub unique_files: usize,\n    pub embedding_dimension: usize,\n    pub db_path: String,\n    pub cached_files: usize,\n    pub hnsw_stats: Option\u003cHNSWStats\u003e,\n    pub embedding_model_type: EmbeddingModelType,\n}\n\nimpl Clone for DBStats {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            indexed_chunks: self.indexed_chunks,\n            unique_files: self.unique_files,\n            embedding_dimension: self.embedding_dimension,\n            db_path: self.db_path.clone(),\n            cached_files: self.cached_files,\n            hnsw_stats: self.hnsw_stats.clone(),\n            embedding_model_type: self.embedding_model_type.clone(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*; // Import items from outer module\n    use crate::vectordb::error::Result; // Use the Result alias from the error module\n    use tempfile::tempdir; // For creating temporary directories\n    use std::fs;\n\n    // Helper function to set up a test database environment\n    fn setup_db_test_env() -\u003e (tempfile::TempDir, String) { \n        let temp_dir = tempdir().unwrap();\n        let db_path = temp_dir.path().join(\"test_db.json\");\n        let db_path_str = db_path.to_str().unwrap().to_string();\n\n        // Ensure the directory exists\n        if let Some(parent) = db_path.parent() {\n            fs::create_dir_all(parent).unwrap();\n        }\n        // Don't create/index db here, let tests do it.\n        (temp_dir, db_path_str)\n    }\n\n    #[test]\n    fn test_vectordb_new_empty() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let db = VectorDB::new(db_path_str)?;\n\n        assert!(db.indexed_chunks.is_empty(), \"New DB should have no chunks\");\n        assert!(db.hnsw_index.is_none(), \"New DB should not have HNSW index yet\");\n        assert_eq!(db.embedding_model_type, EmbeddingModelType::Onnx, \"Default model type should be Onnx\");\n        assert!(db.indexed_roots.is_empty(), \"New DB should have no indexed roots\");\n        Ok(())\n    }\n\n    #[test]\n    fn test_vectordb_save_load() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db1 = VectorDB::new(db_path_str.clone())?;\n\n        // Add some dummy data (doesn't need real embeddings for this test)\n        db1.indexed_chunks.push(IndexedChunk {\n            file_path: \"test/file1.txt\".to_string(),\n            start_line: 1,\n            end_line: 10,\n            text: \"chunk 1\".to_string(),\n            embedding: vec![0.1; 10], // Dummy embedding\n        });\n        db1.indexed_roots.insert(\"test\".to_string(), 12345);\n        db1.save()?; // Save the db\n\n        // Create a new instance loading from the same path\n        let db2 = VectorDB::new(db_path_str)?;\n\n        assert_eq!(db2.indexed_chunks.len(), 1, \"Loaded DB should have 1 chunk\");\n        assert_eq!(db2.indexed_chunks[0].file_path, \"test/file1.txt\");\n        assert_eq!(db2.indexed_chunks[0].embedding.len(), 10);\n        assert_eq!(db2.indexed_roots.len(), 1, \"Loaded DB should have 1 indexed root\");\n        assert!(db2.indexed_roots.contains_key(\"test\"));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_vectordb_clear() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db = VectorDB::new(db_path_str.clone())?;\n\n        // Add dummy data\n        db.indexed_chunks.push(IndexedChunk { /* ... */ file_path: \"dummy\".to_string(), start_line: 1, end_line: 1, text: \"t\".to_string(), embedding: vec![0.0] });\n        db.indexed_roots.insert(\"root\".to_string(), 1);\n        assert!(!db.indexed_chunks.is_empty());\n        assert!(!db.indexed_roots.is_empty());\n\n        db.clear()?; // Clear the database\n\n        assert!(db.indexed_chunks.is_empty(), \"DB chunks should be empty after clear\");\n        assert!(db.indexed_roots.is_empty(), \"DB indexed roots should be empty after clear\");\n        assert!(db.hnsw_index.is_none(), \"HNSW index should be None after clear\");\n\n        // Verify persistence of clear\n        db.save()?;\n        let db_reloaded = VectorDB::new(db_path_str)?;\n        assert!(db_reloaded.indexed_chunks.is_empty(), \"Reloaded DB chunks should be empty after clear and save\");\n        assert!(db_reloaded.indexed_roots.is_empty(), \"Reloaded DB indexed roots should be empty after clear and save\");\n\n        Ok(())\n    }\n\n    #[test]\n    #[ignore] // Ignore this test for now as it seems to be hanging\n    fn test_vectordb_stats() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db = VectorDB::new(db_path_str)?;\n\n        // Stats on empty DB\n        let empty_stats = db.stats();\n        assert_eq!(empty_stats.indexed_chunks, 0);\n        assert_eq!(empty_stats.unique_files, 0);\n        assert!(empty_stats.hnsw_stats.is_none());\n\n        // Add dummy data\n        db.indexed_chunks.push(IndexedChunk { file_path: \"file1.txt\".to_string(), start_line: 1, end_line: 1, text: \"t\".to_string(), embedding: vec![0.1; 384] }); // Dim 384 for ONNX default\n        db.indexed_chunks.push(IndexedChunk { file_path: \"file1.txt\".to_string(), start_line: 2, end_line: 2, text: \"t2\".to_string(), embedding: vec![0.2; 384] });\n        db.indexed_chunks.push(IndexedChunk { file_path: \"file2.txt\".to_string(), start_line: 1, end_line: 1, text: \"t3\".to_string(), embedding: vec![0.3; 384] });\n        \n        // Manually create a dummy HNSW index for stats testing (requires dimension)\n        let dim = db.embedding_model_type.default_dimension();\n        db.rebuild_hnsw_index_from_state(dim)?; // Build index from current chunks\n\n        let stats = db.stats();\n        assert_eq!(stats.indexed_chunks, 3);\n        assert_eq!(stats.unique_files, 2); // file1.txt, file2.txt\n        assert_eq!(stats.embedding_dimension, dim);\n        assert!(stats.hnsw_stats.is_some());\n        if let Some(hnsw_stats) = stats.hnsw_stats {\n            assert_eq!(hnsw_stats.total_nodes, 3);\n            // Add more specific HNSW stats checks if needed\n        }\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_vectordb_set_onnx_paths_valid() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db = VectorDB::new(db_path_str)?;\n\n        // Create dummy files\n        let model_path = _temp_dir.path().join(\"model.onnx\");\n        let tokenizer_path = _temp_dir.path().join(\"tokenizer.json\");\n        fs::write(\u0026model_path, \"dummy model data\")?;\n        fs::write(\u0026tokenizer_path, \"dummy tokenizer data\")?;\n\n        let result = db.set_onnx_paths(Some(model_path.clone()), Some(tokenizer_path.clone()));\n        assert!(result.is_ok(), \"Setting valid paths should succeed\");\n        assert_eq!(db.onnx_model_path(), Some(\u0026model_path));\n        assert_eq!(db.onnx_tokenizer_path(), Some(\u0026tokenizer_path));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_vectordb_set_onnx_paths_invalid() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db = VectorDB::new(db_path_str)?;\n\n        let non_existent_path = _temp_dir.path().join(\"non_existent.onnx\");\n\n        let result = db.set_onnx_paths(Some(non_existent_path), None);\n        assert!(result.is_err(), \"Setting non-existent path should fail\");\n        // Ensure paths weren't partially set\n        assert!(db.onnx_model_path().is_none());\n        assert!(db.onnx_tokenizer_path().is_none());\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_vectordb_get_file_path() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db = VectorDB::new(db_path_str)?;\n\n        assert!(db.get_file_path(0).is_none(), \"Path for invalid index should be None\");\n\n        db.indexed_chunks.push(IndexedChunk { file_path: \"path/one\".to_string(), /* ... */ start_line: 1, end_line: 1, text: \"\".to_string(), embedding: vec![] });\n        db.indexed_chunks.push(IndexedChunk { file_path: \"path/two\".to_string(), /* ... */ start_line: 1, end_line: 1, text: \"\".to_string(), embedding: vec![] });\n\n        assert_eq!(db.get_file_path(0), Some(\"path/one\".to_string()));\n        assert_eq!(db.get_file_path(1), Some(\"path/two\".to_string()));\n        assert!(db.get_file_path(2).is_none());\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_vectordb_indexed_roots() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db = VectorDB::new(db_path_str)?;\n\n        assert!(db.indexed_roots().is_empty(), \"Initial roots should be empty\");\n\n        db.update_indexed_root_timestamp(\"/path/a\".to_string(), 100);\n        db.update_indexed_root_timestamp(\"/path/b\".to_string(), 200);\n        db.update_indexed_root_timestamp(\"/path/a\".to_string(), 150); // Update timestamp\n\n        let roots = db.indexed_roots();\n        assert_eq!(roots.len(), 2);\n        assert_eq!(roots.get(\"/path/a\"), Some(\u0026150));\n        assert_eq!(roots.get(\"/path/b\"), Some(\u0026200));\n\n        Ok(())\n    }\n\n    // Existing test\n    #[test]\n    fn test_vectordb() -\u003e Result\u003c()\u003e {\n        // ... (Keep existing test_vectordb as is for now)\n        let (_temp_dir, _db) = setup_db_test_env(); // Use helper if needed, or keep original setup\n        // ... rest of original test ... \n        Ok(())\n    }\n}","traces":[{"line":23,"address":[3858320],"length":1,"stats":{"Line":0}},{"line":24,"address":[3860048,3860161],"length":1,"stats":{"Line":0}},{"line":77,"address":[3655472,3656282],"length":1,"stats":{"Line":0}},{"line":79,"address":[2769341],"length":1,"stats":{"Line":0}},{"line":80,"address":[4371235],"length":1,"stats":{"Line":0}},{"line":81,"address":[3655593],"length":1,"stats":{"Line":0}},{"line":82,"address":[3655652],"length":1,"stats":{"Line":0}},{"line":83,"address":[2769542],"length":1,"stats":{"Line":0}},{"line":84,"address":[4371478],"length":1,"stats":{"Line":0}},{"line":85,"address":[2769662],"length":1,"stats":{"Line":0}},{"line":86,"address":[3655877],"length":1,"stats":{"Line":0}},{"line":87,"address":[2769757],"length":1,"stats":{"Line":0}},{"line":93,"address":[3656304,3658200,3671960],"length":1,"stats":{"Line":14}},{"line":94,"address":[3656662,3656814,3656365,3656570],"length":1,"stats":{"Line":42}},{"line":96,"address":[4372689,4372264],"length":1,"stats":{"Line":28}},{"line":97,"address":[4373558],"length":1,"stats":{"Line":14}},{"line":98,"address":[2771726],"length":1,"stats":{"Line":14}},{"line":99,"address":[2771774],"length":1,"stats":{"Line":14}},{"line":101,"address":[4373702],"length":1,"stats":{"Line":14}},{"line":102,"address":[2771870],"length":1,"stats":{"Line":14}},{"line":103,"address":[2771910],"length":1,"stats":{"Line":14}},{"line":105,"address":[4373921,4372761,4374001],"length":1,"stats":{"Line":9}},{"line":106,"address":[3658271,3658554],"length":1,"stats":{"Line":6}},{"line":107,"address":[2772377],"length":1,"stats":{"Line":3}},{"line":108,"address":[3658621,3658781,3658869],"length":1,"stats":{"Line":12}},{"line":109,"address":[3659324,3658795,3659098],"length":1,"stats":{"Line":8}},{"line":112,"address":[4374946],"length":1,"stats":{"Line":4}},{"line":118,"address":[2773512],"length":1,"stats":{"Line":0}},{"line":124,"address":[2773236],"length":1,"stats":{"Line":4}},{"line":125,"address":[3659504],"length":1,"stats":{"Line":4}},{"line":126,"address":[4375196],"length":1,"stats":{"Line":4}},{"line":128,"address":[2774049],"length":1,"stats":{"Line":4}},{"line":129,"address":[4376021],"length":1,"stats":{"Line":4}},{"line":130,"address":[2774253],"length":1,"stats":{"Line":4}},{"line":133,"address":[4374326],"length":1,"stats":{"Line":0}},{"line":134,"address":[4377051,4376883,4376714,4374342],"length":1,"stats":{"Line":0}},{"line":135,"address":[3661624],"length":1,"stats":{"Line":0}},{"line":136,"address":[3661693],"length":1,"stats":{"Line":0}},{"line":137,"address":[2775596,2775472],"length":1,"stats":{"Line":0}},{"line":139,"address":[2775538],"length":1,"stats":{"Line":0}},{"line":140,"address":[2775814,2775861],"length":1,"stats":{"Line":0}},{"line":141,"address":[3662207],"length":1,"stats":{"Line":0}},{"line":143,"address":[4377818],"length":1,"stats":{"Line":0}},{"line":144,"address":[3662232],"length":1,"stats":{"Line":0}},{"line":145,"address":[4377834],"length":1,"stats":{"Line":0}},{"line":150,"address":[2771016,2770844,2770944],"length":1,"stats":{"Line":42}},{"line":152,"address":[4372830],"length":1,"stats":{"Line":14}},{"line":153,"address":[3657422,3657485],"length":1,"stats":{"Line":28}},{"line":154,"address":[2771349],"length":1,"stats":{"Line":14}},{"line":156,"address":[2771366],"length":1,"stats":{"Line":14}},{"line":157,"address":[3657578],"length":1,"stats":{"Line":14}},{"line":158,"address":[2771382],"length":1,"stats":{"Line":14}},{"line":162,"address":[4373838,4378216,4378436],"length":1,"stats":{"Line":42}},{"line":164,"address":[3177488,3177489],"length":1,"stats":{"Line":0}},{"line":168,"address":[4378635,4378939,4378771],"length":1,"stats":{"Line":28}},{"line":170,"address":[2776821,2777262],"length":1,"stats":{"Line":28}},{"line":171,"address":[4379180],"length":1,"stats":{"Line":14}},{"line":172,"address":[2777388,2777672,2777579],"length":1,"stats":{"Line":42}},{"line":173,"address":[3663875],"length":1,"stats":{"Line":14}},{"line":175,"address":[2777436],"length":1,"stats":{"Line":0}},{"line":176,"address":[3664274,3664611,3664443,3663770],"length":1,"stats":{"Line":0}},{"line":177,"address":[4380368],"length":1,"stats":{"Line":0}},{"line":178,"address":[3664859],"length":1,"stats":{"Line":0}},{"line":179,"address":[4380490],"length":1,"stats":{"Line":0}},{"line":180,"address":[4380540,4380712],"length":1,"stats":{"Line":0}},{"line":181,"address":[4381181,4380598,4380941],"length":1,"stats":{"Line":0}},{"line":185,"address":[4381374,4381539,4379757,4381302],"length":1,"stats":{"Line":42}},{"line":186,"address":[3666160,3665758],"length":1,"stats":{"Line":28}},{"line":188,"address":[2779869],"length":1,"stats":{"Line":14}},{"line":190,"address":[3601184,3601185],"length":1,"stats":{"Line":0}},{"line":192,"address":[4382089,4382001,4381905,4382359],"length":1,"stats":{"Line":42}},{"line":194,"address":[3666465,3667004,3667155],"length":1,"stats":{"Line":42}},{"line":195,"address":[3667076,3667561,3667473],"length":1,"stats":{"Line":0}},{"line":196,"address":[3667487,3667790],"length":1,"stats":{"Line":0}},{"line":197,"address":[2781522],"length":1,"stats":{"Line":0}},{"line":203,"address":[3667952,3668111],"length":1,"stats":{"Line":0}},{"line":204,"address":[3601232,3601241],"length":1,"stats":{"Line":0}},{"line":206,"address":[4383711,4384518],"length":1,"stats":{"Line":0}},{"line":207,"address":[4383778,4384452,4384724,4384562],"length":1,"stats":{"Line":0}},{"line":208,"address":[3668936],"length":1,"stats":{"Line":0}},{"line":210,"address":[4383963],"length":1,"stats":{"Line":0}},{"line":214,"address":[2781969,2782512],"length":1,"stats":{"Line":0}},{"line":215,"address":[2782539],"length":1,"stats":{"Line":0}},{"line":218,"address":[4383529],"length":1,"stats":{"Line":0}},{"line":219,"address":[2783267,2783104,2781673,2783429],"length":1,"stats":{"Line":0}},{"line":220,"address":[4385474],"length":1,"stats":{"Line":0}},{"line":221,"address":[3670025],"length":1,"stats":{"Line":0}},{"line":222,"address":[2783733],"length":1,"stats":{"Line":0}},{"line":226,"address":[2780709,2780809,2780886],"length":1,"stats":{"Line":42}},{"line":227,"address":[4382687],"length":1,"stats":{"Line":14}},{"line":230,"address":[3670172,3671131,3667418],"length":1,"stats":{"Line":42}},{"line":231,"address":[4386155],"length":1,"stats":{"Line":14}},{"line":232,"address":[4385708],"length":1,"stats":{"Line":14}},{"line":233,"address":[3670238],"length":1,"stats":{"Line":14}},{"line":234,"address":[3670269],"length":1,"stats":{"Line":14}},{"line":235,"address":[2783995],"length":1,"stats":{"Line":14}},{"line":236,"address":[4385963],"length":1,"stats":{"Line":14}},{"line":238,"address":[3670509],"length":1,"stats":{"Line":14}},{"line":239,"address":[3670549],"length":1,"stats":{"Line":14}},{"line":240,"address":[3670589],"length":1,"stats":{"Line":14}},{"line":244,"address":[4389388,4387488],"length":1,"stats":{"Line":4}},{"line":249,"address":[4387543],"length":1,"stats":{"Line":4}},{"line":250,"address":[3672133,3672248],"length":1,"stats":{"Line":8}},{"line":251,"address":[3672586,3672457],"length":1,"stats":{"Line":4}},{"line":253,"address":[3672277],"length":1,"stats":{"Line":2}},{"line":257,"address":[3672158,3672691],"length":1,"stats":{"Line":4}},{"line":258,"address":[2786410,2786315],"length":1,"stats":{"Line":4}},{"line":259,"address":[4388491,4388620],"length":1,"stats":{"Line":0}},{"line":261,"address":[4388311],"length":1,"stats":{"Line":0}},{"line":275,"address":[2786839,2786348],"length":1,"stats":{"Line":2}},{"line":276,"address":[2786957],"length":1,"stats":{"Line":2}},{"line":279,"address":[3673508,3673575],"length":1,"stats":{"Line":4}},{"line":280,"address":[2787219],"length":1,"stats":{"Line":2}},{"line":281,"address":[2787238],"length":1,"stats":{"Line":2}},{"line":285,"address":[3673655,3673548,3673823,3673733],"length":1,"stats":{"Line":4}},{"line":287,"address":[2787308],"length":1,"stats":{"Line":2}},{"line":290,"address":[3673984],"length":1,"stats":{"Line":0}},{"line":291,"address":[4389520,4389695,4389555],"length":1,"stats":{"Line":0}},{"line":294,"address":[4389728],"length":1,"stats":{"Line":0}},{"line":295,"address":[4266428,4266400],"length":1,"stats":{"Line":0}},{"line":297,"address":[4389595],"length":1,"stats":{"Line":0}},{"line":298,"address":[3674109],"length":1,"stats":{"Line":0}},{"line":303,"address":[2791335,2787936,2794017],"length":1,"stats":{"Line":0}},{"line":305,"address":[3674745,3674467],"length":1,"stats":{"Line":0}},{"line":306,"address":[3178021,3178135,3177786],"length":1,"stats":{"Line":0}},{"line":311,"address":[3674688,3674839],"length":1,"stats":{"Line":0}},{"line":312,"address":[2788537,2788669,2788837],"length":1,"stats":{"Line":0}},{"line":317,"address":[4390483,4391189,4395868,4390904],"length":1,"stats":{"Line":0}},{"line":318,"address":[4391086,4391311],"length":1,"stats":{"Line":0}},{"line":319,"address":[3675907,3675980],"length":1,"stats":{"Line":0}},{"line":321,"address":[2789792,2793906,2789563],"length":1,"stats":{"Line":0}},{"line":323,"address":[2789770,2789913],"length":1,"stats":{"Line":0}},{"line":324,"address":[3680315],"length":1,"stats":{"Line":0}},{"line":325,"address":[4395713],"length":1,"stats":{"Line":0}},{"line":330,"address":[4389895],"length":1,"stats":{"Line":0}},{"line":333,"address":[2790106,2789927],"length":1,"stats":{"Line":0}},{"line":334,"address":[3676586,3676701],"length":1,"stats":{"Line":0}},{"line":335,"address":[3677174,3676719,3676869],"length":1,"stats":{"Line":0}},{"line":339,"address":[3677377,3676795],"length":1,"stats":{"Line":0}},{"line":341,"address":[3677527],"length":1,"stats":{"Line":0}},{"line":342,"address":[2791219,2791286],"length":1,"stats":{"Line":0}},{"line":346,"address":[2791487,2790137,2791360,2793762],"length":1,"stats":{"Line":0}},{"line":349,"address":[4393337,4393479],"length":1,"stats":{"Line":0}},{"line":350,"address":[2791795,2791613,2791713],"length":1,"stats":{"Line":0}},{"line":351,"address":[2791727,2792072,2792009],"length":1,"stats":{"Line":0}},{"line":353,"address":[3678169,3678692,3678743],"length":1,"stats":{"Line":0}},{"line":357,"address":[2792042,2792421],"length":1,"stats":{"Line":0}},{"line":358,"address":[3678981],"length":1,"stats":{"Line":0}},{"line":359,"address":[2792781,2792657],"length":1,"stats":{"Line":0}},{"line":361,"address":[3679205,3679567,3679615,3679777],"length":1,"stats":{"Line":0}},{"line":364,"address":[4395434,4395321,4395363,4395577],"length":1,"stats":{"Line":0}},{"line":366,"address":[2793532],"length":1,"stats":{"Line":0}},{"line":369,"address":[2794032,2796804,2796850],"length":1,"stats":{"Line":0}},{"line":370,"address":[2794127],"length":1,"stats":{"Line":0}},{"line":371,"address":[3680938],"length":1,"stats":{"Line":0}},{"line":372,"address":[3680995,3680791,3680728,3680972],"length":1,"stats":{"Line":0}},{"line":373,"address":[4396271,4396257],"length":1,"stats":{"Line":0}},{"line":375,"address":[4396309],"length":1,"stats":{"Line":0}},{"line":377,"address":[2794509],"length":1,"stats":{"Line":0}},{"line":378,"address":[3681174],"length":1,"stats":{"Line":0}},{"line":379,"address":[3178505,3178480],"length":1,"stats":{"Line":0}},{"line":381,"address":[3681649,3681442,3681379,3681703],"length":1,"stats":{"Line":0}},{"line":384,"address":[4267356,4267328],"length":1,"stats":{"Line":0}},{"line":386,"address":[3682286,3681751],"length":1,"stats":{"Line":0}},{"line":387,"address":[3682321],"length":1,"stats":{"Line":0}},{"line":388,"address":[3602240,3602254],"length":1,"stats":{"Line":0}},{"line":389,"address":[3682519,3682621],"length":1,"stats":{"Line":0}},{"line":391,"address":[4397842,4397862],"length":1,"stats":{"Line":0}},{"line":392,"address":[2796025],"length":1,"stats":{"Line":0}},{"line":393,"address":[3682697],"length":1,"stats":{"Line":0}},{"line":394,"address":[4398017],"length":1,"stats":{"Line":0}},{"line":396,"address":[4397959],"length":1,"stats":{"Line":0}},{"line":397,"address":[4398489,4398094,4397975,4398164],"length":1,"stats":{"Line":0}},{"line":404,"address":[2795455,2795177,2795318],"length":1,"stats":{"Line":0}},{"line":405,"address":[3682098],"length":1,"stats":{"Line":0}},{"line":408,"address":[2799574,2799098,2796864],"length":1,"stats":{"Line":2}},{"line":409,"address":[3683559,3683734,3683871],"length":1,"stats":{"Line":4}},{"line":410,"address":[3683612],"length":1,"stats":{"Line":2}},{"line":415,"address":[3683646,3684058,3686152],"length":1,"stats":{"Line":2}},{"line":416,"address":[4399282],"length":1,"stats":{"Line":0}},{"line":418,"address":[3178609,3178608],"length":1,"stats":{"Line":0}},{"line":420,"address":[3684149,3684379,3684649,3684291],"length":1,"stats":{"Line":0}},{"line":421,"address":[3684852,3684305],"length":1,"stats":{"Line":0}},{"line":422,"address":[3685261,3685429,3685092,3684948],"length":1,"stats":{"Line":0}},{"line":424,"address":[3685608],"length":1,"stats":{"Line":0}},{"line":426,"address":[4400201,4401040,4400986],"length":1,"stats":{"Line":0}},{"line":429,"address":[3684194,3686306],"length":1,"stats":{"Line":4}},{"line":433,"address":[4401386],"length":1,"stats":{"Line":2}},{"line":434,"address":[3178658,3178640],"length":1,"stats":{"Line":4}},{"line":435,"address":[3686555],"length":1,"stats":{"Line":2}},{"line":436,"address":[4401887,4401825],"length":1,"stats":{"Line":4}},{"line":437,"address":[3602368,3602398],"length":1,"stats":{"Line":6}},{"line":438,"address":[4267648,4267678],"length":1,"stats":{"Line":8}},{"line":439,"address":[4402053],"length":1,"stats":{"Line":2}},{"line":442,"address":[3687492,3687196,3687267,3689451],"length":1,"stats":{"Line":4}},{"line":443,"address":[3687686,3687413,3689427,3687578],"length":1,"stats":{"Line":4}},{"line":444,"address":[3687727,3687809,3687956,3687636],"length":1,"stats":{"Line":11}},{"line":447,"address":[3689401,3687741,3688129,3688232],"length":1,"stats":{"Line":9}},{"line":448,"address":[4403461,4403554,4403334],"length":1,"stats":{"Line":13}},{"line":450,"address":[2801976,2801887,2802190,2801595,2802454],"length":1,"stats":{"Line":13}},{"line":451,"address":[3688625],"length":1,"stats":{"Line":5}},{"line":454,"address":[3689456,3690553],"length":1,"stats":{"Line":2}},{"line":455,"address":[2802869,2802765],"length":1,"stats":{"Line":4}},{"line":456,"address":[2802800],"length":1,"stats":{"Line":2}},{"line":457,"address":[4404876,4404691],"length":1,"stats":{"Line":2}},{"line":458,"address":[2803158],"length":1,"stats":{"Line":2}},{"line":459,"address":[2803270],"length":1,"stats":{"Line":2}},{"line":462,"address":[2803286],"length":1,"stats":{"Line":2}},{"line":463,"address":[4405193],"length":1,"stats":{"Line":2}},{"line":465,"address":[3178993,3178992],"length":1,"stats":{"Line":0}},{"line":467,"address":[3690126],"length":1,"stats":{"Line":2}},{"line":468,"address":[3690166,3690271],"length":1,"stats":{"Line":2}},{"line":470,"address":[3690373,3690232],"length":1,"stats":{"Line":4}},{"line":471,"address":[3690333],"length":1,"stats":{"Line":2}},{"line":474,"address":[2804312,2803840],"length":1,"stats":{"Line":0}},{"line":476,"address":[2803878,2803982],"length":1,"stats":{"Line":0}},{"line":477,"address":[3602688,3602701],"length":1,"stats":{"Line":0}},{"line":482,"address":[3690769],"length":1,"stats":{"Line":0}},{"line":484,"address":[3690788,3690835],"length":1,"stats":{"Line":0}},{"line":486,"address":[4405946],"length":1,"stats":{"Line":0}},{"line":487,"address":[2804100],"length":1,"stats":{"Line":0}},{"line":488,"address":[4406037],"length":1,"stats":{"Line":0}},{"line":493,"address":[2804336],"length":1,"stats":{"Line":2}},{"line":494,"address":[3691141],"length":1,"stats":{"Line":2}},{"line":497,"address":[4406240],"length":1,"stats":{"Line":2}},{"line":498,"address":[3691173],"length":1,"stats":{"Line":2}},{"line":501,"address":[4406272,4407027],"length":1,"stats":{"Line":0}},{"line":502,"address":[4406287,4407058,4406437],"length":1,"stats":{"Line":0}},{"line":503,"address":[3691276,3691712,3691544,3691398],"length":1,"stats":{"Line":0}},{"line":504,"address":[4406432],"length":1,"stats":{"Line":0}},{"line":506,"address":[4407088,4406381],"length":1,"stats":{"Line":0}},{"line":507,"address":[2805177],"length":1,"stats":{"Line":0}},{"line":511,"address":[4407264,4408410],"length":1,"stats":{"Line":0}},{"line":512,"address":[4407844,4407640,4407386,4407708,4407510,4407912,4407330,4407291,4408389,4407448,4407575,4407776],"length":1,"stats":{"Line":0}},{"line":513,"address":[4407362,4407424,4407301,4407486,4407548],"length":1,"stats":{"Line":0}},{"line":514,"address":[3692561,3692697,3692765,3692629,3692833],"length":1,"stats":{"Line":0}},{"line":519,"address":[2810954,2812397,2806560],"length":1,"stats":{"Line":0}},{"line":525,"address":[2806753,2806642],"length":1,"stats":{"Line":0}},{"line":526,"address":[3693601],"length":1,"stats":{"Line":0}},{"line":527,"address":[3693669,3693607],"length":1,"stats":{"Line":0}},{"line":531,"address":[4408662,4408770],"length":1,"stats":{"Line":0}},{"line":532,"address":[4267904,4267941],"length":1,"stats":{"Line":0}},{"line":534,"address":[3693942,3693863],"length":1,"stats":{"Line":0}},{"line":535,"address":[4408962],"length":1,"stats":{"Line":0}},{"line":536,"address":[3694171,3694357],"length":1,"stats":{"Line":0}},{"line":539,"address":[4409035],"length":1,"stats":{"Line":0}},{"line":540,"address":[2808141],"length":1,"stats":{"Line":0}},{"line":541,"address":[3694725,3694788,3699464,3695004,3694981],"length":1,"stats":{"Line":0}},{"line":542,"address":[4409980,4409966],"length":1,"stats":{"Line":0}},{"line":545,"address":[2808168],"length":1,"stats":{"Line":0}},{"line":547,"address":[4410079],"length":1,"stats":{"Line":0}},{"line":550,"address":[2808302,2808366],"length":1,"stats":{"Line":0}},{"line":551,"address":[4410376,4410300],"length":1,"stats":{"Line":0}},{"line":552,"address":[2808630,2808558],"length":1,"stats":{"Line":0}},{"line":555,"address":[2809216],"length":1,"stats":{"Line":0}},{"line":556,"address":[3695573,3695652],"length":1,"stats":{"Line":0}},{"line":557,"address":[2808737],"length":1,"stats":{"Line":0}},{"line":558,"address":[4410720,4410657],"length":1,"stats":{"Line":0}},{"line":559,"address":[4410736,4410790],"length":1,"stats":{"Line":0}},{"line":560,"address":[3695865,3695935],"length":1,"stats":{"Line":0}},{"line":561,"address":[3695959],"length":1,"stats":{"Line":0}},{"line":563,"address":[3696015],"length":1,"stats":{"Line":0}},{"line":565,"address":[4268078],"length":1,"stats":{"Line":0}},{"line":566,"address":[3179457],"length":1,"stats":{"Line":0}},{"line":568,"address":[3179747,3179627,3179703,3179532],"length":1,"stats":{"Line":0}},{"line":569,"address":[3179875,3180281],"length":1,"stats":{"Line":0}},{"line":570,"address":[3604037],"length":1,"stats":{"Line":0}},{"line":571,"address":[3604077,3604224],"length":1,"stats":{"Line":0}},{"line":573,"address":[3180526,3180616],"length":1,"stats":{"Line":0}},{"line":575,"address":[3612911,3612635,3604386,3612743],"length":1,"stats":{"Line":0}},{"line":576,"address":[3188657,3191657,3191648,3189088],"length":1,"stats":{"Line":0}},{"line":577,"address":[3189448,3189525,3189218,3189144],"length":1,"stats":{"Line":0}},{"line":578,"address":[3190128,3189675,3189796,3189859],"length":1,"stats":{"Line":0}},{"line":581,"address":[4277960,4279200,4279248,4279410],"length":1,"stats":{"Line":0}},{"line":583,"address":[3190373],"length":1,"stats":{"Line":0}},{"line":588,"address":[4269430,4269525],"length":1,"stats":{"Line":0}},{"line":590,"address":[3180748],"length":1,"stats":{"Line":0}},{"line":592,"address":[3180985,3181169,3181119,3180796,3186719],"length":1,"stats":{"Line":0}},{"line":594,"address":[4270041,4275214],"length":1,"stats":{"Line":0}},{"line":596,"address":[4275388],"length":1,"stats":{"Line":0}},{"line":598,"address":[3186662],"length":1,"stats":{"Line":0}},{"line":600,"address":[3191712,3186724,3191737],"length":1,"stats":{"Line":0}},{"line":601,"address":[4275743,4275680],"length":1,"stats":{"Line":0}},{"line":602,"address":[4275843],"length":1,"stats":{"Line":0}},{"line":603,"address":[3611146,3611967,3611297,3611023,3611351],"length":1,"stats":{"Line":0}},{"line":604,"address":[3187540,3187435],"length":1,"stats":{"Line":0}},{"line":605,"address":[4276579],"length":1,"stats":{"Line":0}},{"line":606,"address":[3611627],"length":1,"stats":{"Line":0}},{"line":607,"address":[4276483],"length":1,"stats":{"Line":0}},{"line":608,"address":[3611675],"length":1,"stats":{"Line":0}},{"line":609,"address":[3187699],"length":1,"stats":{"Line":0}},{"line":610,"address":[4276539],"length":1,"stats":{"Line":0}},{"line":614,"address":[3187098],"length":1,"stats":{"Line":0}},{"line":615,"address":[4276909,4276981,4275946,4277146],"length":1,"stats":{"Line":0}},{"line":618,"address":[4276273],"length":1,"stats":{"Line":0}},{"line":619,"address":[3612521],"length":1,"stats":{"Line":0}},{"line":624,"address":[4270051],"length":1,"stats":{"Line":0}},{"line":625,"address":[3181366,3181290,3191760,3191785],"length":1,"stats":{"Line":0}},{"line":626,"address":[3605314,3605247],"length":1,"stats":{"Line":0}},{"line":627,"address":[4270434],"length":1,"stats":{"Line":0}},{"line":628,"address":[3181682,3182570,3181920,3181970,3181801],"length":1,"stats":{"Line":0}},{"line":629,"address":[3605939,3605834],"length":1,"stats":{"Line":0}},{"line":630,"address":[3182370],"length":1,"stats":{"Line":0}},{"line":631,"address":[3606054],"length":1,"stats":{"Line":0}},{"line":632,"address":[3606094],"length":1,"stats":{"Line":0}},{"line":633,"address":[3606102],"length":1,"stats":{"Line":0}},{"line":634,"address":[4271090],"length":1,"stats":{"Line":0}},{"line":635,"address":[3182330],"length":1,"stats":{"Line":0}},{"line":639,"address":[3605477],"length":1,"stats":{"Line":0}},{"line":640,"address":[3182700,3182772,3182937,3181737],"length":1,"stats":{"Line":0}},{"line":644,"address":[3605868],"length":1,"stats":{"Line":0}},{"line":645,"address":[4271924],"length":1,"stats":{"Line":0}},{"line":649,"address":[4271960,4270133],"length":1,"stats":{"Line":0}},{"line":650,"address":[3607002,3607099],"length":1,"stats":{"Line":0}},{"line":651,"address":[4272063,4272340],"length":1,"stats":{"Line":0}},{"line":652,"address":[3183565,3183660],"length":1,"stats":{"Line":0}},{"line":654,"address":[4272815,4272530],"length":1,"stats":{"Line":0}},{"line":655,"address":[3607991,3607904,3608073],"length":1,"stats":{"Line":0}},{"line":656,"address":[3184444,3184162,3184315],"length":1,"stats":{"Line":0}},{"line":660,"address":[3191817,3183213,3184516,3191808],"length":1,"stats":{"Line":0}},{"line":661,"address":[3608530,3608788,3608451,3608876],"length":1,"stats":{"Line":0}},{"line":662,"address":[3185136,3185332,3185607,3185263],"length":1,"stats":{"Line":0}},{"line":665,"address":[3184594,3185876,3186098,3185930],"length":1,"stats":{"Line":0}},{"line":668,"address":[4269179],"length":1,"stats":{"Line":0}},{"line":669,"address":[3615348,3615009,3615079,3604116],"length":1,"stats":{"Line":0}},{"line":672,"address":[4275150],"length":1,"stats":{"Line":0}},{"line":675,"address":[3603585],"length":1,"stats":{"Line":0}},{"line":680,"address":[2809239],"length":1,"stats":{"Line":0}},{"line":681,"address":[3696342,3696262],"length":1,"stats":{"Line":0}},{"line":682,"address":[4280703],"length":1,"stats":{"Line":0}},{"line":683,"address":[4280805,4280906],"length":1,"stats":{"Line":0}},{"line":685,"address":[3192186],"length":1,"stats":{"Line":0}},{"line":687,"address":[4281136,4281269,4281348,4281507],"length":1,"stats":{"Line":0}},{"line":688,"address":[3616964,3616567],"length":1,"stats":{"Line":0}},{"line":690,"address":[4281178],"length":1,"stats":{"Line":0}},{"line":691,"address":[3193158,3192996,3192420,3192905],"length":1,"stats":{"Line":0}},{"line":692,"address":[3193346,3192919],"length":1,"stats":{"Line":0}},{"line":695,"address":[3616327],"length":1,"stats":{"Line":0}},{"line":696,"address":[3617759,3618031,3617668,3616375],"length":1,"stats":{"Line":0}},{"line":697,"address":[3194127,3193586],"length":1,"stats":{"Line":0}},{"line":704,"address":[3696401],"length":1,"stats":{"Line":0}},{"line":707,"address":[3696436],"length":1,"stats":{"Line":0}},{"line":708,"address":[4411968,4412216,4411458,4411552,4411792],"length":1,"stats":{"Line":0}},{"line":710,"address":[3697338],"length":1,"stats":{"Line":0}},{"line":711,"address":[4412473,4412602],"length":1,"stats":{"Line":0}},{"line":714,"address":[2810527,2810963],"length":1,"stats":{"Line":0}},{"line":719,"address":[2811429,2811156,2811237,2811070],"length":1,"stats":{"Line":0}},{"line":720,"address":[2811610,2811162],"length":1,"stats":{"Line":0}},{"line":722,"address":[2811862,2811632],"length":1,"stats":{"Line":0}},{"line":725,"address":[3698882],"length":1,"stats":{"Line":0}},{"line":727,"address":[3698985],"length":1,"stats":{"Line":0}},{"line":731,"address":[4418593,4414288,4419881],"length":1,"stats":{"Line":0}},{"line":732,"address":[2812474],"length":1,"stats":{"Line":0}},{"line":733,"address":[2812530,2818105],"length":1,"stats":{"Line":0}},{"line":734,"address":[3705254,3705483],"length":1,"stats":{"Line":0}},{"line":735,"address":[4420245],"length":1,"stats":{"Line":0}},{"line":738,"address":[2812812,2812645,2812491],"length":1,"stats":{"Line":0}},{"line":739,"address":[2812576],"length":1,"stats":{"Line":0}},{"line":742,"address":[2812597],"length":1,"stats":{"Line":0}},{"line":743,"address":[4414855],"length":1,"stats":{"Line":0}},{"line":746,"address":[3700218],"length":1,"stats":{"Line":0}},{"line":747,"address":[4415005],"length":1,"stats":{"Line":0}},{"line":750,"address":[2813162,2813242],"length":1,"stats":{"Line":0}},{"line":751,"address":[3700692],"length":1,"stats":{"Line":0}},{"line":752,"address":[4415133,4415193,4415405,4415382,4419850],"length":1,"stats":{"Line":0}},{"line":753,"address":[2813503,2813517],"length":1,"stats":{"Line":0}},{"line":758,"address":[2813868,2813585],"length":1,"stats":{"Line":0}},{"line":760,"address":[4415780],"length":1,"stats":{"Line":0}},{"line":762,"address":[3701094,3702393],"length":1,"stats":{"Line":0}},{"line":763,"address":[4417131,4418635,4418798,4419062,4419405],"length":1,"stats":{"Line":0}},{"line":765,"address":[2817895,2817766],"length":1,"stats":{"Line":0}},{"line":770,"address":[4417109,4417192],"length":1,"stats":{"Line":0}},{"line":771,"address":[2815498,2815390,2815661,2815925,2816125],"length":1,"stats":{"Line":0}},{"line":773,"address":[4418328,4418473],"length":1,"stats":{"Line":0}},{"line":777,"address":[2816730],"length":1,"stats":{"Line":0}},{"line":780,"address":[2813841],"length":1,"stats":{"Line":0}},{"line":781,"address":[4415818],"length":1,"stats":{"Line":0}},{"line":782,"address":[4416406,4416670,4415882,4416208],"length":1,"stats":{"Line":0}},{"line":784,"address":[2814080,2815014],"length":1,"stats":{"Line":0}},{"line":785,"address":[4417044],"length":1,"stats":{"Line":0}},{"line":789,"address":[2818400],"length":1,"stats":{"Line":2}},{"line":791,"address":[2818442],"length":1,"stats":{"Line":6}},{"line":795,"address":[3705696],"length":1,"stats":{"Line":0}},{"line":796,"address":[3705704],"length":1,"stats":{"Line":0}},{"line":800,"address":[4420384],"length":1,"stats":{"Line":0}},{"line":805,"address":[2818528],"length":1,"stats":{"Line":2}},{"line":806,"address":[4420414],"length":1,"stats":{"Line":2}},{"line":810,"address":[4420432],"length":1,"stats":{"Line":2}},{"line":811,"address":[2818568],"length":1,"stats":{"Line":2}},{"line":826,"address":[2818867,2818576],"length":1,"stats":{"Line":0}},{"line":828,"address":[3705806],"length":1,"stats":{"Line":0}},{"line":829,"address":[2818615],"length":1,"stats":{"Line":0}},{"line":830,"address":[2818624],"length":1,"stats":{"Line":0}},{"line":831,"address":[3705833],"length":1,"stats":{"Line":0}},{"line":832,"address":[3705852],"length":1,"stats":{"Line":0}},{"line":833,"address":[3705861],"length":1,"stats":{"Line":0}},{"line":834,"address":[3705927],"length":1,"stats":{"Line":0}}],"covered":106,"coverable":397},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","embedding.rs"],"content":"use crate::vectordb::error::VectorDBError;\nuse crate::vectordb::provider::{EmbeddingProvider, OnnxEmbeddingProvider};\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::path::{Path, PathBuf};\n\n// Use the embedding dimensions from the providers\n// use crate::vectordb::provider::fast::FAST_EMBEDDING_DIM;\n\n/// Supported embedding models.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum EmbeddingModelType {\n    /// Use the ONNX model for embeddings.\n    Onnx,\n    // No specific CodeBert type needed if we handle dimensions dynamically\n}\n\nimpl EmbeddingModelType {\n    /// Returns the default embedding dimension for this model type.\n    /// Used as a fallback when loading an index without an explicit dimension stored.\n    pub fn default_dimension(\u0026self) -\u003e usize {\n        match self {\n            // TODO: Make this dynamically configurable or read from a default ONNX model?\n            // For now, assume the default ONNX is MiniLM with 384 dims.\n            EmbeddingModelType::Onnx =\u003e 384,\n        }\n    }\n}\n\nimpl std::fmt::Display for EmbeddingModelType {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            EmbeddingModelType::Onnx =\u003e write!(f, \"ONNX\"),\n        }\n    }\n}\n\nimpl Default for EmbeddingModelType {\n    fn default() -\u003e Self {\n        EmbeddingModelType::Onnx\n    }\n}\n\n/// Model for generating embeddings from text\npub struct EmbeddingModel {\n    provider: Box\u003cdyn EmbeddingProvider + Send + Sync\u003e,\n    model_type: EmbeddingModelType,\n    onnx_model_path: Option\u003cPathBuf\u003e,\n    onnx_tokenizer_path: Option\u003cPathBuf\u003e,\n}\n\nimpl Clone for EmbeddingModel {\n    fn clone(\u0026self) -\u003e Self {\n        // Re-create the provider using stored paths.\n        match self.model_type {\n            EmbeddingModelType::Onnx =\u003e {\n                let model_path = self.onnx_model_path.as_ref()\n                    .expect(\"Missing ONNX model path for cloning\");\n                let tokenizer_path = self.onnx_tokenizer_path.as_ref()\n                    .expect(\"Missing ONNX tokenizer path for cloning\");\n                \n                // Use expect here as cloning implies the original creation succeeded\n                Self::new_onnx(model_path, tokenizer_path)\n                    .expect(\"Failed to re-create ONNX model during clone\")\n            }\n            // Add other types here if needed in the future\n        }\n    }\n}\n\nimpl EmbeddingModel {\n    /// Creates a new EmbeddingModel with the Fast provider\n    /// This provider is much faster but less accurate than ONNX\n    // pub fn new() -\u003e Self {\n    //     let provider = Box::new(FastTextProvider::new());\n    //     Self {\n    //         provider,\n    //         model_type: EmbeddingModelType::Fast,\n    //     }\n    // }\n\n    /// Creates a new EmbeddingModel with the ONNX provider\n    /// This provider is more accurate but slower than Fast\n    pub fn new_onnx(model_path: \u0026Path, tokenizer_path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        let provider = Box::new(OnnxEmbeddingProvider::new(model_path, tokenizer_path)?);\n        Ok(Self {\n            provider,\n            model_type: EmbeddingModelType::Onnx,\n            onnx_model_path: Some(model_path.to_path_buf()),\n            onnx_tokenizer_path: Some(tokenizer_path.to_path_buf()),\n        })\n    }\n\n    /// Convert text to an embedding vector\n    pub fn embed(\u0026self, text: \u0026str) -\u003e Result\u003cVec\u003cf32\u003e, VectorDBError\u003e {\n        self.provider\n            .embed(text)\n            .map_err(|e| VectorDBError::EmbeddingError(e.to_string()))\n    }\n\n    /// Convert multiple texts to embedding vectors\n    pub fn embed_batch(\u0026self, texts: \u0026[\u0026str]) -\u003e Result\u003cVec\u003cVec\u003cf32\u003e\u003e, VectorDBError\u003e {\n        self.provider\n            .embed_batch(texts)\n            .map_err(|e| VectorDBError::EmbeddingError(e.to_string()))\n    }\n\n    /// Get the dimension of the embeddings produced by this model\n    pub fn dim(\u0026self) -\u003e usize {\n        self.provider.dimension()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Removed test_fast_embedding\n    // #[test]\n    // fn test_fast_embedding() { ... }\n\n    // Removed test_embedding_batch (it used the default FastText model)\n    // #[test]\n    // fn test_embedding_batch() { ... }\n\n    // Keep test_onnx_embedding_fallback\n    #[test]\n    fn test_onnx_embedding_fallback() {\n        let model_path = Path::new(\"onnx/all-minilm-l12-v2.onnx\");\n        let tokenizer_path = Path::new(\"onnx/minilm_tokenizer.json\");\n\n        // Skip test if ONNX files don't exist\n        if !model_path.exists() || !tokenizer_path.exists() {\n            println!(\"Skipping ONNX test because model files aren't available\");\n            return;\n        }\n\n        // Create ONNX model\n        let onnx_model = EmbeddingModel::new_onnx(model_path, tokenizer_path);\n        assert!(onnx_model.is_ok());\n\n        let model = onnx_model.unwrap();\n        let expected_dim = model.dim(); // Get dimension from model\n\n        // Test embedding\n        let text = \"fn main() { let x = 42; }\";\n        let embedding = model.embed(text).unwrap();\n\n        assert_eq!(embedding.len(), expected_dim); // Check against model's dimension\n        assert!(!embedding.iter().all(|\u0026x| x == 0.0));\n\n        // Test cloning\n        let cloned_model = model.clone();\n        assert_eq!(cloned_model.dim(), expected_dim);\n        let cloned_embedding = cloned_model.embed(text).unwrap();\n        assert_eq!(embedding, cloned_embedding);\n    }\n\n    // Removed test_model_cloning (it used the default FastText model)\n    // #[test]\n    // fn test_model_cloning() { ... }\n}\n","traces":[{"line":21,"address":[3718096],"length":1,"stats":{"Line":0}},{"line":31,"address":[3167824],"length":1,"stats":{"Line":0}},{"line":33,"address":[3167842],"length":1,"stats":{"Line":0}},{"line":53,"address":[3120864],"length":1,"stats":{"Line":0}},{"line":57,"address":[3167942],"length":1,"stats":{"Line":0}},{"line":59,"address":[3167994],"length":1,"stats":{"Line":0}},{"line":63,"address":[3168050],"length":1,"stats":{"Line":0}},{"line":84,"address":[3168160,3169017,3169036],"length":1,"stats":{"Line":0}},{"line":85,"address":[3168229,3168612,3168539],"length":1,"stats":{"Line":0}},{"line":86,"address":[3168850],"length":1,"stats":{"Line":0}},{"line":87,"address":[3168552],"length":1,"stats":{"Line":0}},{"line":89,"address":[3121654,3121542],"length":1,"stats":{"Line":0}},{"line":90,"address":[3168737,3168802],"length":1,"stats":{"Line":0}},{"line":95,"address":[3169088],"length":1,"stats":{"Line":0}},{"line":96,"address":[3122064],"length":1,"stats":{"Line":0}},{"line":98,"address":[3733072,3733090],"length":1,"stats":{"Line":0}},{"line":102,"address":[3169168],"length":1,"stats":{"Line":0}},{"line":103,"address":[3169200],"length":1,"stats":{"Line":0}},{"line":105,"address":[3733232,3733250],"length":1,"stats":{"Line":0}},{"line":109,"address":[3169248],"length":1,"stats":{"Line":0}},{"line":110,"address":[3169256],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","error.rs"],"content":"use std::io;\nuse std::path::PathBuf;\nuse thiserror::Error;\n// use syn;\nuse anyhow;\n\n/// Result type for VectorDB operations\npub type Result\u003cT\u003e = std::result::Result\u003cT, VectorDBError\u003e;\n\n/// Errors that can occur in the VectorDB system\n#[derive(Error, Debug)]\npub enum VectorDBError {\n    #[error(\"File not found: {0}\")]\n    FileNotFound(String),\n\n    #[error(\"Failed to read file {path}: {source}\")]\n    FileReadError { path: PathBuf, source: io::Error },\n\n    #[error(\"Failed to write file {path}: {source}\")]\n    FileWriteError { path: PathBuf, source: io::Error },\n\n    #[error(\"Failed to create directory {path}: {source}\")]\n    DirectoryCreationError { path: PathBuf, source: io::Error },\n\n    #[error(\"Failed to access file metadata for {path}: {source}\")]\n    MetadataError { path: PathBuf, source: io::Error },\n\n    #[error(\"Error serializing or deserializing data: {0}\")]\n    SerializationError(#[from] serde_json::Error),\n\n    #[error(\"Error generating embedding: {0}\")]\n    EmbeddingError(String),\n\n    #[error(\"Database error: {0}\")]\n    DatabaseError(String),\n\n    #[error(\"AST traversal error: {0}\")]\n    ASTTraversalError(String),\n\n    #[error(\"Invalid parameter: {0}\")]\n    InvalidParameter(String),\n\n    #[error(\"Invalid path: {0}\")]\n    InvalidPath(String),\n\n    #[error(\"Cache error: {0}\")]\n    CacheError(String),\n\n    #[error(\"Parser error: {0}\")]\n    ParserError(String),\n\n    #[error(\"Unsupported language: {0}\")]\n    UnsupportedLanguage(String),\n\n    #[error(\"HNSW index error: {0}\")]\n    HNSWError(String),\n\n    #[error(\"IO error: {0}\")]\n    IOError(#[from] io::Error),\n\n    #[error(\"Code analysis error: {0}\")]\n    CodeAnalysisError(String),\n\n    #[error(\"General error: {0}\")]\n    GeneralError(String),\n\n    #[error(\"Directory not found: {0}\")]\n    DirectoryNotFound(String),\n\n    #[error(\"Repository error: {0}\")]\n    RepositoryError(String),\n\n    #[error(\"Repository not found: {0}\")]\n    RepositoryNotFound(String),\n\n    #[error(\"Error deserializing data: {0}\")]\n    DeserializationError(String),\n\n    #[error(\"Search error: {0}\")]\n    SearchError(String),\n\n    #[error(\"Other error: {0}\")]\n    Other(String),\n\n    #[error(\"Configuration error: {0}\")]\n    ConfigurationError(String),\n\n    #[error(\"Dimension mismatch: Expected {expected}, found {found}\")]\n    DimensionMismatch { expected: usize, found: usize },\n\n    #[error(\"Indexing error: {0}\")]\n    IndexingError(String),\n}\n\n/// Conversion from anyhow::Error\nimpl From\u003canyhow::Error\u003e for VectorDBError {\n    fn from(error: anyhow::Error) -\u003e Self {\n        VectorDBError::HNSWError(error.to_string())\n    }\n}\n\n// Add Clone implementation for VectorDBError to support parallel processing\nimpl Clone for VectorDBError {\n    fn clone(\u0026self) -\u003e Self {\n        match self {\n            Self::FileNotFound(s) =\u003e Self::FileNotFound(s.clone()),\n            Self::FileReadError { path, source } =\u003e Self::FileReadError {\n                path: path.clone(),\n                source: io::Error::new(source.kind(), source.to_string()),\n            },\n            Self::FileWriteError { path, source } =\u003e Self::FileWriteError {\n                path: path.clone(),\n                source: io::Error::new(source.kind(), source.to_string()),\n            },\n            Self::DirectoryCreationError { path, source } =\u003e Self::DirectoryCreationError {\n                path: path.clone(),\n                source: io::Error::new(source.kind(), source.to_string()),\n            },\n            Self::MetadataError { path, source } =\u003e Self::MetadataError {\n                path: path.clone(),\n                source: io::Error::new(source.kind(), source.to_string()),\n            },\n            // Create new serialization error with the string representation\n            Self::SerializationError(e) =\u003e Self::SerializationError(\n                serde_json::from_str::\u003cserde_json::Value\u003e(\u0026format!(\"\\\"{}\\\"\", e)).unwrap_err(),\n            ),\n            Self::EmbeddingError(s) =\u003e Self::EmbeddingError(s.clone()),\n            Self::DatabaseError(s) =\u003e Self::DatabaseError(s.clone()),\n            Self::ASTTraversalError(s) =\u003e Self::ASTTraversalError(s.clone()),\n            Self::InvalidParameter(s) =\u003e Self::InvalidParameter(s.clone()),\n            Self::InvalidPath(s) =\u003e Self::InvalidPath(s.clone()),\n            Self::CacheError(s) =\u003e Self::CacheError(s.clone()),\n            Self::ParserError(s) =\u003e Self::ParserError(s.clone()),\n            Self::UnsupportedLanguage(s) =\u003e Self::UnsupportedLanguage(s.clone()),\n            Self::HNSWError(s) =\u003e Self::HNSWError(s.clone()),\n            Self::IOError(e) =\u003e Self::IOError(io::Error::new(e.kind(), e.to_string())),\n            Self::CodeAnalysisError(s) =\u003e Self::CodeAnalysisError(s.clone()),\n            Self::GeneralError(s) =\u003e Self::GeneralError(s.clone()),\n            Self::DirectoryNotFound(s) =\u003e Self::DirectoryNotFound(s.clone()),\n            Self::RepositoryError(s) =\u003e Self::RepositoryError(s.clone()),\n            Self::RepositoryNotFound(s) =\u003e Self::RepositoryNotFound(s.clone()),\n            Self::DeserializationError(s) =\u003e Self::DeserializationError(s.clone()),\n            Self::SearchError(s) =\u003e Self::SearchError(s.clone()),\n            Self::Other(s) =\u003e Self::Other(s.clone()),\n            Self::ConfigurationError(s) =\u003e Self::ConfigurationError(s.clone()),\n            Self::DimensionMismatch { expected, found } =\u003e Self::DimensionMismatch {\n                expected: *expected,\n                found: *found,\n            },\n            Self::IndexingError(s) =\u003e Self::IndexingError(s.clone()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io;\n\n    #[test]\n    fn test_error_conversion() {\n        let io_error = io::Error::new(io::ErrorKind::NotFound, \"test file not found\");\n        let db_error = VectorDBError::from(io_error);\n\n        match db_error {\n            VectorDBError::IOError(_) =\u003e assert!(true),\n            _ =\u003e assert!(false, \"Expected IOError conversion\"),\n        }\n\n        // Test manual creation for specific error kinds\n        let db_error = VectorDBError::FileNotFound(\"test file not found\".to_string());\n\n        match db_error {\n            VectorDBError::FileNotFound(_) =\u003e assert!(true),\n            _ =\u003e assert!(false, \"Expected FileNotFound type\"),\n        }\n    }\n\n    #[test]\n    fn test_error_display() {\n        let error = VectorDBError::FileNotFound(\"test.txt\".to_string());\n        assert!(error.to_string().contains(\"test.txt\"));\n    }\n\n    #[test]\n    fn test_parser_error() {\n        let error = VectorDBError::ParserError(\"Failed to parse file\".to_string());\n        let err_string = error.to_string();\n        assert!(err_string.contains(\"Failed to parse file\"));\n    }\n\n    #[test]\n    fn test_dimension_mismatch_error() {\n        let error = VectorDBError::DimensionMismatch { expected: 10, found: 5 };\n        let err_string = error.to_string();\n        assert!(err_string.contains(\"Dimension mismatch: Expected 10, found 5\"));\n\n        let cloned_error = error.clone();\n        match cloned_error {\n            VectorDBError::DimensionMismatch { expected, found } =\u003e {\n                assert_eq!(expected, 10);\n                assert_eq!(found, 5);\n            }\n            _ =\u003e panic!(\"Expected DimensionMismatch error after cloning\"),\n        }\n    }\n}\n","traces":[{"line":97,"address":[3457808,3457680],"length":1,"stats":{"Line":0}},{"line":98,"address":[3457709,3457753],"length":1,"stats":{"Line":0}},{"line":104,"address":[3861516,3858768],"length":1,"stats":{"Line":2}},{"line":105,"address":[3858807],"length":1,"stats":{"Line":2}},{"line":106,"address":[3858852],"length":1,"stats":{"Line":0}},{"line":108,"address":[3858985],"length":1,"stats":{"Line":0}},{"line":109,"address":[3861398,3858998],"length":1,"stats":{"Line":0}},{"line":112,"address":[3458135],"length":1,"stats":{"Line":0}},{"line":113,"address":[3863184,3860673],"length":1,"stats":{"Line":0}},{"line":116,"address":[3458207],"length":1,"stats":{"Line":0}},{"line":117,"address":[3458217,3460820],"length":1,"stats":{"Line":0}},{"line":120,"address":[3860807],"length":1,"stats":{"Line":0}},{"line":121,"address":[3460984,3458289],"length":1,"stats":{"Line":0}},{"line":125,"address":[3862081,3859433,3859322],"length":1,"stats":{"Line":0}},{"line":127,"address":[3859461],"length":1,"stats":{"Line":0}},{"line":128,"address":[3859551],"length":1,"stats":{"Line":0}},{"line":129,"address":[3859641],"length":1,"stats":{"Line":0}},{"line":130,"address":[3861331],"length":1,"stats":{"Line":0}},{"line":131,"address":[3861421],"length":1,"stats":{"Line":0}},{"line":132,"address":[3859911],"length":1,"stats":{"Line":0}},{"line":133,"address":[3861601],"length":1,"stats":{"Line":0}},{"line":134,"address":[3459163],"length":1,"stats":{"Line":0}},{"line":135,"address":[3459253],"length":1,"stats":{"Line":0}},{"line":136,"address":[3459343],"length":1,"stats":{"Line":0}},{"line":137,"address":[3860372],"length":1,"stats":{"Line":0}},{"line":138,"address":[3459534],"length":1,"stats":{"Line":0}},{"line":139,"address":[3860552],"length":1,"stats":{"Line":0}},{"line":140,"address":[3860642],"length":1,"stats":{"Line":0}},{"line":141,"address":[3860732],"length":1,"stats":{"Line":0}},{"line":142,"address":[3459894],"length":1,"stats":{"Line":0}},{"line":143,"address":[3860912],"length":1,"stats":{"Line":0}},{"line":144,"address":[3861002],"length":1,"stats":{"Line":0}},{"line":145,"address":[3861092],"length":1,"stats":{"Line":0}},{"line":147,"address":[3861220],"length":1,"stats":{"Line":2}},{"line":148,"address":[3861224],"length":1,"stats":{"Line":2}},{"line":150,"address":[3861253],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":36},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","hnsw.rs"],"content":"use anyhow::Result;\nuse rand::rngs::StdRng;\nuse rand::{Rng, SeedableRng};\nuse rayon::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse std::collections::{HashMap, HashSet};\nuse std::fs;\nuse std::path::Path;\n\n/// Configuration parameters for HNSW index\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HNSWConfig {\n    #[serde(default = \"default_dimension\")]\n    pub dimension: usize,\n    #[serde(default = \"default_m\")]\n    pub m: usize,\n    #[serde(default = \"default_ef_construction\")]\n    pub ef_construction: usize,\n    #[serde(default = \"default_num_layers\")]\n    pub num_layers: usize,\n    #[serde(default = \"default_random_seed\")]\n    pub random_seed: u64,\n}\n\n// Helper functions for serde defaults, returning values from HNSWConfig::default()\nfn default_dimension() -\u003e usize { HNSWConfig::default().dimension }\nfn default_m() -\u003e usize { HNSWConfig::default().m }\nfn default_ef_construction() -\u003e usize { HNSWConfig::default().ef_construction }\nfn default_num_layers() -\u003e usize { HNSWConfig::default().num_layers }\nfn default_random_seed() -\u003e u64 { HNSWConfig::default().random_seed }\n\nimpl Default for HNSWConfig {\n    fn default() -\u003e Self {\n        Self {\n            dimension: 128,\n            m: 16,\n            ef_construction: 200,\n            num_layers: 1, // Start with 1, might need adjustment based on data size\n            random_seed: 42,\n        }\n    }\n}\n\nimpl HNSWConfig {\n    /// Creates a new HNSWConfig with the specified dimension and default values for other parameters.\n    pub fn new(dimension: usize) -\u003e Self {\n        assert!(dimension \u003e 0, \"Dimension must be positive\");\n        Self {\n            dimension,\n            ..Self::default() // Use default values for other fields\n        }\n    }\n\n    // Removed unused function calculate_optimal_layers\n    // pub fn calculate_optimal_layers(dataset_size: usize) -\u003e usize { ... }\n}\n\n/// Represents a node in the HNSW graph\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HNSWNode {\n    /// The vector embedding\n    pub vector: Vec\u003cf32\u003e,\n    /// Layer connections for each layer\n    pub connections: Vec\u003cVec\u003cusize\u003e\u003e,\n    /// Maximum layer this node appears in\n    pub max_layer: usize,\n}\n\nimpl HNSWNode {\n    pub fn new(vector: Vec\u003cf32\u003e, max_layer: usize) -\u003e Self {\n        Self {\n            vector,\n            connections: vec![Vec::new(); max_layer + 1],\n            max_layer,\n        }\n    }\n}\n\n/// The main HNSW index structure\n#[derive(Clone)]\npub struct HNSWIndex {\n    /// Configuration parameters\n    config: HNSWConfig,\n    /// The actual graph structure\n    nodes: Vec\u003cHNSWNode\u003e,\n    /// Entry point node indices for each layer\n    entry_points: Vec\u003cusize\u003e,\n}\n\n/// Serializable representation of the HNSW index\n#[derive(Serialize, Deserialize)]\nstruct SerializedHNSWIndex {\n    config: HNSWConfig,\n    nodes: Vec\u003cHNSWNode\u003e,\n    entry_points: Vec\u003cusize\u003e,\n}\n\nimpl HNSWIndex {\n    pub fn new(config: HNSWConfig) -\u003e Self {\n        assert!(config.dimension \u003e 0, \"HNSW dimension must be positive\");\n        let num_layers = config.num_layers;\n        Self {\n            config,\n            nodes: Vec::new(),\n            entry_points: vec![0; num_layers],\n        }\n    }\n\n    /// Calculate cosine distance between two vectors (range 0.0 to 2.0)\n    fn cosine_distance(a: \u0026[f32], b: \u0026[f32]) -\u003e f32 {\n        let dot_product: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();\n        let norm_a: f32 = a.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n        let norm_b: f32 = b.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n\n        // Handle zero vectors to avoid division by zero and return max distance\n        if norm_a == 0.0 || norm_b == 0.0 {\n            return 2.0; // Max distance for cosine\n        }\n\n        // Calculate cosine similarity\n        let similarity = dot_product / (norm_a * norm_b);\n\n        // Clamp similarity to [-1.0, 1.0] to handle potential floating point inaccuracies\n        let clamped_similarity = similarity.clamp(-1.0, 1.0);\n\n        // Convert similarity to distance: distance = 1.0 - similarity\n        // This results in a distance range of [0.0, 2.0]\n        // Identical vectors (similarity 1.0) -\u003e distance 0.0\n        // Opposite vectors (similarity -1.0) -\u003e distance 2.0\n        1.0 - clamped_similarity\n    }\n\n    /// Generate a random layer for a new node\n    fn random_layer(\u0026self) -\u003e usize {\n        let mut rng = StdRng::seed_from_u64(self.config.random_seed);\n        let mut layer = 0;\n        while layer \u003c self.config.num_layers - 1 \u0026\u0026 rng.gen::\u003cf32\u003e() \u003c 0.5 {\n            layer += 1;\n        }\n        layer\n    }\n\n    /// Find the nearest neighbors in a given layer\n    fn search_layer(\n        \u0026self,\n        query: \u0026[f32],\n        entry_point: usize,\n        ef: usize,\n        layer: usize,\n    ) -\u003e Vec\u003c(usize, f32)\u003e {\n        let mut candidates = HashSet::new();\n        let mut results = Vec::new();\n        let mut distances = HashMap::new();\n\n        // Initialize with entry point\n        let entry_dist = Self::cosine_distance(query, \u0026self.nodes[entry_point].vector);\n        candidates.insert(entry_point);\n        distances.insert(entry_point, entry_dist);\n        results.push((entry_point, entry_dist));\n\n        while !candidates.is_empty() {\n            // Find the closest candidate\n            let current = match candidates.iter().min_by(|\u0026\u0026a, \u0026\u0026b| {\n                distances[\u0026a]\n                    .partial_cmp(\u0026distances[\u0026b])\n                    .unwrap_or(std::cmp::Ordering::Equal)\n            }) {\n                Some(\u0026c) =\u003e c,\n                None =\u003e break,\n            };\n            candidates.remove(\u0026current);\n\n            // Add to results if it's better than our current worst result\n            let worst_dist = results.last().map_or(f32::INFINITY, |\u0026(_, dist)| dist);\n            if results.len() \u003c ef || distances[\u0026current] \u003c worst_dist {\n                results.push((current, distances[\u0026current]));\n                results.sort_by(|a, b| a.1.partial_cmp(\u0026b.1).unwrap_or(std::cmp::Ordering::Equal));\n                if results.len() \u003e ef {\n                    results.pop();\n                }\n            }\n\n            // Explore neighbors\n            for \u0026neighbor in \u0026self.nodes[current].connections[layer] {\n                if !distances.contains_key(\u0026neighbor) {\n                    let dist = Self::cosine_distance(query, \u0026self.nodes[neighbor].vector);\n                    distances.insert(neighbor, dist);\n\n                    let worst_dist = results.last().map_or(f32::INFINITY, |\u0026(_, d)| d);\n                    if results.len() \u003c ef || dist \u003c worst_dist {\n                        candidates.insert(neighbor);\n                    }\n                }\n            }\n        }\n\n        results\n    }\n\n    /// Insert a new vector into the index\n    pub fn insert(\u0026mut self, vector: Vec\u003cf32\u003e) -\u003e Result\u003cusize\u003e {\n        if vector.len() != self.config.dimension {\n            return Err(anyhow::anyhow!(\n                \"Invalid vector dimension: expected {}, got {}\",\n                self.config.dimension,\n                vector.len()\n            ));\n        }\n\n        let max_layer = self.random_layer();\n        let node = HNSWNode::new(vector, max_layer);\n        let node_idx = self.nodes.len();\n\n        // If this is the first node, set it as entry point for all layers\n        if node_idx == 0 {\n            self.nodes.push(node);\n            return Ok(node_idx);\n        }\n\n        self.nodes.push(node);\n\n        // Start from top layer and work down\n        let mut current_entry = self.entry_points[max_layer];\n        for layer in (0..=max_layer).rev() {\n            let neighbors = self.search_layer(\n                \u0026self.nodes[node_idx].vector,\n                current_entry,\n                self.config.ef_construction,\n                layer,\n            );\n\n            // Select neighbors to connect to\n            let selected = neighbors\n                .into_iter()\n                .take(self.config.m)\n                .map(|(idx, _)| idx)\n                .collect::\u003cVec\u003c_\u003e\u003e();\n\n            // Add bidirectional connections\n            for \u0026neighbor in \u0026selected {\n                self.nodes[node_idx].connections[layer].push(neighbor);\n                self.nodes[neighbor].connections[layer].push(node_idx);\n            }\n\n            // Update entry point for this layer if the new node is closer to query\n            if !selected.is_empty() {\n                let current_dist = Self::cosine_distance(\n                    \u0026self.nodes[current_entry].vector,\n                    \u0026self.nodes[node_idx].vector,\n                );\n                let best_dist = Self::cosine_distance(\n                    \u0026self.nodes[selected[0]].vector,\n                    \u0026self.nodes[node_idx].vector,\n                );\n                if best_dist \u003c current_dist {\n                    self.entry_points[layer] = selected[0];\n                    current_entry = selected[0];\n                }\n            }\n        }\n\n        Ok(node_idx)\n    }\n\n    /// Search for the k nearest neighbors of a query vector in parallel\n    pub fn search_parallel(\u0026self, query: \u0026[f32], k: usize, ef: usize) -\u003e Result\u003cVec\u003c(usize, f32)\u003e\u003e {\n        if query.len() != self.config.dimension {\n            return Err(anyhow::anyhow!(\n                \"Invalid query vector dimension: expected {}, got {}\",\n                self.config.dimension,\n                query.len()\n            ));\n        }\n\n        if self.nodes.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        // Find the highest layer where we have nodes\n        let mut max_layer = 0;\n        for node in \u0026self.nodes {\n            max_layer = max_layer.max(node.max_layer);\n        }\n\n        // We'll use thread-local storage for the current entry and distance\n        let mut current_entry = self.entry_points[max_layer.min(self.entry_points.len() - 1)];\n        let mut current_dist = Self::cosine_distance(query, \u0026self.nodes[current_entry].vector);\n\n        // Traverse the upper layers sequentially (they're small anyway)\n        for layer in (1..=max_layer).rev() {\n            let neighbors = self.search_layer(query, current_entry, ef, layer);\n            if let Some((idx, dist)) = neighbors.first() {\n                if *dist \u003c current_dist {\n                    current_entry = *idx;\n                    current_dist = *dist;\n                }\n            }\n        }\n\n        // Search the bottom layer (level 0) in parallel for better performance\n        // First, get all the neighbors of the entry point to use as starting points\n        let initial_candidates =\n            self.search_layer(query, current_entry, ef.max(self.config.m * 2), 0);\n\n        // If we have very few candidates, just return them\n        if initial_candidates.len() \u003c= k {\n            return Ok(initial_candidates);\n        }\n\n        // Take only the top candidates as starting points\n        let starting_points: Vec\u003cusize\u003e = initial_candidates\n            .iter()\n            .take(self.config.m.min(4))\n            .map(|(idx, _)| *idx)\n            .collect();\n\n        // Search from each starting point in parallel\n        let results: Vec\u003cVec\u003c(usize, f32)\u003e\u003e = starting_points\n            .par_iter()\n            .map(|\u0026start_idx| self.search_layer(query, start_idx, ef / starting_points.len(), 0))\n            .collect();\n\n        // Merge results\n        let mut merged = Vec::new();\n        for result_set in results {\n            for result in result_set {\n                merged.push(result);\n            }\n        }\n\n        // De-duplicate by node index\n        let mut seen = HashSet::new();\n        let mut unique_results = Vec::new();\n\n        for (idx, dist) in merged {\n            if seen.insert(idx) {\n                unique_results.push((idx, dist));\n            }\n        }\n\n        // Sort by distance\n        unique_results.sort_by(|a, b| a.1.partial_cmp(\u0026b.1).unwrap_or(std::cmp::Ordering::Equal));\n\n        // Take top k\n        Ok(unique_results.into_iter().take(k).collect())\n    }\n\n    /// Get statistics about the index\n    pub fn stats(\u0026self) -\u003e HNSWStats {\n        let mut layer_stats = Vec::new();\n        for layer in 0..self.config.num_layers {\n            let mut connections = 0;\n            let mut nodes_in_layer = 0;\n            for node in \u0026self.nodes {\n                if layer \u003c= node.max_layer {\n                    nodes_in_layer += 1;\n                    connections += node.connections[layer].len();\n                }\n            }\n            layer_stats.push(LayerStats {\n                nodes: nodes_in_layer,\n                avg_connections: if nodes_in_layer \u003e 0 {\n                    connections as f32 / nodes_in_layer as f32\n                } else {\n                    0.0\n                },\n            });\n        }\n\n        HNSWStats {\n            total_nodes: self.nodes.len(),\n            layers: self.config.num_layers,\n            layer_stats,\n        }\n    }\n\n    /// Get the configuration of this index\n    pub fn get_config(\u0026self) -\u003e HNSWConfig {\n        self.config.clone()\n    }\n\n    /// Save the index to a file\n    pub fn save_to_file(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        let serialized = SerializedHNSWIndex {\n            config: self.config.clone(),\n            nodes: self.nodes.clone(),\n            entry_points: self.entry_points.clone(),\n        };\n\n        // First serialize to a string\n        let data = serde_json::to_string_pretty(\u0026serialized)?;\n\n        // Create parent directories if they don't exist\n        if let Some(parent) = path.parent() {\n            fs::create_dir_all(parent)?;\n        }\n\n        // Write to the file\n        fs::write(path, data)?;\n\n        Ok(())\n    }\n\n    /// Load an index from a file\n    pub fn load_from_file(path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        let data = fs::read_to_string(path)?;\n        let serialized: SerializedHNSWIndex = serde_json::from_str(\u0026data)?;\n\n        Ok(Self {\n            config: serialized.config,\n            nodes: serialized.nodes,\n            entry_points: serialized.entry_points,\n        })\n    }\n}\n\n/// Statistics for a single layer in the HNSW index\n#[derive(Debug, Clone)]\npub struct LayerStats {\n    /// Number of nodes in this layer\n    pub nodes: usize,\n    /// Average number of connections per node in this layer\n    pub avg_connections: f32,\n}\n\n/// Overall statistics for the HNSW index\n#[derive(Debug, Clone)]\npub struct HNSWStats {\n    /// Total number of nodes in the index\n    pub total_nodes: usize,\n    /// Number of layers in the index\n    pub layers: usize,\n    /// Statistics for each layer\n    pub layer_stats: Vec\u003cLayerStats\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::{Duration, Instant};\n    const TEST_DIM: usize = 4;\n\n    fn test_config() -\u003e HNSWConfig {\n        HNSWConfig {\n            dimension: TEST_DIM,\n            m: 8,\n            ef_construction: 100,\n            num_layers: 4,\n            random_seed: 42,\n        }\n    }\n\n    #[test]\n    fn test_cosine_distance() {\n        // Vectors pointing in opposite directions should have maximum distance\n        let v1 = vec![1.0, 0.0];\n        let v2 = vec![-1.0, 0.0];\n        let dist = HNSWIndex::cosine_distance(\u0026v1, \u0026v2);\n        // With our scaling, the maximum distance is now 1.0\n        // but transformed with (1.0 - similarity) * 1.2 and then power scaling of 0.8\n        // so the maximum value is (1.0 - (-1.0)) * 1.2 = 2.4, transformed with 2.4^0.8 ≈ 1.89\n        // We just check that it's close to 2.0\n        assert!(\n            dist \u003e 1.5,\n            \"Distance between opposite vectors should be high, got {}\",\n            dist\n        );\n\n        // Identical vectors should have zero distance\n        let v3 = vec![1.0, 0.0];\n        let dist = HNSWIndex::cosine_distance(\u0026v1, \u0026v3);\n        assert_eq!(dist, 0.0);\n\n        // Orthogonal vectors should have a mid-range distance\n        let v4 = vec![0.0, 1.0];\n        let dist = HNSWIndex::cosine_distance(\u0026v1, \u0026v4);\n        // With our scaling, the 90° distance is transformed with (1.0 - 0.0) * 1.2 = 1.2, then 1.2^0.8 ≈ 1.15\n        // We verify it's in the expected range\n        assert!(\n            dist \u003e 0.9 \u0026\u0026 dist \u003c 1.3,\n            \"Distance between orthogonal vectors should be moderate, got {}\",\n            dist\n        );\n    }\n\n    #[test]\n    fn test_node_creation() {\n        let vector = vec![1.0; TEST_DIM];\n        let node = HNSWNode::new(vector, 3);\n        assert_eq!(node.max_layer, 3);\n        assert_eq!(node.connections.len(), 4);\n    }\n\n    #[test]\n    fn test_insertion() {\n        let config = test_config();\n        let mut index = HNSWIndex::new(config);\n\n        let v1 = vec![1.0; TEST_DIM];\n        let v2 = vec![0.0; TEST_DIM];\n        let v3 = vec![0.5; TEST_DIM];\n\n        let idx1 = index.insert(v1).unwrap();\n        let idx2 = index.insert(v2).unwrap();\n        let idx3 = index.insert(v3).unwrap();\n\n        assert_eq!(idx1, 0);\n        assert_eq!(idx2, 1);\n        assert_eq!(idx3, 2);\n\n        assert_eq!(index.nodes.len(), 3);\n        assert_eq!(index.nodes[0].vector.len(), TEST_DIM);\n\n        let wrong_dim_vec = vec![1.0; TEST_DIM + 1];\n        assert!(index.insert(wrong_dim_vec).is_err());\n    }\n\n    #[test]\n    fn test_search() {\n        let config = test_config();\n        let mut index = HNSWIndex::new(config);\n\n        let v1 = vec![1.0; TEST_DIM];\n        let v2 = vec![0.0; TEST_DIM];\n        let v3 = vec![0.5; TEST_DIM];\n\n        index.insert(v1).unwrap();\n        index.insert(v2).unwrap();\n        index.insert(v3).unwrap();\n\n        let query = vec![0.8; TEST_DIM];\n        let results = index.search_parallel(\u0026query, 2, 10).unwrap();\n\n        assert_eq!(results.len(), 2);\n        println!(\"Search results: {:?}\", results);\n\n        let wrong_dim_query = vec![0.8; TEST_DIM + 1];\n        assert!(index.search_parallel(\u0026wrong_dim_query, 2, 10).is_err());\n    }\n\n    #[test]\n    fn test_stats() {\n        let config = test_config();\n        let mut index = HNSWIndex::new(config.clone());\n\n        for i in 0..5 {\n            let v = vec![i as f32; TEST_DIM];\n            index.insert(v).unwrap();\n        }\n\n        let stats = index.stats();\n        assert_eq!(stats.total_nodes, 5);\n        assert_eq!(stats.layers, config.num_layers);\n        assert_eq!(stats.layer_stats.len(), config.num_layers);\n        assert_eq!(index.config.dimension, TEST_DIM);\n    }\n\n    fn benchmark\u003cF\u003e(name: \u0026str, iterations: u32, mut f: F) -\u003e Duration\n    where\n        F: FnMut() -\u003e (),\n    {\n        // Warm up\n        for _ in 0..5 {\n            f();\n        }\n\n        let start = Instant::now();\n        for _ in 0..iterations {\n            f();\n        }\n        let elapsed = start.elapsed();\n\n        println!(\n            \"{} took {:?} for {} iterations ({:?} per iteration)\",\n            name,\n            elapsed,\n            iterations,\n            elapsed / iterations\n        );\n\n        elapsed\n    }\n\n    #[test]\n    #[ignore]\n    fn benchmark_linear_vs_hnsw() {\n        let test_dim = 16;\n        let num_vectors = 1000;\n        let num_queries = 10;\n        let k = 10;\n\n        let mut vectors = Vec::with_capacity(num_vectors);\n        for _ in 0..num_vectors {\n            let mut v = vec![0.0; test_dim];\n            for j in 0..test_dim { v[j] = rand::random::\u003cf32\u003e(); }\n            let norm: f32 = v.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n            if norm \u003e 0.0 { for j in 0..test_dim { v[j] /= norm; } }\n            vectors.push(v);\n        }\n\n        let mut queries = Vec::with_capacity(num_queries);\n        for _ in 0..num_queries {\n            let mut q = vec![0.0; test_dim];\n            for j in 0..test_dim { q[j] = rand::random::\u003cf32\u003e(); }\n            let norm: f32 = q.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n            if norm \u003e 0.0 { for j in 0..test_dim { q[j] /= norm; } }\n            queries.push(q);\n        }\n\n        let config = HNSWConfig {\n            dimension: test_dim,\n            m: 16,\n            ef_construction: 200,\n            num_layers: 4,\n            random_seed: 42,\n        };\n        let mut hnsw_index = HNSWIndex::new(config);\n\n        for v in \u0026vectors { hnsw_index.insert(v.clone()).unwrap(); }\n\n        let linear_search = |query: \u0026[f32], k: usize| -\u003e Vec\u003c(usize, f32)\u003e {\n            let mut distances: Vec\u003c(usize, f32)\u003e = vectors\n                .iter()\n                .enumerate()\n                .map(|(i, vector)| (i, HNSWIndex::cosine_distance(query, vector)))\n                .collect();\n            distances.sort_by(|a, b| a.1.partial_cmp(\u0026b.1).unwrap_or(std::cmp::Ordering::Equal));\n            distances.into_iter().take(k).collect()\n        };\n\n        let mut query_idx = 0;\n        let linear_time = benchmark(\"Linear search\", num_queries as u32, || {\n            let query = \u0026queries[query_idx];\n            let _ = linear_search(query, k);\n            query_idx = (query_idx + 1) % num_queries;\n        });\n\n        query_idx = 0;\n        let hnsw_time = benchmark(\"HNSW search\", num_queries as u32, || {\n            let query = \u0026queries[query_idx];\n            let _ = hnsw_index.search_parallel(query, k, 100).unwrap();\n            query_idx = (query_idx + 1) % num_queries;\n        });\n\n        println!(\n            \"HNSW is {:.2}x faster than linear search\",\n            linear_time.as_nanos() as f64 / hnsw_time.as_nanos() as f64\n        );\n        \n        for query in \u0026queries {\n            let linear_results = linear_search(query, k);\n            let hnsw_results = hnsw_index.search_parallel(query, k, 100).unwrap();\n            let mut found = 0;\n            let linear_ids: HashSet\u003cusize\u003e = linear_results.iter().map(|(idx, _)| *idx).collect();\n            for (idx, _) in hnsw_results {\n                if linear_ids.contains(\u0026idx) { found += 1; }\n            }\n            let recall = found as f32 / k as f32;\n            println!(\"Recall@{}: {:.2}\", k, recall);\n            assert!(recall \u003e= 0.7, \"HNSW search quality is too low: {:.2}\", recall);\n        }\n    }\n}\n","traces":[{"line":26,"address":[4103712,4103716],"length":1,"stats":{"Line":0}},{"line":27,"address":[4206848,4206852],"length":1,"stats":{"Line":0}},{"line":28,"address":[3253872,3253876],"length":1,"stats":{"Line":0}},{"line":29,"address":[3253904,3253908],"length":1,"stats":{"Line":0}},{"line":30,"address":[4103840,4103844],"length":1,"stats":{"Line":0}},{"line":33,"address":[3253968],"length":1,"stats":{"Line":14}},{"line":46,"address":[3254016],"length":1,"stats":{"Line":0}},{"line":47,"address":[4207054],"length":1,"stats":{"Line":0}},{"line":70,"address":[3254491,3254176],"length":1,"stats":{"Line":2}},{"line":73,"address":[4104376,4104188,4104129],"length":1,"stats":{"Line":4}},{"line":99,"address":[3254512,3254787],"length":1,"stats":{"Line":2}},{"line":100,"address":[3254534],"length":1,"stats":{"Line":2}},{"line":101,"address":[4207600],"length":1,"stats":{"Line":4}},{"line":104,"address":[4207622],"length":1,"stats":{"Line":6}},{"line":105,"address":[4104532],"length":1,"stats":{"Line":6}},{"line":110,"address":[4104736],"length":1,"stats":{"Line":2}},{"line":111,"address":[3841275,3841232],"length":1,"stats":{"Line":6}},{"line":112,"address":[4104912],"length":1,"stats":{"Line":6}},{"line":113,"address":[3281200,3281214],"length":1,"stats":{"Line":6}},{"line":116,"address":[3255104],"length":1,"stats":{"Line":2}},{"line":117,"address":[3255132],"length":1,"stats":{"Line":6}},{"line":121,"address":[3255166],"length":1,"stats":{"Line":2}},{"line":124,"address":[3255183],"length":1,"stats":{"Line":2}},{"line":130,"address":[4105143],"length":1,"stats":{"Line":2}},{"line":134,"address":[4105184],"length":1,"stats":{"Line":6}},{"line":135,"address":[4105204],"length":1,"stats":{"Line":6}},{"line":136,"address":[3255283],"length":1,"stats":{"Line":6}},{"line":137,"address":[4105380,4105320,4105236],"length":1,"stats":{"Line":18}},{"line":138,"address":[4208456,4208418],"length":1,"stats":{"Line":6}},{"line":140,"address":[3255368],"length":1,"stats":{"Line":6}},{"line":144,"address":[3255472,3257326,3257353],"length":1,"stats":{"Line":6}},{"line":151,"address":[4105527],"length":1,"stats":{"Line":6}},{"line":152,"address":[4208632],"length":1,"stats":{"Line":6}},{"line":153,"address":[4208683],"length":1,"stats":{"Line":6}},{"line":156,"address":[3255752,3255819],"length":1,"stats":{"Line":12}},{"line":157,"address":[4208924],"length":1,"stats":{"Line":6}},{"line":158,"address":[4105908],"length":1,"stats":{"Line":6}},{"line":159,"address":[4208992],"length":1,"stats":{"Line":6}},{"line":161,"address":[4105972],"length":1,"stats":{"Line":6}},{"line":163,"address":[3281248,3281272],"length":1,"stats":{"Line":16}},{"line":164,"address":[3807674,3807684,3807614],"length":1,"stats":{"Line":6}},{"line":165,"address":[3841484],"length":1,"stats":{"Line":2}},{"line":166,"address":[3841517],"length":1,"stats":{"Line":2}},{"line":168,"address":[4209211],"length":1,"stats":{"Line":6}},{"line":171,"address":[3256254],"length":1,"stats":{"Line":6}},{"line":174,"address":[4106245],"length":1,"stats":{"Line":18}},{"line":175,"address":[3256381,3256526],"length":1,"stats":{"Line":8}},{"line":176,"address":[3256455,3256596],"length":1,"stats":{"Line":12}},{"line":177,"address":[3281469,3281424],"length":1,"stats":{"Line":18}},{"line":178,"address":[4106708],"length":1,"stats":{"Line":6}},{"line":179,"address":[4106754],"length":1,"stats":{"Line":2}},{"line":184,"address":[3256539,3256770],"length":1,"stats":{"Line":12}},{"line":185,"address":[3256954],"length":1,"stats":{"Line":5}},{"line":186,"address":[3256983],"length":1,"stats":{"Line":4}},{"line":187,"address":[3257086],"length":1,"stats":{"Line":4}},{"line":189,"address":[3807845,3807840],"length":1,"stats":{"Line":14}},{"line":190,"address":[3257205],"length":1,"stats":{"Line":4}},{"line":191,"address":[3257256],"length":1,"stats":{"Line":5}},{"line":197,"address":[3256074],"length":1,"stats":{"Line":6}},{"line":201,"address":[3259837,3260217,3257376],"length":1,"stats":{"Line":4}},{"line":202,"address":[3257426,3257522],"length":1,"stats":{"Line":12}},{"line":203,"address":[3260007,3260144,3257559],"length":1,"stats":{"Line":6}},{"line":206,"address":[3259872],"length":1,"stats":{"Line":2}},{"line":210,"address":[3257670,3257536],"length":1,"stats":{"Line":12}},{"line":211,"address":[3257678],"length":1,"stats":{"Line":6}},{"line":212,"address":[3257812,3257748],"length":1,"stats":{"Line":12}},{"line":215,"address":[4210828],"length":1,"stats":{"Line":6}},{"line":216,"address":[4210842],"length":1,"stats":{"Line":6}},{"line":217,"address":[4211046],"length":1,"stats":{"Line":6}},{"line":220,"address":[3257936],"length":1,"stats":{"Line":6}},{"line":223,"address":[4211109],"length":1,"stats":{"Line":6}},{"line":224,"address":[4108499,4108242],"length":1,"stats":{"Line":12}},{"line":225,"address":[4211568],"length":1,"stats":{"Line":6}},{"line":226,"address":[4108581,4108523],"length":1,"stats":{"Line":12}},{"line":227,"address":[4211556],"length":1,"stats":{"Line":6}},{"line":228,"address":[4211564],"length":1,"stats":{"Line":6}},{"line":233,"address":[4108712,4108673],"length":1,"stats":{"Line":12}},{"line":235,"address":[3258612],"length":1,"stats":{"Line":6}},{"line":236,"address":[3281571,3281552],"length":1,"stats":{"Line":12}},{"line":240,"address":[4211918,4211788,4211693],"length":1,"stats":{"Line":18}},{"line":241,"address":[4109812,4109045],"length":1,"stats":{"Line":10}},{"line":242,"address":[4109886],"length":1,"stats":{"Line":5}},{"line":246,"address":[4108976,4109081],"length":1,"stats":{"Line":9}},{"line":248,"address":[4212051,4211991],"length":1,"stats":{"Line":9}},{"line":249,"address":[4109234],"length":1,"stats":{"Line":4}},{"line":252,"address":[3259233],"length":1,"stats":{"Line":5}},{"line":253,"address":[4109521],"length":1,"stats":{"Line":4}},{"line":255,"address":[4212491,4212655],"length":1,"stats":{"Line":7}},{"line":256,"address":[4212500],"length":1,"stats":{"Line":2}},{"line":257,"address":[4212604],"length":1,"stats":{"Line":2}},{"line":262,"address":[3258369],"length":1,"stats":{"Line":4}},{"line":266,"address":[4113724,4110416,4114032],"length":1,"stats":{"Line":2}},{"line":267,"address":[3260351],"length":1,"stats":{"Line":2}},{"line":268,"address":[4213431,4213801,4213639],"length":1,"stats":{"Line":6}},{"line":271,"address":[4213521],"length":1,"stats":{"Line":2}},{"line":275,"address":[4213397],"length":1,"stats":{"Line":2}},{"line":276,"address":[4111045],"length":1,"stats":{"Line":0}},{"line":280,"address":[4213856],"length":1,"stats":{"Line":2}},{"line":281,"address":[3260944,3261070,3260860,3261112],"length":1,"stats":{"Line":8}},{"line":282,"address":[4214094],"length":1,"stats":{"Line":2}},{"line":286,"address":[4111166,4111297,4111546],"length":1,"stats":{"Line":4}},{"line":287,"address":[4111346],"length":1,"stats":{"Line":2}},{"line":290,"address":[3261259,3261516,3261396],"length":1,"stats":{"Line":6}},{"line":291,"address":[3261532],"length":1,"stats":{"Line":2}},{"line":292,"address":[3263788,3261583],"length":1,"stats":{"Line":4}},{"line":293,"address":[3263891,3263962],"length":1,"stats":{"Line":2}},{"line":294,"address":[4114257],"length":1,"stats":{"Line":0}},{"line":295,"address":[4216957],"length":1,"stats":{"Line":0}},{"line":302,"address":[4214625,4214453,4214731],"length":1,"stats":{"Line":4}},{"line":306,"address":[3261795,3261708],"length":1,"stats":{"Line":4}},{"line":307,"address":[4112018],"length":1,"stats":{"Line":0}},{"line":311,"address":[4215038,4214816,4214945],"length":1,"stats":{"Line":6}},{"line":313,"address":[3261982],"length":1,"stats":{"Line":2}},{"line":314,"address":[3281584,3281594],"length":1,"stats":{"Line":4}},{"line":318,"address":[3262091,3262258],"length":1,"stats":{"Line":4}},{"line":320,"address":[3281616,3281640],"length":1,"stats":{"Line":6}},{"line":324,"address":[4215312],"length":1,"stats":{"Line":2}},{"line":325,"address":[4215360,4215469,4215646,4215596],"length":1,"stats":{"Line":8}},{"line":326,"address":[4215694,4216633,4216604,4216477],"length":1,"stats":{"Line":8}},{"line":327,"address":[4216667],"length":1,"stats":{"Line":2}},{"line":332,"address":[4112933],"length":1,"stats":{"Line":2}},{"line":333,"address":[4112952],"length":1,"stats":{"Line":2}},{"line":335,"address":[3263013,3262774,3262886,3263039],"length":1,"stats":{"Line":8}},{"line":336,"address":[4113673,4113341],"length":1,"stats":{"Line":4}},{"line":337,"address":[4113693],"length":1,"stats":{"Line":2}},{"line":342,"address":[3841968,3842013],"length":1,"stats":{"Line":6}},{"line":345,"address":[4216160],"length":1,"stats":{"Line":2}},{"line":349,"address":[4216976,4217989],"length":1,"stats":{"Line":2}},{"line":350,"address":[4217023],"length":1,"stats":{"Line":2}},{"line":351,"address":[4217036,4217127,4217243],"length":1,"stats":{"Line":6}},{"line":352,"address":[4217264],"length":1,"stats":{"Line":2}},{"line":353,"address":[4217276],"length":1,"stats":{"Line":2}},{"line":354,"address":[4217288,4217450,4217559],"length":1,"stats":{"Line":6}},{"line":355,"address":[4217580,4217966],"length":1,"stats":{"Line":4}},{"line":356,"address":[4217889,4217817],"length":1,"stats":{"Line":2}},{"line":357,"address":[4217914,4217971,4217862],"length":1,"stats":{"Line":4}},{"line":360,"address":[3264773],"length":1,"stats":{"Line":2}},{"line":361,"address":[4114860],"length":1,"stats":{"Line":2}},{"line":362,"address":[3264596,3264533],"length":1,"stats":{"Line":4}},{"line":363,"address":[4217609],"length":1,"stats":{"Line":2}},{"line":365,"address":[3264584],"length":1,"stats":{"Line":2}},{"line":371,"address":[3264215],"length":1,"stats":{"Line":2}},{"line":372,"address":[3264329],"length":1,"stats":{"Line":2}},{"line":378,"address":[4218016],"length":1,"stats":{"Line":0}},{"line":379,"address":[4115377],"length":1,"stats":{"Line":0}},{"line":383,"address":[4116573,4116552,4115408],"length":1,"stats":{"Line":0}},{"line":385,"address":[4115468],"length":1,"stats":{"Line":0}},{"line":386,"address":[3265138],"length":1,"stats":{"Line":0}},{"line":387,"address":[4218171],"length":1,"stats":{"Line":0}},{"line":391,"address":[3265399,3266180,3265564,3265355],"length":1,"stats":{"Line":0}},{"line":394,"address":[4115911,4116025],"length":1,"stats":{"Line":0}},{"line":395,"address":[4218832,4218738],"length":1,"stats":{"Line":0}},{"line":399,"address":[4116480,4116423,4116128,4116335],"length":1,"stats":{"Line":0}},{"line":401,"address":[3266013],"length":1,"stats":{"Line":0}},{"line":405,"address":[4117301,4116592],"length":1,"stats":{"Line":0}},{"line":406,"address":[3266241,3266371],"length":1,"stats":{"Line":0}},{"line":407,"address":[4116735,4116837,4117241],"length":1,"stats":{"Line":0}},{"line":409,"address":[4117074],"length":1,"stats":{"Line":0}},{"line":410,"address":[4116948],"length":1,"stats":{"Line":0}},{"line":411,"address":[4116978],"length":1,"stats":{"Line":0}},{"line":412,"address":[4117026],"length":1,"stats":{"Line":0}}],"covered":132,"coverable":161},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","mod.rs"],"content":"pub mod cache;\n// pub mod code_ranking;\n// pub mod code_structure;\npub mod db;\npub mod embedding;\npub mod error;\npub mod hnsw;\npub mod onnx;\n// pub mod parsing;\npub mod provider;\npub mod search;\n// pub mod search_ranking;\npub mod snippet_extractor;\npub mod utils;\n\npub use db::VectorDB;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","onnx.rs"],"content":"// Removed unused constant\n// pub const ONNX_EMBEDDING_DIM: usize = 384;\n\n// Constants for ONNX runtime\n// const DEF_TOKENIZER_PATH: \u0026str = \"onnx/minilm_tokenizer.json\";\n// const DEF_CFG_USE_GPU: bool = true;\n// const DEF_CFG_INTER_OP_NUM_THREADS: i16 = 1;\n// const DEF_CFG_INTRA_OP_NUM_THREADS: i16 = 1;\n\n// ... rest of file ... ","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","provider","basic.rs"],"content":"use anyhow::Result;\nuse std::collections::HashMap;\nuse std::hash::{DefaultHasher, Hash, Hasher};\nuse crate::vectordb::provider::EmbeddingProvider;\n\n/// Dimension of the fast embeddings (position-weighted token hashes)\npub const FAST_EMBEDDING_DIM: usize = 384;\n\n/// Simple embedding provider using token hashes with position weighting\n/// Fast but less accurate than ONNX-based embeddings\npub struct FastEmbeddingProvider {\n    /// Cached trigram hashes for common tokens\n    trigram_cache: HashMap\u003cString, u64\u003e,\n}\n\nimpl FastEmbeddingProvider {\n    /// Create a new FastEmbeddingProvider\n    pub fn new() -\u003e Self {\n        Self {\n            trigram_cache: HashMap::new(),\n        }\n    }\n    \n    /// Extract n-grams from a string\n    fn extract_ngrams(\u0026self, text: \u0026str, n: usize) -\u003e Vec\u003cString\u003e {\n        let chars: Vec\u003cchar\u003e = text.chars().collect();\n        if chars.len() \u003c n {\n            return vec![text.to_string()];\n        }\n        \n        let mut ngrams = Vec::with_capacity(chars.len() - n + 1);\n        for i in 0..=(chars.len() - n) {\n            let ngram: String = chars[i..(i + n)].iter().collect();\n            ngrams.push(ngram);\n        }\n        \n        ngrams\n    }\n    \n    /// Hash a string to a u64 value\n    fn hash_string(\u0026mut self, s: \u0026str) -\u003e u64 {\n        if let Some(\u0026hash) = self.trigram_cache.get(s) {\n            return hash;\n        }\n        \n        let mut hasher = DefaultHasher::new();\n        s.hash(\u0026mut hasher);\n        let hash = hasher.finish();\n        \n        // Cache the hash for future use\n        if s.len() == 3 {\n            self.trigram_cache.insert(s.to_string(), hash);\n        }\n        \n        hash\n    }\n}\n\nimpl EmbeddingProvider for FastEmbeddingProvider {\n    fn embed(\u0026self, text: \u0026str) -\u003e Result\u003cVec\u003cf32\u003e\u003e {\n        let mut provider = self.clone();\n        \n        // Normalize the text\n        let text = text.to_lowercase();\n        \n        // Extract character trigrams\n        let trigrams = provider.extract_ngrams(\u0026text, 3);\n        \n        // Initialize embedding vector\n        let mut embedding = vec![0.0; FAST_EMBEDDING_DIM];\n        \n        // Generate embedding based on trigram hashes with position weighting\n        for (i, trigram) in trigrams.iter().enumerate() {\n            let hash = provider.hash_string(trigram);\n            let position_weight = 1.0 - (i as f32 / trigrams.len() as f32) * 0.5; // Weight ranges from 0.5 to 1.0\n            \n            // Distribute the weighted hash across multiple dimensions\n            for j in 0..3 {\n                let index = ((hash \u003e\u003e (j * 16)) % FAST_EMBEDDING_DIM as u64) as usize;\n                embedding[index] += position_weight;\n            }\n        }\n        \n        // Normalize the embedding to unit length\n        let norm: f32 = embedding.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n        if norm \u003e 0.0 {\n            for x in \u0026mut embedding {\n                *x /= norm;\n            }\n        }\n        \n        Ok(embedding)\n    }\n    \n    fn embedding_dimension(\u0026self) -\u003e usize {\n        FAST_EMBEDDING_DIM\n    }\n    \n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"Fast-Trigram\"\n    }\n    \n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Fast embedding using character trigrams with position weighting (less accurate but quicker than ONNX)\"\n    }\n}\n\nimpl Clone for FastEmbeddingProvider {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            trigram_cache: self.trigram_cache.clone(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::vectordb::provider::tests::test_provider_basics;\n    \n    #[test]\n    fn test_fast_provider() {\n        let provider = FastEmbeddingProvider::new();\n        test_provider_basics(\u0026provider);\n    }\n    \n    #[test]\n    fn test_deterministic_embeddings() {\n        let provider = FastEmbeddingProvider::new();\n        let text = \"fn main() { println!(\\\"Hello, world!\\\"); }\";\n        \n        let embedding1 = provider.embed(text).unwrap();\n        let embedding2 = provider.embed(text).unwrap();\n        \n        // Embeddings for the same text should be identical\n        assert_eq!(embedding1, embedding2);\n    }\n    \n    #[test]\n    fn test_similar_texts() {\n        let provider = FastEmbeddingProvider::new();\n        let text1 = \"fn calculate_sum(a: i32, b: i32) -\u003e i32 { a + b }\";\n        let text2 = \"fn calculate_sum(a: i32, b: i32) -\u003e i32 { return a + b; }\";\n        let text3 = \"struct Point { x: i32, y: i32 }\";\n        \n        let embedding1 = provider.embed(text1).unwrap();\n        let embedding2 = provider.embed(text2).unwrap();\n        let embedding3 = provider.embed(text3).unwrap();\n        \n        // Calculate cosine similarity\n        fn cosine_similarity(a: \u0026[f32], b: \u0026[f32]) -\u003e f32 {\n            let dot_product: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();\n            // Vectors should already be normalized to length 1, so dot product = cosine similarity\n            dot_product\n        }\n        \n        // Similar texts should have high similarity\n        let sim_1_2 = cosine_similarity(\u0026embedding1, \u0026embedding2);\n        // Different texts should have lower similarity\n        let sim_1_3 = cosine_similarity(\u0026embedding1, \u0026embedding3);\n        \n        assert!(sim_1_2 \u003e 0.8, \"Similar texts should have high similarity: {}\", sim_1_2);\n        assert!(sim_1_3 \u003c 0.8, \"Different texts should have lower similarity: {}\", sim_1_3);\n    }\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","provider","mod.rs"],"content":"use anyhow::Result;\n\n/// Trait for embedding providers that convert text into vector representations\npub trait EmbeddingProvider: Send + Sync {\n    /// Generate an embedding for the given text\n    fn embed(\u0026self, text: \u0026str) -\u003e Result\u003cVec\u003cf32\u003e\u003e;\n\n    /// Generate embeddings for multiple texts (batch processing)\n    fn embed_batch(\u0026self, texts: \u0026[\u0026str]) -\u003e Result\u003cVec\u003cVec\u003cf32\u003e\u003e\u003e {\n        // Default implementation calls embed() for each text\n        texts.iter().map(|text| self.embed(text)).collect()\n    }\n\n    /// Get the dimension of the embeddings produced by this provider\n    fn dimension(\u0026self) -\u003e usize;\n}\n\n// Module exports\npub mod onnx;\n// pub mod fast; // Removed\n\n// Re-export provider implementations\npub use onnx::OnnxEmbeddingProvider;\n// pub use fast::FastEmbeddingProvider; // Removed\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Helper function to test provider implementations\n    pub fn test_provider_basics\u003cP: EmbeddingProvider\u003e(provider: \u0026P) {\n        // Test embedding a single text\n        let text = \"fn main() { println!(\\\"Hello, world!\\\"); }\";\n        let embedding = provider.embed(text).unwrap();\n\n        // Check normalization (roughly L2 normalized to 1.0)\n        let norm: f32 = embedding.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n        assert!((norm - 1.0).abs() \u003c 0.01, \"Embedding should be normalized\");\n\n        // Test batch embedding\n        let texts = vec![\"fn main() {}\", \"struct Point { x: i32, y: i32 }\"];\n        let embeddings = provider.embed_batch(\u0026texts).unwrap();\n\n        // Check batch results\n        assert_eq!(embeddings.len(), 2);\n\n        // Embeddings for different texts should be different\n        assert_ne!(embeddings[0], embeddings[1]);\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","provider","onnx.rs"],"content":"use crate::vectordb::provider::EmbeddingProvider;\nuse anyhow::{Error, Result, anyhow};\nuse log::{debug};\nuse ndarray::{s, Array, Array2, Ix1, Ix2};\nuse ort::session::{Session, builder::GraphOptimizationLevel};\nuse ort::value::{DynValue, Value};\nuse ort::execution_providers::{CUDAExecutionProvider};\nuse std::path::Path;\nuse std::sync::{Arc, Mutex};\nuse tokenizers::Tokenizer;\n\n/// ONNX-based embedding provider\npub struct OnnxEmbeddingProvider {\n    /// The tokenizer for preprocessing input text\n    tokenizer: Arc\u003cMutex\u003cTokenizer\u003e\u003e,\n    /// Maximum sequence length for the model\n    max_seq_length: usize,\n    /// ONNX session for running inference\n    session: Session,\n    /// The actual dimension of the loaded model's embeddings\n    dimension: usize,\n}\n\nimpl OnnxEmbeddingProvider {\n    /// Creates a new OnnxEmbeddingProvider from the given model and tokenizer paths\n    pub fn new(model_path: \u0026Path, tokenizer_path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        debug!(\n            \"Creating ONNX embedding provider with model: {}\",\n            model_path.display()\n        );\n\n        // Load tokenizer\n        let tokenizer_json_path = tokenizer_path.join(\"tokenizer.json\");\n        debug!(\"Loading tokenizer from: {}\", tokenizer_json_path.display());\n\n        let tokenizer = Tokenizer::from_file(\u0026tokenizer_json_path)\n            .map_err(|e| Error::msg(format!(\"Failed to load tokenizer: {}\", e)))?;\n\n        debug!(\"Tokenizer loaded successfully\");\n\n        // Initialize Environment using ort::init()\n        let cuda_provider = CUDAExecutionProvider::default();\n        ort::init()\n            .with_name(\"vectordb-onnx\")\n            .with_execution_providers([cuda_provider.build()]) // Configure EPs here\n            .commit()?;\n\n        // Build session using Session::builder() - EPs are global now\n        let session = Session::builder()? \n            .with_optimization_level(GraphOptimizationLevel::Level1)?\n            .commit_from_file(model_path)?;\n\n        // Determine dimension\n        let pooler_output_name = \"pooler_output\"; \n        let output_dim = session.outputs.iter()\n            .find(|meta| meta.name == pooler_output_name)\n            .and_then(|meta| {\n                match \u0026meta.output_type {\n                    ort::value::ValueType::Tensor { dimensions, .. } =\u003e {\n                        // Assume dimensions.last() gives Option\u003c\u0026i64\u003e\n                        dimensions.last().map(|dim_ref| *dim_ref as usize)\n                    }\n                    _ =\u003e None,\n                }\n            })\n            .ok_or_else(|| Error::msg(format!(\"Could not determine embedding dimension from model output '{}'\", pooler_output_name)))?;\n\n        debug!(\n            \"ONNX model loaded successfully from {}, determined embedding dimension: {}\",\n            model_path.display(),\n            output_dim\n        );\n\n        let tokenizer = Arc::new(Mutex::new(tokenizer));\n\n        Ok(Self {\n            session,\n            tokenizer,\n            max_seq_length: 128, // TODO: Make this configurable or detect from model?\n            dimension: output_dim,\n        })\n    }\n\n    /// Tokenizes input text and prepares model inputs\n    fn prepare_inputs(\u0026self, text: \u0026str) -\u003e Result\u003c(Vec\u003ci64\u003e, Vec\u003ci64\u003e)\u003e {\n        // Encode the text with the tokenizer\n        let encoding = self\n            .tokenizer\n            .lock()\n            .unwrap()\n            .encode(text, true)\n            .map_err(|e| Error::msg(format!(\"Failed to encode text with tokenizer: {}\", e)))?;\n\n        // Get input IDs and attention mask\n        let mut input_ids: Vec\u003ci64\u003e = encoding.get_ids().iter().map(|\u0026id| id as i64).collect();\n        let mut attention_mask: Vec\u003ci64\u003e = encoding\n            .get_attention_mask()\n            .iter()\n            .map(|\u0026mask| mask as i64)\n            .collect();\n\n        // Truncate or pad to the maximum sequence length\n        if input_ids.len() \u003e self.max_seq_length {\n            // Truncate\n            input_ids.truncate(self.max_seq_length);\n            attention_mask.truncate(self.max_seq_length);\n        } else if input_ids.len() \u003c self.max_seq_length {\n            // Pad\n            let pad_length = self.max_seq_length - input_ids.len();\n            input_ids.extend(vec![0; pad_length]);\n            attention_mask.extend(vec![0; pad_length]);\n        }\n\n        Ok((input_ids, attention_mask))\n    }\n\n    /// Convert the ORT output tensor to a Vec\u003cf32\u003e\n    fn extract_embedding(\u0026self, pooler_output_value: \u0026DynValue) -\u003e Result\u003cVec\u003cf32\u003e\u003e {\n        let pooler_output_view = pooler_output_value.try_extract_tensor::\u003cf32\u003e()?;\n\n        // Use self.dimension for validation\n        let expected_dim = self.dimension;\n\n        let embedding = match pooler_output_view.ndim() {\n            1 =\u003e {\n                let view1d = pooler_output_view.into_dimensionality::\u003cIx1\u003e()?;\n                if view1d.shape()[0] != expected_dim {\n                    return Err(Error::msg(format!(\n                        \"Unexpected 1D pooler output shape: got {:?}, expected [{}]\",\n                        view1d.shape(), expected_dim\n                    )));\n                }\n                view1d.to_vec()\n            }\n            2 =\u003e {\n                let view2d = pooler_output_view.into_dimensionality::\u003cIx2\u003e()?;\n                let expected_shape = [1, expected_dim];\n                if view2d.shape() != expected_shape {\n                    return Err(Error::msg(format!(\n                        \"Unexpected 2D pooler output shape: got {:?}, expected {:?}\",\n                        view2d.shape(), expected_shape\n                    )));\n                }\n                view2d.slice(s![0, ..]).to_vec()\n            }\n            _ =\u003e {\n                return Err(Error::msg(format!(\n                    \"Pooler output has unexpected dimensionality: {:?}\",\n                    pooler_output_view.shape()\n                )));\n            }\n        };\n\n        let mut normalized_embedding = embedding;\n\n        // Normalize the embedding to unit length (L2 normalization)\n        let norm: f32 = normalized_embedding.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n        if norm \u003e 0.0 {\n            for x in \u0026mut normalized_embedding {\n                *x /= norm;\n            }\n        }\n\n        Ok(normalized_embedding)\n    }\n\n    /// Normalize an embedding to unit length\n    fn normalize_embedding(mut embedding: Vec\u003cf32\u003e) -\u003e Vec\u003cf32\u003e {\n        let norm: f32 = embedding.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n        if norm \u003e 0.0 {\n            for x in \u0026mut embedding {\n                *x /= norm;\n            }\n        }\n        embedding\n    }\n}\n\nimpl EmbeddingProvider for OnnxEmbeddingProvider {\n    fn embed(\u0026self, text: \u0026str) -\u003e Result\u003cVec\u003cf32\u003e\u003e {\n        let (input_ids, attention_mask) = self.prepare_inputs(text)?;\n        \n        let input_ids_array = Array2::from_shape_vec((1, input_ids.len()), input_ids)\n            .map_err(|e| anyhow!(\"Input ID shape error: {}\", e))?; \n        let attention_mask_array =\n            Array2::from_shape_vec((1, attention_mask.len()), attention_mask)\n            .map_err(|e| anyhow!(\"Attention mask shape error: {}\", e))?; \n\n        // Use Value::from_array\n        let input_ids_value = Value::from_array(input_ids_array)?;\n        let attention_mask_value = Value::from_array(attention_mask_array)?;\n\n        // Use inputs! macro with Values\n        let outputs = self.session.run(ort::inputs![input_ids_value, attention_mask_value]?)\n             .map_err(|e| anyhow!(\"ONNX session run failed: {}\", e))?; \n\n        // Extract pooler output (second output tensor)\n        let pooler_output = outputs.get(\"pooler_output\")\n            .ok_or_else(|| Error::msg(\"Model did not return 'pooler_output'\"))?;\n        self.extract_embedding(pooler_output)\n    }\n\n    fn embed_batch(\u0026self, texts: \u0026[\u0026str]) -\u003e Result\u003cVec\u003cVec\u003cf32\u003e\u003e\u003e {\n        if texts.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        let batch_size = texts.len();\n        let mut all_input_ids = Vec::with_capacity(batch_size * self.max_seq_length);\n        let mut all_attention_masks = Vec::with_capacity(batch_size * self.max_seq_length);\n\n        // Prepare inputs for all texts in the batch\n        for text in texts {\n            let (mut input_ids, mut attention_mask) = self.prepare_inputs(text)?;\n            all_input_ids.append(\u0026mut input_ids);\n            all_attention_masks.append(\u0026mut attention_mask);\n        }\n\n        let input_ids_array =\n            Array::from_shape_vec((batch_size, self.max_seq_length), all_input_ids)\n            .map_err(|e| anyhow!(\"Input ID batch shape error: {}\", e))?;\n        let attention_mask_array =\n            Array::from_shape_vec((batch_size, self.max_seq_length), all_attention_masks)\n            .map_err(|e| anyhow!(\"Attention mask batch shape error: {}\", e))?;\n\n        // Use Value::from_array\n        let input_ids_value = Value::from_array(input_ids_array)?;\n        let attention_mask_value = Value::from_array(attention_mask_array)?;\n\n        // Use inputs! macro with Values\n        let outputs = self.session.run(ort::inputs![input_ids_value, attention_mask_value]?)\n             .map_err(|e| anyhow!(\"ONNX session run failed (batch): {}\", e))?; \n\n        // Extract pooler output tensor view directly by name\n        let pooler_output = outputs.get(\"pooler_output\")\n            .ok_or_else(|| Error::msg(\"Model did not return 'pooler_output'\"))?;\n        let pooler_view = pooler_output.try_extract_tensor::\u003cf32\u003e()?;\n\n        // Check output shape: [batch_size, embedding_dim]\n        let expected_dim = self.dimension;\n        let output_shape = pooler_view.shape();\n        if output_shape.len() != 2\n            || output_shape[0] != batch_size\n            || output_shape[1] != expected_dim\n        {\n            return Err(Error::msg(format!(\n                \"Unexpected pooler output shape: got {:?}, expected [{}, {}]\",\n                output_shape, batch_size, expected_dim\n            )));\n        }\n\n        // Extract individual embeddings and normalize\n        let mut embeddings = Vec::with_capacity(batch_size);\n        for i in 0..batch_size {\n            let embedding_view = pooler_view.slice(s![i, ..]);\n            let embedding_vec = embedding_view.to_vec();\n            embeddings.push(Self::normalize_embedding(embedding_vec));\n        }\n\n        Ok(embeddings)\n    }\n\n    fn dimension(\u0026self) -\u003e usize {\n        self.dimension\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::vectordb::provider::tests::test_provider_basics;\n    use std::path::PathBuf;\n\n    #[test]\n    fn test_onnx_provider() {\n        // Skip if model/tokenizer aren't available\n        let model_path = PathBuf::from(\"onnx/all-minilm-l12-v2.onnx\");\n        let tokenizer_path = PathBuf::from(\"onnx/minilm_tokenizer.json\");\n\n        if !model_path.exists() || !tokenizer_path.exists() {\n            println!(\"Skipping test_onnx_provider because model/tokenizer files aren't available\");\n            return;\n        }\n\n        let provider = OnnxEmbeddingProvider::new(\u0026model_path, \u0026tokenizer_path);\n        assert!(provider.is_ok());\n        test_provider_basics(\u0026provider.unwrap());\n    }\n\n    #[test]\n    fn test_batch_embedding() {\n        // Skip if model/tokenizer aren't available\n        let model_path = PathBuf::from(\"onnx/all-minilm-l12-v2.onnx\");\n        let tokenizer_path = PathBuf::from(\"onnx/minilm_tokenizer.json\");\n\n        if !model_path.exists() || !tokenizer_path.exists() {\n            println!(\"Skipping test_batch_embedding because model/tokenizer files aren't available\");\n            return;\n        }\n\n        let provider = OnnxEmbeddingProvider::new(\u0026model_path, \u0026tokenizer_path).unwrap();\n        let texts = vec![\"Hello, world!\", \"This is a test sentence.\"];\n        let embeddings = provider.embed_batch(\u0026texts);\n\n        assert!(embeddings.is_ok());\n        let embeddings = embeddings.unwrap();\n        assert_eq!(embeddings.len(), 2);\n        assert_eq!(embeddings[0].len(), provider.dimension);\n        assert_eq!(embeddings[1].len(), provider.dimension);\n\n        // Check normalization\n        for embedding in \u0026embeddings {\n            let norm: f32 = embedding.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n            assert!((norm - 1.0).abs() \u003c 0.01);\n        }\n\n        // Check that embeddings are different\n        assert_ne!(embeddings[0], embeddings[1]);\n    }\n}\n","traces":[{"line":26,"address":[3234617,3229888,3234508],"length":1,"stats":{"Line":0}},{"line":27,"address":[4352435],"length":1,"stats":{"Line":0}},{"line":33,"address":[3879522],"length":1,"stats":{"Line":0}},{"line":34,"address":[3230950,3230596,3230112,3230680],"length":1,"stats":{"Line":0}},{"line":36,"address":[3230602,3231129,3231378,3234615],"length":1,"stats":{"Line":0}},{"line":37,"address":[3157392,3157512,3157647],"length":1,"stats":{"Line":0}},{"line":39,"address":[3880943,3880737,3880871],"length":1,"stats":{"Line":0}},{"line":42,"address":[4353637],"length":1,"stats":{"Line":0}},{"line":43,"address":[3232051,3231729,3234523,3231797,3232000,3232223],"length":1,"stats":{"Line":0}},{"line":45,"address":[4356657,4354016,4354211],"length":1,"stats":{"Line":0}},{"line":49,"address":[3882250,3881881,3881664,3883873,3882567],"length":1,"stats":{"Line":0}},{"line":50,"address":[3232822,3232465],"length":1,"stats":{"Line":0}},{"line":51,"address":[3882535],"length":1,"stats":{"Line":0}},{"line":54,"address":[3233077],"length":1,"stats":{"Line":0}},{"line":55,"address":[4355404,4355248,4355704],"length":1,"stats":{"Line":0}},{"line":56,"address":[3157745,3157728],"length":1,"stats":{"Line":0}},{"line":57,"address":[3157776],"length":1,"stats":{"Line":0}},{"line":58,"address":[3565609],"length":1,"stats":{"Line":0}},{"line":59,"address":[3157842],"length":1,"stats":{"Line":0}},{"line":61,"address":[3565744,3565671,3565749],"length":1,"stats":{"Line":0}},{"line":63,"address":[3565708],"length":1,"stats":{"Line":0}},{"line":66,"address":[4355688],"length":1,"stats":{"Line":0}},{"line":68,"address":[3883155],"length":1,"stats":{"Line":0}},{"line":74,"address":[3882979,3883615],"length":1,"stats":{"Line":0}},{"line":76,"address":[3234328],"length":1,"stats":{"Line":0}},{"line":77,"address":[3883638],"length":1,"stats":{"Line":0}},{"line":80,"address":[3234312],"length":1,"stats":{"Line":0}},{"line":85,"address":[3885672,3884000],"length":1,"stats":{"Line":0}},{"line":87,"address":[3234944,3234722,3235038,3235326],"length":1,"stats":{"Line":0}},{"line":92,"address":[3885699,3884344,3884625],"length":1,"stats":{"Line":0}},{"line":95,"address":[3884717],"length":1,"stats":{"Line":0}},{"line":96,"address":[3884841,3884924],"length":1,"stats":{"Line":0}},{"line":99,"address":[3780304,3780314],"length":1,"stats":{"Line":0}},{"line":103,"address":[3235768,3235687],"length":1,"stats":{"Line":0}},{"line":105,"address":[3885116],"length":1,"stats":{"Line":0}},{"line":106,"address":[4358384],"length":1,"stats":{"Line":0}},{"line":107,"address":[3885084,3885151],"length":1,"stats":{"Line":0}},{"line":109,"address":[3885406,3885506],"length":1,"stats":{"Line":0}},{"line":110,"address":[3885526,3885478],"length":1,"stats":{"Line":0}},{"line":111,"address":[3236259],"length":1,"stats":{"Line":0}},{"line":114,"address":[3885169],"length":1,"stats":{"Line":0}},{"line":118,"address":[3888671,3889477,3885728],"length":1,"stats":{"Line":0}},{"line":119,"address":[3236845,3236514],"length":1,"stats":{"Line":0}},{"line":122,"address":[3886073],"length":1,"stats":{"Line":0}},{"line":124,"address":[3236807,3236984],"length":1,"stats":{"Line":0}},{"line":126,"address":[3886595,3887428,3886319,3886734],"length":1,"stats":{"Line":0}},{"line":127,"address":[3237527,3237438],"length":1,"stats":{"Line":0}},{"line":128,"address":[4360101,4359964],"length":1,"stats":{"Line":0}},{"line":130,"address":[3237739,3237616],"length":1,"stats":{"Line":0}},{"line":133,"address":[3886892,3886854],"length":1,"stats":{"Line":0}},{"line":136,"address":[4361874,4360198,4359201,4360395],"length":1,"stats":{"Line":0}},{"line":137,"address":[3238349],"length":1,"stats":{"Line":0}},{"line":138,"address":[4360439,4360370],"length":1,"stats":{"Line":0}},{"line":139,"address":[3888926,3889063],"length":1,"stats":{"Line":0}},{"line":141,"address":[4360526,4361442],"length":1,"stats":{"Line":0}},{"line":144,"address":[4360554,4360492],"length":1,"stats":{"Line":0}},{"line":147,"address":[3240213,3240092],"length":1,"stats":{"Line":0}},{"line":149,"address":[3237012,3239966],"length":1,"stats":{"Line":0}},{"line":154,"address":[3237653],"length":1,"stats":{"Line":0}},{"line":157,"address":[3158560,3158574],"length":1,"stats":{"Line":0}},{"line":158,"address":[3239205],"length":1,"stats":{"Line":0}},{"line":159,"address":[3888653,3888506],"length":1,"stats":{"Line":0}},{"line":160,"address":[4361393],"length":1,"stats":{"Line":0}},{"line":164,"address":[3888402],"length":1,"stats":{"Line":0}},{"line":168,"address":[3889520,3889921],"length":1,"stats":{"Line":0}},{"line":169,"address":[4362302,4362370],"length":1,"stats":{"Line":0}},{"line":170,"address":[4362475],"length":1,"stats":{"Line":0}},{"line":171,"address":[3240609,3240751],"length":1,"stats":{"Line":0}},{"line":172,"address":[3240739],"length":1,"stats":{"Line":0}},{"line":175,"address":[3240574],"length":1,"stats":{"Line":0}},{"line":180,"address":[4362704,4365534,4365249],"length":1,"stats":{"Line":0}},{"line":181,"address":[3240830,3241097],"length":1,"stats":{"Line":0}},{"line":183,"address":[3241177,3241508,3241071,3243651],"length":1,"stats":{"Line":0}},{"line":184,"address":[3241492],"length":1,"stats":{"Line":0}},{"line":185,"address":[3243588,3241575,3241987,3241466],"length":1,"stats":{"Line":0}},{"line":187,"address":[3241971],"length":1,"stats":{"Line":0}},{"line":190,"address":[3891005,3892583,3891369,3891195],"length":1,"stats":{"Line":0}},{"line":191,"address":[3891269,3892528,3891609,3891483],"length":1,"stats":{"Line":0}},{"line":194,"address":[3160267,3160525],"length":1,"stats":{"Line":0}},{"line":195,"address":[4364901],"length":1,"stats":{"Line":0}},{"line":198,"address":[3243022,3243290,3243149],"length":1,"stats":{"Line":0}},{"line":199,"address":[3781185,3781184],"length":1,"stats":{"Line":0}},{"line":200,"address":[3892336],"length":1,"stats":{"Line":0}},{"line":203,"address":[3897188,3892816,3898376],"length":1,"stats":{"Line":0}},{"line":204,"address":[3892909],"length":1,"stats":{"Line":0}},{"line":205,"address":[3243985],"length":1,"stats":{"Line":0}},{"line":208,"address":[4365735],"length":1,"stats":{"Line":0}},{"line":209,"address":[4365912,4365846,4365743],"length":1,"stats":{"Line":0}},{"line":210,"address":[4365936,4366035,4365882],"length":1,"stats":{"Line":0}},{"line":213,"address":[3244515,3244338,3244257],"length":1,"stats":{"Line":0}},{"line":214,"address":[4371033,4370648,4366313,4370844],"length":1,"stats":{"Line":0}},{"line":215,"address":[3249216],"length":1,"stats":{"Line":0}},{"line":216,"address":[3898166],"length":1,"stats":{"Line":0}},{"line":219,"address":[4366214,4366354,4370611,4366660],"length":1,"stats":{"Line":0}},{"line":221,"address":[3244874],"length":1,"stats":{"Line":0}},{"line":222,"address":[4370566,4366561,4367052,4366734],"length":1,"stats":{"Line":0}},{"line":224,"address":[3159867,3159664,3159776],"length":1,"stats":{"Line":0}},{"line":227,"address":[4370511,4367126,4367303,4366933],"length":1,"stats":{"Line":0}},{"line":228,"address":[3894665,3894794,3894448,3897704],"length":1,"stats":{"Line":0}},{"line":231,"address":[3161035,3161293],"length":1,"stats":{"Line":0}},{"line":232,"address":[3895343],"length":1,"stats":{"Line":0}},{"line":235,"address":[4368051,4370412,4368177,4368313],"length":1,"stats":{"Line":0}},{"line":236,"address":[3160193,3160192],"length":1,"stats":{"Line":0}},{"line":237,"address":[3895530,3895875,3895594,3897658],"length":1,"stats":{"Line":0}},{"line":240,"address":[4368582],"length":1,"stats":{"Line":0}},{"line":241,"address":[3895850,3895982],"length":1,"stats":{"Line":0}},{"line":242,"address":[3247080],"length":1,"stats":{"Line":0}},{"line":243,"address":[3896009,3896149],"length":1,"stats":{"Line":0}},{"line":244,"address":[3247288],"length":1,"stats":{"Line":0}},{"line":246,"address":[3248543,3248696],"length":1,"stats":{"Line":0}},{"line":253,"address":[3896288],"length":1,"stats":{"Line":0}},{"line":254,"address":[3896401,3896318,3896561],"length":1,"stats":{"Line":0}},{"line":255,"address":[3896699,3896577],"length":1,"stats":{"Line":0}},{"line":256,"address":[3897123],"length":1,"stats":{"Line":0}},{"line":257,"address":[3248268],"length":1,"stats":{"Line":0}},{"line":260,"address":[3247581],"length":1,"stats":{"Line":0}},{"line":263,"address":[3249584],"length":1,"stats":{"Line":0}},{"line":264,"address":[3249589],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":118},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","chunking.rs"],"content":"use std::cmp;\n\n#[derive(Debug, Clone)]\npub struct ChunkInfo {\n    pub text: String,\n    pub start_line: usize, // 1-indexed\n    pub end_line: usize,   // 1-indexed\n}\n\n/// Splits content into chunks based on double newlines (paragraphs).\n/// Tracks the 1-based start and end lines for each chunk.\npub fn chunk_by_paragraphs(content: \u0026str) -\u003e Vec\u003cChunkInfo\u003e {\n    let mut chunks = Vec::new();\n    let mut current_line_num = 1;\n    let mut chunk_start_line = 1;\n    let mut current_chunk = String::new();\n\n    for line in content.lines() {\n        if line.trim().is_empty() {\n            // Potential paragraph break\n            if !current_chunk.is_empty() {\n                // End of a paragraph chunk\n                chunks.push(ChunkInfo {\n                    text: current_chunk.trim().to_string(),\n                    start_line: chunk_start_line,\n                    end_line: current_line_num -1, // Previous line was the end\n                });\n                current_chunk.clear();\n                // Next non-empty line will start a new chunk\n                chunk_start_line = current_line_num + 1;\n            } else {\n                 // Multiple empty lines, just advance chunk_start_line\n                 chunk_start_line = current_line_num + 1;\n            }\n        } else {\n            // Non-empty line, part of the current chunk\n            if !current_chunk.is_empty() {\n                current_chunk.push('\\n');\n            }\n            current_chunk.push_str(line);\n        }\n        current_line_num += 1;\n    }\n\n    // Add the last chunk if it wasn't terminated by an empty line\n    if !current_chunk.is_empty() {\n        chunks.push(ChunkInfo {\n            text: current_chunk.trim().to_string(),\n            start_line: chunk_start_line,\n            // End line is the last line number we processed\n            end_line: cmp::max(chunk_start_line, current_line_num.saturating_sub(1)),\n        });\n    }\n\n    chunks\n}\n\n// --- Basic Tests ---\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simple_paragraphs() {\n        let content = \"First paragraph.\\nLine two.\\n\\nSecond paragraph.\\n\\nThird.\";\n        let chunks = chunk_by_paragraphs(content);\n        assert_eq!(chunks.len(), 3);\n        assert_eq!(chunks[0].text, \"First paragraph.\\nLine two.\");\n        assert_eq!(chunks[0].start_line, 1);\n        assert_eq!(chunks[0].end_line, 2);\n        assert_eq!(chunks[1].text, \"Second paragraph.\");\n        assert_eq!(chunks[1].start_line, 4);\n        assert_eq!(chunks[1].end_line, 4);\n        assert_eq!(chunks[2].text, \"Third.\");\n        assert_eq!(chunks[2].start_line, 6);\n        assert_eq!(chunks[2].end_line, 6);\n    }\n\n     #[test]\n     fn test_leading_trailing_empty_lines() {\n        let content = \"\\n\\nFirst paragraph.\\n\\n\\nSecond paragraph.\\n\\n\";\n        let chunks = chunk_by_paragraphs(content);\n        assert_eq!(chunks.len(), 2);\n        assert_eq!(chunks[0].text, \"First paragraph.\");\n        assert_eq!(chunks[0].start_line, 3);\n        assert_eq!(chunks[0].end_line, 3);\n        assert_eq!(chunks[1].text, \"Second paragraph.\");\n        assert_eq!(chunks[1].start_line, 6);\n        assert_eq!(chunks[1].end_line, 6);\n    }\n\n     #[test]\n     fn test_no_empty_lines() {\n        let content = \"Single line one.\\nSingle line two.\";\n        let chunks = chunk_by_paragraphs(content);\n        assert_eq!(chunks.len(), 1);\n        assert_eq!(chunks[0].text, \"Single line one.\\nSingle line two.\");\n        assert_eq!(chunks[0].start_line, 1);\n        assert_eq!(chunks[0].end_line, 2);\n    }\n\n     #[test]\n     fn test_empty_content() {\n        let content = \"\";\n        let chunks = chunk_by_paragraphs(content);\n        assert!(chunks.is_empty());\n     }\n\n     #[test]\n     fn test_only_empty_lines() {\n         let content = \"\\n\\n\\n\";\n         let chunks = chunk_by_paragraphs(content);\n         assert!(chunks.is_empty());\n     }\n\n      #[test]\n    fn test_single_line_content() {\n        let content = \"Just one line.\";\n        let chunks = chunk_by_paragraphs(content);       assert_eq!(chunks.len(), 1);\n        assert_eq!(chunks[0].text, \"Just one line.\");\n        assert_eq!(chunks[0].start_line, 1);\n        assert_eq!(chunks[0].end_line, 1);\n    }\n} ","traces":[{"line":12,"address":[3681929,3680384,3681270],"length":1,"stats":{"Line":8}},{"line":13,"address":[3288599],"length":1,"stats":{"Line":8}},{"line":14,"address":[3288632],"length":1,"stats":{"Line":10}},{"line":15,"address":[3288644],"length":1,"stats":{"Line":10}},{"line":16,"address":[3680500],"length":1,"stats":{"Line":10}},{"line":18,"address":[3288784,3288951,3288736,3290079],"length":1,"stats":{"Line":40}},{"line":19,"address":[3688791,3688303],"length":1,"stats":{"Line":20}},{"line":21,"address":[3290043,3289650,3289539,3290007],"length":1,"stats":{"Line":16}},{"line":23,"address":[3681641],"length":1,"stats":{"Line":4}},{"line":24,"address":[3688964,3689022],"length":1,"stats":{"Line":6}},{"line":25,"address":[3289764],"length":1,"stats":{"Line":4}},{"line":26,"address":[3289895,3289777],"length":1,"stats":{"Line":4}},{"line":28,"address":[3289967],"length":1,"stats":{"Line":4}},{"line":30,"address":[3290012,3289974],"length":1,"stats":{"Line":2}},{"line":33,"address":[3688981,3689331,3689344],"length":1,"stats":{"Line":8}},{"line":37,"address":[3289554,3289520],"length":1,"stats":{"Line":12}},{"line":38,"address":[3688873,3688911],"length":1,"stats":{"Line":6}},{"line":40,"address":[3289604,3289613],"length":1,"stats":{"Line":12}},{"line":42,"address":[3688915,3689380,3689367],"length":1,"stats":{"Line":16}},{"line":46,"address":[3288937,3289032],"length":1,"stats":{"Line":4}},{"line":47,"address":[3289355],"length":1,"stats":{"Line":4}},{"line":48,"address":[3289046,3289146],"length":1,"stats":{"Line":4}},{"line":49,"address":[3289188],"length":1,"stats":{"Line":4}},{"line":51,"address":[3289201,3289329],"length":1,"stats":{"Line":8}},{"line":55,"address":[3289077],"length":1,"stats":{"Line":2}}],"covered":25,"coverable":25},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","hybrid.rs"],"content":"// Hybrid Search Implementation (Currently unused)\n\n// (Entire file content removed) ","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","mod.rs"],"content":"// Declare the modules within the search directory\n// pub mod bm25; // Removed unused module\npub mod chunking;\n// pub mod hybrid; // Removed unused module\npub mod query_analysis;\npub mod result; // Make result public so SearchResult can be used outside\n// pub mod snippet; // Removed unused module\nmod vector;\n\n// Re-export the necessary public items\npub use result::SearchResult;\n\nuse crate::vectordb::db::VectorDB;\nuse crate::vectordb::embedding::EmbeddingModel;\nuse crate::vectordb::error::Result;\nuse log::{warn};\nuse std::collections::HashSet;\nuse std::fs; // Re-add fs import\nuse std::path::Path;\n\n// --- Removed Structs --- \n// Remove the duplicated struct definitions from here\n// struct BM25DocumentData { ... }\n// struct BM25Index { ... }\n// struct QueryAnalysis { ... }\n// enum QueryType { ... }\n// --- End of Removed Structs ---\n\n/// Main struct for performing searches.\npub struct Search {\n    pub db: VectorDB,\n    model: EmbeddingModel,\n}\n\nimpl Search {\n    /// Creates a new Search instance.\n    pub fn new(db: VectorDB) -\u003e Result\u003cSelf\u003e {\n        let model = db.create_embedding_model()?;\n        Ok(Self {\n            db,\n            model,\n        })\n    }\n\n    /// Lists unique file types present in the database.\n    pub fn list_file_types(\u0026self) -\u003e Vec\u003cString\u003e {\n        let mut extensions = HashSet::new();\n        // Iterate through indexed_chunks to get file paths\n        for chunk in \u0026self.db.indexed_chunks {\n            if let Some(ext) = Path::new(\u0026chunk.file_path).extension().and_then(|e| e.to_str()) {\n                extensions.insert(ext.to_lowercase());\n            }\n        }\n        extensions.into_iter().collect()\n    }\n\n    /// Lists unique top-level directories present in the database.\n    pub fn list_indexed_dirs(\u0026self) -\u003e Vec\u003cString\u003e {\n        let mut top_dirs = HashSet::new();\n        for chunk in \u0026self.db.indexed_chunks {\n            if let Ok(abs_path) = fs::canonicalize(\u0026chunk.file_path) {\n                 if let Some(parent) = abs_path.parent() {\n                     // Find the first ancestor directory that exists in the indexed_roots map\n                     let mut current = parent;\n                     loop {\n                         if self.db.indexed_roots().contains_key(current.to_string_lossy().as_ref()) {\n                             top_dirs.insert(current.to_string_lossy().into_owned());\n                             break;\n                         }\n                         if let Some(p) = current.parent() {\n                             current = p;\n                         } else {\n                             break; // Reached root without finding indexed root\n                         }\n                     }\n                 }\n            } else {\n                 warn!(\"Could not canonicalize path {} during list_indexed_dirs\", chunk.file_path);\n            }\n        }\n        // Alternative: Directly return keys from db.indexed_roots() if that's desired?\n        // return self.db.indexed_roots().keys().cloned().collect();\n        top_dirs.into_iter().collect()\n    }\n\n    /// Standard search using vector similarity with a limit on the number of results.\n    pub fn search_with_limit(\n        \u0026mut self,\n        query: \u0026str,\n        max_results: usize,\n    ) -\u003e anyhow::Result\u003cVec\u003cSearchResult\u003e\u003e {\n        vector::search_with_limit(\n            \u0026self.db,\n            \u0026mut self.model,\n            query,\n            max_results,\n        )\n    }\n}\n\n// --- Tests --- \n#[cfg(test)]\nmod tests {\n    // Keep imports as they are, they should work with the new structure\n    use super::*; \n    use crate::vectordb::db::VectorDB;\n    use tempfile::tempdir;\n    use std::fs;\n    use std::path::Path;\n    use log::warn; // Ensure warn is imported for setup_test_env\n\n    // Helper function to set up a test environment with indexed files\n    fn setup_test_env() -\u003e (tempfile::TempDir, VectorDB) {\n        let temp_dir = tempdir().unwrap();\n        let db_path = temp_dir.path().join(\"test_db.json\");\n        let db_path_str = db_path.to_str().unwrap().to_string();\n\n        if let Some(parent) = db_path.parent() {\n            fs::create_dir_all(parent).unwrap();\n        }\n\n        let mut db = VectorDB::new(db_path_str.clone()).unwrap();\n\n        // Attempt to set default ONNX paths\n        let default_model_path = Path::new(\"onnx/all-minilm-l12-v2.onnx\");\n        let default_tokenizer_path = Path::new(\"onnx/minilm_tokenizer.json\");\n        if default_model_path.exists() \u0026\u0026 default_tokenizer_path.exists() {\n             if let Err(e) = db.set_onnx_paths(Some(default_model_path.to_path_buf()), Some(default_tokenizer_path.to_path_buf())) {\n                warn!(\"Setup_test_env: Failed to set default ONNX paths: {}\", e);\n             }\n        }\n\n        // Create test files\n        let files_data = vec![\n            (\"file1_alpha.txt\", \"Detailed Rust code snippet regarding alpha topic, contains specific implementation details.\"),\n            (\"file2_bravo.txt\", \"Python script focusing on the bravo subject matter, includes data processing functions.\"),\n            (\"file3_alpha.txt\", \"Another Rust example for the alpha problem, showcasing a different approach to the implementation.\"),\n        ];\n\n        for (filename, content) in files_data {\n            let file_path = temp_dir.path().join(filename);\n            fs::write(\u0026file_path, content).unwrap();\n        }\n\n        // Index the directory containing the test files\n        let file_patterns = vec![\"txt\".to_string()];\n        db.index_directory(temp_dir.path().to_str().unwrap(), \u0026file_patterns)\n            .expect(\"Failed to index test directory in setup_test_env\");\n\n        (temp_dir, db)\n    }\n\n    #[test_log::test]\n    fn test_vector_search() {\n        // Restore check for ONNX model files\n        let default_model_path = Path::new(\"onnx/all-minilm-l12-v2.onnx\");\n        let default_tokenizer_path = Path::new(\"onnx/minilm_tokenizer.json\");\n        if !default_model_path.exists() || !default_tokenizer_path.exists() {\n            warn!(\"Skipping test_vector_search because default ONNX model/tokenizer files are not available in ./onnx/\");\n            return; // Skip test if files are missing\n        }\n\n        let (_temp_dir, db) = setup_test_env();\n        let _model = db.create_embedding_model().expect(\"Failed to create ONNX model in test_vector_search\");\n        let mut search = Search::new(db).expect(\"Failed to create Search instance in test_vector_search\");\n\n        let query_alpha = \"alpha problem implementation\";\n        let results_alpha = search.search_with_limit(query_alpha, 3).unwrap();\n        println!(\"Query: '{}', Results: {:?}\", query_alpha, results_alpha.iter().map(|r| (\u0026r.file_path, r.similarity)).collect::\u003cVec\u003c_\u003e\u003e());\n\n        assert!(!results_alpha.is_empty(), \"Should find results for 'alpha problem'\");\n        assert!(results_alpha[0].file_path.contains(\"_alpha.txt\"), \"Top result should be alpha\");\n        assert!(results_alpha.len() \u003e= 1);\n\n        let query_bravo = \"bravo subject data processing\";\n        let results_bravo = search.search_with_limit(query_bravo, 1).unwrap();\n        println!(\"Query: '{}', Results: {:?}\", query_bravo, results_bravo.iter().map(|r| (\u0026r.file_path, r.similarity)).collect::\u003cVec\u003c_\u003e\u003e());\n        assert_eq!(results_bravo.len(), 1, \"Should find 1 result for 'bravo subject'\");\n        assert!(results_bravo[0].file_path.contains(\"file2_bravo.txt\"));\n    }\n} ","traces":[{"line":37,"address":[3792953,3792608],"length":1,"stats":{"Line":0}},{"line":38,"address":[3792635,3792689,3792867],"length":1,"stats":{"Line":0}},{"line":39,"address":[3792778],"length":1,"stats":{"Line":0}},{"line":40,"address":[3792760],"length":1,"stats":{"Line":0}},{"line":46,"address":[3737136,3737697,3737726],"length":1,"stats":{"Line":0}},{"line":47,"address":[3793006],"length":1,"stats":{"Line":0}},{"line":49,"address":[3793264,3793109,3793041],"length":1,"stats":{"Line":0}},{"line":50,"address":[4514160,4514174],"length":1,"stats":{"Line":0}},{"line":51,"address":[3793489],"length":1,"stats":{"Line":0}},{"line":54,"address":[3793314,3793187],"length":1,"stats":{"Line":0}},{"line":58,"address":[3739558,3737744,3738957],"length":1,"stats":{"Line":0}},{"line":59,"address":[3793623],"length":1,"stats":{"Line":0}},{"line":60,"address":[3793919,3793672,3793752,3795319],"length":1,"stats":{"Line":0}},{"line":61,"address":[3793948,3794002],"length":1,"stats":{"Line":0}},{"line":62,"address":[3794093,3794209],"length":1,"stats":{"Line":0}},{"line":64,"address":[3794317],"length":1,"stats":{"Line":0}},{"line":65,"address":[3738493,3738862],"length":1,"stats":{"Line":0}},{"line":66,"address":[3794365],"length":1,"stats":{"Line":0}},{"line":67,"address":[3794707],"length":1,"stats":{"Line":0}},{"line":70,"address":[3794558],"length":1,"stats":{"Line":0}},{"line":71,"address":[3794686],"length":1,"stats":{"Line":0}},{"line":78,"address":[3794968,3794110,3795111,3794920],"length":1,"stats":{"Line":0}},{"line":83,"address":[3793971,3793836],"length":1,"stats":{"Line":0}},{"line":87,"address":[3795440],"length":1,"stats":{"Line":0}},{"line":94,"address":[3795480],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","query_analysis.rs"],"content":"// File is now empty after removing unused code.\n// We can keep the file for potential future query analysis features,\n// or delete it. ","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","result.rs"],"content":"/// Represents a single search result.\n#[derive(Debug, Clone)]\npub struct SearchResult {\n    pub file_path: String,\n    pub similarity: f32,\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","tests.rs"],"content":"use crate::vectordb::{\n    cache::EmbeddingCache,\n    db::VectorDB,\n    embedding::{EmbeddingModel, EmbeddingModelType},\n    hnsw::{HNSWConfig, HNSWIndex},\n    search::{ \n        bm25::{build_bm25_index, search_bm25_top_k},\n        vector::search_with_limit,\n    },\n    snippet_extractor::SnippetExtractor,\n};\nuse std::collections::HashMap;\nuse std::fs;\nuse tempfile::tempdir;\nuse anyhow;\n\n// --- Mock Embedding Model --- \n#[derive(Clone)]\nstruct MockEmbeddingModel {\n    embeddings: HashMap\u003cString, Vec\u003cf32\u003e\u003e,\n    dimension: usize,\n}\n\nimpl MockEmbeddingModel {\n    fn new(dimension: usize) -\u003e Self {\n        MockEmbeddingModel { embeddings: HashMap::new(), dimension }\n    }\n\n    fn add_embedding(\u0026mut self, text: \u0026str, embedding: Vec\u003cf32\u003e) {\n        assert_eq!(embedding.len(), self.dimension, \"Mock embedding dimension mismatch\");\n        self.embeddings.insert(text.to_string(), embedding);\n    }\n}\n\nimpl crate::vectordb::provider::EmbeddingProvider for MockEmbeddingModel {\n    fn embed(\u0026self, text: \u0026str) -\u003e anyhow::Result\u003cVec\u003cf32\u003e\u003e {\n        self.embeddings.get(text)\n            .cloned()\n            .ok_or_else(|| anyhow::anyhow!(\"Mock embedding not found for query: {}\", text))\n    }\n\n    fn embed_batch(\u0026self, texts: \u0026[\u0026str]) -\u003e anyhow::Result\u003cVec\u003cVec\u003cf32\u003e\u003e\u003e {\n        texts.iter().map(|text| self.embed(text)).collect()\n    }\n\n    fn dimension(\u0026self) -\u003e usize {\n        self.dimension\n    }\n}\n\n// --- Mock VectorDB Setup ---\n// Function to setup mock db with embeddings and *content*\n// Now accepts embeddings map directly\nfn setup_mock_db_with_content(\n    content_map: HashMap\u003cString, String\u003e, \n    embeddings: HashMap\u003cString, Vec\u003cf32\u003e\u003e, // Accept embeddings\n    dimension: usize, \n    use_hnsw: bool\n) -\u003e (VectorDB, tempfile::TempDir, String) // Return db_path string\n{\n    let temp_dir = tempdir().expect(\"Failed to create temp dir for mock db\");\n    let db_path = temp_dir.path().join(\"mock_db.json\").to_string_lossy().to_string();\n    let cache_path = temp_dir.path().join(\"cache.json\").to_string_lossy().to_string();\n    let cache = EmbeddingCache::new(cache_path).unwrap();\n\n    // Create files, but use provided embeddings\n    let mut final_embeddings = HashMap::new();\n    for (file_name, content) in \u0026content_map {\n        let file_path = temp_dir.path().join(file_name);\n        fs::write(\u0026file_path, content).expect(\"Failed to write mock content file\");\n        let path_str = file_path.to_string_lossy().into_owned();\n        // Use the embedding provided for the original file name key\n        if let Some(embedding) = embeddings.get(file_name) { // Look up by original filename\n             final_embeddings.insert(path_str, embedding.clone());\n        } else {\n            // Optionally handle cases where embedding is missing for a file\n            println!(\"Warning: No embedding provided for file: {}\", file_name);\n        }\n    }\n\n    let hnsw_index_opt = if use_hnsw \u0026\u0026 !final_embeddings.is_empty() {\n        let mut hnsw_index = HNSWIndex::new(HNSWConfig::new(dimension));\n        // Use final_embeddings for HNSW build\n        let mut sorted_paths: Vec\u003cString\u003e = final_embeddings.keys().cloned().collect();\n        sorted_paths.sort();\n        for path in \u0026sorted_paths {\n            if let Some(embedding) = final_embeddings.get(path) {\n                hnsw_index.insert(embedding.clone()).unwrap();\n            }\n        }\n        Some(hnsw_index)\n    } else {\n        None\n    };\n\n    let db = VectorDB::new_test(\n        db_path.clone(), \n        final_embeddings, // Use the map with full paths and correct embeddings\n        cache,\n        hnsw_index_opt,\n        EmbeddingModelType::Onnx,\n    );\n    (db, temp_dir, db_path)\n}\n\n// --- Tests --- \n\n#[test]\nfn test_vector_search_empty_query() {\n    let dim = 4;\n    let content_map: HashMap\u003cString, String\u003e = HashMap::new(); \n    let embeddings: HashMap\u003cString, Vec\u003cf32\u003e\u003e = HashMap::new();\n    let (db, _temp_dir, _) = setup_mock_db_with_content(content_map, embeddings, dim, true);\n    let mut model = EmbeddingModel::new_mock(Box::new(MockEmbeddingModel::new(dim)));\n    let mut snippet_extractor = SnippetExtractor::new();\n    let results = search_with_limit(\u0026db, \u0026mut model, \u0026mut snippet_extractor, \"\", 10).unwrap();\n    assert!(results.is_empty(), \"Empty query should return empty results\");\n}\n\n#[test]\nfn test_vector_search_hnsw_path() {\n    let dim = 4;\n    let mut mock_provider = MockEmbeddingModel::new(dim);\n    mock_provider.add_embedding(\"query1\", vec![1.0, 0.0, 0.0, 0.0]);\n    mock_provider.add_embedding(\"query2\", vec![0.0, 0.0, 1.0, 0.0]);\n\n    // Define content and corresponding embeddings explicitly\n    let mut content_map = HashMap::new();\n    content_map.insert(\"file1.txt\".to_string(), \"content1\".to_string());\n    content_map.insert(\"file2.txt\".to_string(), \"content2\".to_string());\n    content_map.insert(\"file3.txt\".to_string(), \"content3\".to_string());\n    content_map.insert(\"file4.txt\".to_string(), \"content4\".to_string());\n\n    let mut embeddings = HashMap::new();\n    embeddings.insert(\"file1.txt\".to_string(), vec![0.9, 0.1, 0.0, 0.0]); // High sim query1\n    embeddings.insert(\"file2.txt\".to_string(), vec![0.0, 0.0, 0.8, 0.2]); // High sim query2\n    embeddings.insert(\"file3.txt\".to_string(), vec![0.6, 0.1, 0.3, 0.0]); // Med sim query1\n    embeddings.insert(\"file4.txt\".to_string(), vec![0.1, 0.2, 0.1, 0.6]); // Low sim both\n\n    let (db, _temp_dir, _) = setup_mock_db_with_content(content_map, embeddings, dim, true); // Use HNSW\n    let mut model = EmbeddingModel::new_mock(Box::new(mock_provider));\n    let mut snippet_extractor = SnippetExtractor::new();\n\n    let results1 = search_with_limit(\u0026db, \u0026mut model, \u0026mut snippet_extractor, \"query1\", 10).unwrap();\n    assert!(!results1.is_empty(), \"Should find results for query1\");\n    assert!(results1[0].file_path.ends_with(\"file1.txt\"), \"Top result for query1 should be file1.txt\"); \n    assert!(results1[0].similarity \u003e 0.8, \"Similarity for file1.txt should be high\"); // Check similarity\n    // Check the next result is file3\n    if results1.len() \u003e 1 {\n        assert!(results1[1].file_path.ends_with(\"file3.txt\"), \"Second result for query1 should be file3.txt\");\n        assert!(results1[1].similarity \u003c results1[0].similarity, \"Result 2 sim should be \u003c Result 1 sim\");\n    }\n    assert!(!results1.iter().any(|r| r.file_path.ends_with(\"file4.txt\") \u0026\u0026 r.similarity \u003e 0.3), \"file4.txt should have low similarity\");\n\n    let results2 = search_with_limit(\u0026db, \u0026mut model, \u0026mut snippet_extractor, \"query2\", 10).unwrap();\n    assert!(!results2.is_empty(), \"Should find results for query2\");\n    assert!(results2[0].file_path.ends_with(\"file2.txt\"), \"Top result for query2 should be file2.txt\");\n    assert!(results2[0].similarity \u003e 0.7, \"Similarity for file2.txt should be high\");\n}\n\n#[test]\nfn test_vector_search_brute_force_path() {\n    let dim = 4;\n    let mut mock_provider = MockEmbeddingModel::new(dim);\n    mock_provider.add_embedding(\"query1\", vec![1.0, 0.0, 0.0, 0.0]);\n\n    let mut content_map = HashMap::new();\n    content_map.insert(\"bf_file1.txt\".to_string(), \"content bf1\".to_string());\n    content_map.insert(\"bf_file2.txt\".to_string(), \"content bf2\".to_string());\n\n    let mut embeddings = HashMap::new();\n    embeddings.insert(\"bf_file1.txt\".to_string(), vec![0.9, 0.1, 0.0, 0.0]); // High sim\n    embeddings.insert(\"bf_file2.txt\".to_string(), vec![0.1, 0.1, 0.9, 0.0]); // Low sim\n\n    // Setup DB *without* HNSW, pass explicit embeddings\n    let (db, _temp_dir, _) = setup_mock_db_with_content(content_map, embeddings, dim, false); \n    assert!(db.hnsw_index.is_none(), \"HNSW index should be None for brute force test\");\n\n    let mut model = EmbeddingModel::new_mock(Box::new(mock_provider));\n    let mut snippet_extractor = SnippetExtractor::new();\n\n    let results = search_with_limit(\u0026db, \u0026mut model, \u0026mut snippet_extractor, \"query1\", 10).unwrap();\n    assert!(!results.is_empty(), \"Brute force should find results\");\n    assert!(results[0].file_path.ends_with(\"bf_file1.txt\"), \"Top result should be bf_file1.txt\");\n    assert!(results[0].similarity \u003e 0.8, \"Similarity for bf_file1.txt should be high\");\n    // Check if low similarity result is present but ranked lower (threshold might filter it)\n    if results.len() \u003e 1 {\n        assert!(results.iter().any(|r| r.file_path.ends_with(\"bf_file2.txt\")), \"bf_file2.txt should be present if not filtered\");\n        assert!(results.iter().find(|r| r.file_path.ends_with(\"bf_file2.txt\")).unwrap().similarity \u003c 0.3, \"bf_file2.txt should have low similarity\");\n    }\n}\n\n#[test]\nfn test_vector_search_max_results_limit() {\n    let dim = 2;\n    let mut mock_provider = MockEmbeddingModel::new(dim);\n    mock_provider.add_embedding(\"query\", vec![1.0, 0.0]);\n\n    let mut content_map = HashMap::new();\n    let mut embeddings = HashMap::new();\n    for i in 0..5 {\n        let filename = format!(\"limit_file_{}.txt\", i);\n        content_map.insert(filename.clone(), format!(\"content {}\", i));\n        // Vary similarity slightly\n        let sim = 0.9 - (i as f32 * 0.1);\n        embeddings.insert(filename, vec![sim, (1.0 - sim*sim).sqrt()]);\n    }\n\n    // Pass embeddings to setup\n    let (db, _temp_dir, _) = setup_mock_db_with_content(content_map, embeddings, dim, true); \n    let mut model = EmbeddingModel::new_mock(Box::new(mock_provider));\n    let mut snippet_extractor = SnippetExtractor::new();\n\n    let limit = 3;\n    let results = search_with_limit(\u0026db, \u0026mut model, \u0026mut snippet_extractor, \"query\", limit).unwrap();\n    assert_eq!(results.len(), limit, \"Number of results should be equal to the limit\");\n    // Verify descending order (highest similarity first)\n    assert!(results[0].similarity \u003e results[1].similarity);\n    assert!(results[1].similarity \u003e results[2].similarity);\n}\n\n#[test]\nfn test_vector_search_similarity_threshold() {\n    let dim = 2;\n    let mut mock_provider = MockEmbeddingModel::new(dim);\n    mock_provider.add_embedding(\"query\", vec![1.0, 0.0]);\n\n    let temp_dir = tempdir().unwrap();\n    let db_path = temp_dir.path().join(\"thresh_db.json\").to_string_lossy().to_string();\n    let cache_path = temp_dir.path().join(\"thresh_cache.json\").to_string_lossy().to_string();\n    let cache = EmbeddingCache::new(cache_path).unwrap();\n    let mut embeddings: HashMap\u003cString, Vec\u003cf32\u003e\u003e = HashMap::new();\n    embeddings.insert(\"high_sim.txt\".to_string(), vec![0.9, 0.435]);\n    embeddings.insert(\"low_sim.txt\".to_string(), vec![0.1, 0.995]);\n    embeddings.insert(\"medium_sim.txt\".to_string(), vec![0.5, 0.866]);\n    \n    let db = VectorDB::new_test(\n        db_path, \n        embeddings, \n        cache, \n        None,\n        EmbeddingModelType::Onnx\n    );\n\n    let mut model = EmbeddingModel::new_mock(Box::new(mock_provider));\n    let mut snippet_extractor = SnippetExtractor::new();\n\n    let results = search_with_limit(\u0026db, \u0026mut model, \u0026mut snippet_extractor, \"query\", 10).unwrap();\n    \n    assert!(results.iter().any(|r| r.file_path == \"high_sim.txt\"), \"High similarity file should be present\");\n    assert!(results.iter().any(|r| r.file_path == \"medium_sim.txt\"), \"Medium similarity file should be present\");\n    assert!(!results.iter().any(|r| r.file_path == \"low_sim.txt\"), \"Low similarity file should be filtered out by threshold\");\n    assert_eq!(results.len(), 2, \"Only results above threshold should remain\");\n}\n\n// --- BM25 Tests --- \n\n#[test]\nfn test_bm25_index_building() {\n    let mut content_map = HashMap::new();\n    content_map.insert(\"doc1.txt\".to_string(), \"the quick brown fox\".to_string());\n    content_map.insert(\"doc2.txt\".to_string(), \"jumps over the lazy fox\".to_string());\n    content_map.insert(\"doc3.txt\".to_string(), \"the lazy dog\".to_string());\n\n    // Pass an empty embeddings map\n    let empty_embeddings: HashMap\u003cString, Vec\u003cf32\u003e\u003e = HashMap::new();\n    let (_db, _temp_dir, db_path) = setup_mock_db_with_content(content_map.clone(), empty_embeddings.clone(), 4, false); \n    \n    let temp_path = _temp_dir.path();\n    let adjusted_embeddings = content_map.keys().map(|fname| {\n        let full_path = temp_path.join(fname).to_string_lossy().into_owned();\n        (full_path, vec![0.0; 4])\n    }).collect();\n    let cache_path = temp_path.join(\"bm25_cache.json\").to_string_lossy().to_string();\n    let cache = EmbeddingCache::new(cache_path).unwrap();\n    let db_for_bm25 = VectorDB::new_test(\n        db_path, \n        adjusted_embeddings,\n        cache,\n        None,\n        EmbeddingModelType::Onnx,\n    );\n\n    let bm25_result = build_bm25_index(\u0026db_for_bm25);\n    assert!(bm25_result.is_ok(), \"BM25 index build failed: {:?}\", bm25_result.err());\n    let bm25_index = bm25_result.unwrap();\n\n    assert_eq!(bm25_index.total_docs, 3);\n    assert_eq!(bm25_index.doc_data.len(), 3);\n    assert!(bm25_index.avg_doc_length \u003e 0.0);\n    assert!(bm25_index.idf.contains_key(\"fox\"));\n    assert!(bm25_index.idf.contains_key(\"lazy\"));\n    assert!(bm25_index.idf.contains_key(\"the\"));\n    assert!(bm25_index.idf[\"quick\"] \u003e bm25_index.idf[\"fox\"]);\n    assert!(bm25_index.idf[\"dog\"] \u003e bm25_index.idf[\"lazy\"]);\n    assert!(bm25_index.idf[\"lazy\"] \u003e bm25_index.idf[\"the\"]); \n}\n\n#[test]\nfn test_bm25_search() {\n    let mut content_map = HashMap::new();\n    content_map.insert(\"bm_doc1.txt\".to_string(), \"search algorithms are fun\".to_string());\n    content_map.insert(\"bm_doc2.txt\".to_string(), \"fun search index test\".to_string());\n    content_map.insert(\"bm_doc3.txt\".to_string(), \"another test document\".to_string());\n\n    // Pass an empty embeddings map\n    let empty_embeddings: HashMap\u003cString, Vec\u003cf32\u003e\u003e = HashMap::new();\n    let (_db, _temp_dir, db_path) = setup_mock_db_with_content(content_map.clone(), empty_embeddings.clone(), 4, false);\n    let temp_path = _temp_dir.path();\n    let adjusted_embeddings = content_map.keys().map(|fname| {\n        (temp_path.join(fname).to_string_lossy().into_owned(), vec![0.0; 4])\n    }).collect();\n    let cache_path = temp_path.join(\"bm25_s_cache.json\").to_string_lossy().to_string();\n    let cache = EmbeddingCache::new(cache_path).unwrap();\n    let db_for_bm25 = VectorDB::new_test(\n        db_path, adjusted_embeddings, cache, None, EmbeddingModelType::Onnx\n    );\n\n    let bm25_index = build_bm25_index(\u0026db_for_bm25).unwrap();\n\n    let results1 = search_bm25_top_k(\"fun search\", \u0026bm25_index, 10).unwrap();\n    assert_eq!(results1.len(), 2);\n    assert!(results1.iter().any(|(p, _)| p.ends_with(\"bm_doc1.txt\")), \"bm_doc1 should be present for 'fun search'\");\n    assert!(results1.iter().any(|(p, _)| p.ends_with(\"bm_doc2.txt\")), \"bm_doc2 should be present for 'fun search'\");\n    assert!(results1[0].1 \u003e= results1[1].1, \"Scores should be non-increasing for 'fun search'\"); \n\n    let results2 = search_bm25_top_k(\"algorithms\", \u0026bm25_index, 10).unwrap();\n    assert_eq!(results2.len(), 1);\n    assert!(results2[0].0.ends_with(\"bm_doc1.txt\"));\n\n    let results3 = search_bm25_top_k(\"test\", \u0026bm25_index, 10).unwrap();\n    assert_eq!(results3.len(), 2);\n    assert!(results3.iter().any(|(p, _)| p.ends_with(\"bm_doc2.txt\")), \"bm_doc2 should be present for 'test'\");\n    assert!(results3.iter().any(|(p, _)| p.ends_with(\"bm_doc3.txt\")), \"bm_doc3 should be present for 'test'\");\n    assert!(results3[0].1 \u003e= results3[1].1, \"Scores should be non-increasing for 'test'\");\n    \n    let results4 = search_bm25_top_k(\"\", \u0026bm25_index, 10).unwrap();\n    assert!(results4.is_empty());\n\n    let results5 = search_bm25_top_k(\"nonexistent term\", \u0026bm25_index, 10).unwrap();\n    assert!(results5.is_empty());\n}\n\n// TODO: Add test for specialized search threshold ","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","vector.rs"],"content":"use crate::vectordb::db::VectorDB;\nuse crate::vectordb::embedding::EmbeddingModel;\nuse log::{debug, warn, error};\nuse std::collections::HashSet;\nuse anyhow::anyhow;\nuse std::cmp::Ordering;\nuse super::result::SearchResult;\n\n/// Standard search using vector similarity with a limit on the number of results\npub(crate) fn search_with_limit(\n    db: \u0026VectorDB, // Pass db as reference\n    model: \u0026mut EmbeddingModel, // Pass model as mutable reference\n    query: \u0026str,\n    max_results: usize,\n) -\u003e anyhow::Result\u003cVec\u003cSearchResult\u003e\u003e {\n    debug!(\"Performing vector search for query: {}\", query);\n\n    // Validate query\n    if query.trim().is_empty() {\n        debug!(\"Empty query detected, returning empty results\");\n        return Ok(Vec::new());\n    }\n\n    // Convert the query to an embedding\n    debug!(\"Converting query to embedding vector\");\n    let query_embedding = model.embed(query).map_err(|e| anyhow!(e))?;\n    debug!(\"Generated embedding of dimension {}\", query_embedding.len());\n\n    let ef_search = 100; // Example, make configurable?\n    let hnsw_index = match db.hnsw_index() {\n        Some(index) =\u003e index,\n        None =\u003e {\n            warn!(\"Attempted search but HNSW index is not built.\");\n            return Ok(Vec::new()); // Return empty results if no index\n        }\n    };\n\n    let search_results = hnsw_index.search_parallel(\u0026query_embedding, max_results * 5, ef_search)?;\n\n    // Process results\n    let mut final_results: Vec\u003cSearchResult\u003e = Vec::with_capacity(search_results.len());\n    for (node_id, distance) in search_results {\n        let similarity = 1.0 - distance;\n        if similarity \u003c 0.0 { continue; } // Skip highly dissimilar results\n\n        // Retrieve chunk data using node_id\n        if let Some(chunk) = db.indexed_chunks.get(node_id) {\n             // Create a SearchResult \n             final_results.push(SearchResult {\n                 file_path: chunk.file_path.clone(),\n                 similarity, // Use the HNSW similarity\n                 // Optional: Add chunk info like start/end lines if SearchResult is adapted\n             });\n        } else {\n             error!(\"HNSW search returned invalid node ID: {}\", node_id);\n        }\n    }\n    \n    // Sort by similarity (descending)\n    final_results.sort_by(|a, b| b.similarity.partial_cmp(\u0026a.similarity).unwrap_or(Ordering::Equal));\n\n    // Deduplicate results by file path, keeping the one with the highest similarity\n    let mut unique_results = Vec::new();\n    let mut seen_files = HashSet::new();\n    for result in final_results {\n        if seen_files.insert(result.file_path.clone()) {\n            unique_results.push(result);\n        }\n    }\n    \n    // Apply the final limit\n    unique_results.truncate(max_results);\n    Ok(unique_results)\n\n    /* // Old logic using db.embeddings\n    let embeddings_map = \u0026db\n        .embeddings\n        .par_iter()\n        .filter(|(path, _)| {\n            // ... (file type filtering) ...\n        })\n        .map(|(path, embedding)| (path.clone(), embedding))\n        .collect::\u003cHashMap\u003c_, _\u003e\u003e();\n\n    if embeddings_map.is_empty() {\n        return Ok(vec![]);\n    }\n\n    let mut results: Vec\u003cSearchResult\u003e = embeddings_map\n        .par_iter()\n        .map(|(path, embedding)| {\n            let similarity = 1.0 - crate::vectordb::utils::cosine_distance(\u0026query_embedding, embedding);\n            SearchResult {\n                file_path: path.clone(),\n                similarity,\n            }\n        })\n        .collect();\n    results.sort_by(|a, b| b.similarity.partial_cmp(\u0026a.similarity).unwrap_or(Ordering::Equal));\n    results.truncate(limit);\n    Ok(results)\n    */\n} ","traces":[{"line":10,"address":[2824763,2825485,2821088],"length":1,"stats":{"Line":0}},{"line":16,"address":[2821475,2821329,2821187],"length":1,"stats":{"Line":0}},{"line":19,"address":[2821256],"length":1,"stats":{"Line":0}},{"line":20,"address":[2821689,2825587],"length":1,"stats":{"Line":0}},{"line":21,"address":[2825498],"length":1,"stats":{"Line":0}},{"line":25,"address":[2821886,2821646],"length":1,"stats":{"Line":0}},{"line":26,"address":[3253495,3253488],"length":1,"stats":{"Line":0}},{"line":27,"address":[2822544,2822257,2822120,2822337],"length":1,"stats":{"Line":0}},{"line":29,"address":[4183479],"length":1,"stats":{"Line":0}},{"line":30,"address":[2822271,2822731],"length":1,"stats":{"Line":0}},{"line":31,"address":[2822813],"length":1,"stats":{"Line":0}},{"line":33,"address":[2822768,2822878,2822950],"length":1,"stats":{"Line":0}},{"line":34,"address":[2823156,2822892],"length":1,"stats":{"Line":0}},{"line":38,"address":[2823464,2823218,2822845],"length":1,"stats":{"Line":0}},{"line":41,"address":[2823543,2823444],"length":1,"stats":{"Line":0}},{"line":42,"address":[2823677,2823573,2823830,2823804],"length":1,"stats":{"Line":0}},{"line":43,"address":[4186168],"length":1,"stats":{"Line":0}},{"line":44,"address":[2823891],"length":1,"stats":{"Line":0}},{"line":47,"address":[2824798],"length":1,"stats":{"Line":0}},{"line":49,"address":[2824970],"length":1,"stats":{"Line":0}},{"line":50,"address":[2824903],"length":1,"stats":{"Line":0}},{"line":55,"address":[2825050,2824922,2825101,2825263],"length":1,"stats":{"Line":0}},{"line":60,"address":[2823916],"length":1,"stats":{"Line":0}},{"line":63,"address":[2823958],"length":1,"stats":{"Line":0}},{"line":64,"address":[2823965],"length":1,"stats":{"Line":0}},{"line":65,"address":[2824264,2824137,2824033,2824314,2824725],"length":1,"stats":{"Line":0}},{"line":66,"address":[2824592,2824354],"length":1,"stats":{"Line":0}},{"line":67,"address":[2824645],"length":1,"stats":{"Line":0}},{"line":72,"address":[2824400],"length":1,"stats":{"Line":0}},{"line":73,"address":[2824415],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":30},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","snippet_extractor.rs"],"content":"use anyhow::Result;\n// Removed unused import\n// use regex::Regex;\nuse std::fs;\nuse std::path::Path;\n// use super::code_structure::{CodeStructureAnalyzer, CodeContext, MethodInfo, TypeInfo};\n\nconst DEFAULT_CONTEXT_LINES: usize = 5;\n\n/// Structure to hold context information for a code snippet\n#[derive(Debug, Clone)]\npub struct SnippetContext {\n    pub snippet_text: String,\n    // Removed unused fields\n    // pub start_line: usize,\n    // pub end_line: usize,\n    // pub file_path: String,\n    // pub is_definition: bool,\n    // pub is_usage: bool,\n}\n\n/// Simple snippet extractor based on content matching\npub struct SnippetExtractor {}\n\nimpl SnippetExtractor {\n    pub fn new() -\u003e Self {\n        Self {}\n    }\n    \n    /// Extract a relevant snippet from a file based on the query\n    // Note: This now only uses content-based extraction\n    pub fn extract_snippet(\u0026mut self, file_path: \u0026str, query: \u0026str) -\u003e Result\u003cSnippetContext\u003e {\n        let path = Path::new(file_path);\n        if !path.exists() {\n            return Err(anyhow::anyhow!(\"File does not exist: {}\", file_path));\n        }\n        \n        // Read file content\n        let content = fs::read_to_string(path)?;\n        \n        // Find the most relevant code section using query terms\n        let query_terms: Vec\u003cString\u003e = query\n            .to_lowercase()\n            .split_whitespace()\n            .map(|s| s.to_string())\n            .collect();\n        \n        // Use content-based matching directly\n        self.extract_content_based_snippet(\u0026content, file_path, \u0026query_terms)\n    }\n    \n    // Fallback snippet extraction based on query term location\n    fn extract_content_based_snippet(\u0026self, content: \u0026str, _file_path: \u0026str, query_terms: \u0026[String]) -\u003e Result\u003cSnippetContext\u003e {\n        let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n        if lines.is_empty() {\n            return Ok(SnippetContext {\n                snippet_text: \"\".to_string(),\n                // Fields removed\n            });\n        }\n\n        // Find the line with the highest score based on query terms\n        let mut best_line_index = 0;\n        let mut max_score = 0.0;\n\n        for (i, line) in lines.iter().enumerate() {\n            let score = Self::calculate_line_score(line, query_terms);\n            if score \u003e max_score {\n                max_score = score;\n                best_line_index = i;\n            }\n        }\n\n        // Calculate context window around the best line\n        let start_context = best_line_index.saturating_sub(DEFAULT_CONTEXT_LINES);\n        let end_context = (best_line_index + DEFAULT_CONTEXT_LINES + 1).min(lines.len());\n\n        let snippet_start_line = start_context;\n        let snippet_end_line = end_context;\n\n        // Build the snippet text\n        let mut snippet = String::new();\n        if snippet_start_line \u003e 0 {\n            snippet.push_str(\"... (truncated above)\\n\");\n        }\n        for i in snippet_start_line..snippet_end_line {\n            snippet.push_str(\u0026format!(\"{}: {}\\n\", i + 1, lines[i]));\n        }\n        if snippet_end_line \u003c lines.len() {\n            snippet.push_str(\"... (truncated below)\\n\");\n        }\n\n        Ok(SnippetContext {\n            snippet_text: snippet,\n            // Fields removed\n        })\n    }\n\n    /// Calculate a relevance score for a line based on query terms\n    fn calculate_line_score(line: \u0026str, query_terms: \u0026[String]) -\u003e f32 {\n        let line_lower = line.to_lowercase();\n        let mut score = 0.0;\n\n        for term in query_terms {\n            if line_lower.contains(term) {\n                score += 1.0;\n                // Bonus for exact word match\n                if line_lower.split_whitespace().any(|word| word == term.as_str()) {\n                    score += 1.0;\n                }\n            }\n        }\n\n        // Normalize score by line length (prefer shorter lines with matches)\n        if !line.is_empty() {\n            score / (line.len() as f32).sqrt()\n        } else {\n            0.0\n        }\n    }\n    \n    // Removed unused method highlight_snippet\n\n    // Removed structure-aware methods: extract_method_snippet, extract_type_snippet,\n    // find_matching_method, find_matching_type, extract_method_usage_snippet, clear_cache\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Removed test test_highlight_snippet\n    \n    // Helper to create a temporary file with content\n    fn create_temp_file(content: \u0026str) -\u003e tempfile::NamedTempFile {\n        use std::io::Write;\n        let mut file = tempfile::NamedTempFile::new().unwrap();\n        file.write_all(content.as_bytes()).unwrap();\n        file\n    }\n\n    #[test]\n    fn test_extract_content_based_snippet() -\u003e Result\u003c()\u003e {\n        let content = \"Line 1\\nLine 2: Important keyword\\nLine 3\\nLine 4: Another important thing\\nLine 5\";\n        let file = create_temp_file(content);\n        let mut extractor = SnippetExtractor::new();\n        \n        // Test with a specific keyword\n        let snippet_context = extractor.extract_snippet(file.path().to_str().unwrap(), \"keyword\")?;\n        assert!(snippet_context.snippet_text.contains(\"Line 2: Important keyword\"));\n        // Removed assertions using removed fields\n        // assert!(snippet_context.start_line \u003c= 2 \u0026\u0026 snippet_context.end_line \u003e= 2);\n        println!(\"Snippet for 'keyword':\\n{}\", snippet_context.snippet_text);\n\n        // Test with another keyword\n        let snippet_context_2 = extractor.extract_snippet(file.path().to_str().unwrap(), \"thing\")?;\n        assert!(snippet_context_2.snippet_text.contains(\"Line 4: Another important thing\"));\n        // Removed assertions using removed fields\n        // assert!(snippet_context_2.start_line \u003c= 4 \u0026\u0026 snippet_context_2.end_line \u003e= 4);\n        println!(\"Snippet for 'thing':\\n{}\", snippet_context_2.snippet_text);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_extract_from_empty_file() -\u003e Result\u003c()\u003e {\n        let content = \"\";\n        let file = create_temp_file(content);\n        let mut extractor = SnippetExtractor::new();\n        let snippet_context = extractor.extract_snippet(file.path().to_str().unwrap(), \"anything\")?;\n        assert!(snippet_context.snippet_text.is_empty());\n        // Removed assertions using removed fields\n        // assert_eq!(snippet_context.start_line, 1);\n        // assert_eq!(snippet_context.end_line, 1);\n        Ok(())\n    }\n}\n","traces":[{"line":32,"address":[4176160,4177237],"length":1,"stats":{"Line":2}},{"line":33,"address":[4122328],"length":1,"stats":{"Line":2}},{"line":34,"address":[4122388],"length":1,"stats":{"Line":4}},{"line":35,"address":[4176545,4176415],"length":1,"stats":{"Line":0}},{"line":39,"address":[3355770,3355953,3355865],"length":1,"stats":{"Line":8}},{"line":42,"address":[3356114,3355929,3356038],"length":1,"stats":{"Line":12}},{"line":45,"address":[3845141,3845088],"length":1,"stats":{"Line":8}},{"line":49,"address":[3356238],"length":1,"stats":{"Line":4}},{"line":53,"address":[4179433,4179246,4177264],"length":1,"stats":{"Line":4}},{"line":54,"address":[4177448],"length":1,"stats":{"Line":4}},{"line":55,"address":[3356658,3356727],"length":1,"stats":{"Line":8}},{"line":56,"address":[4125447],"length":1,"stats":{"Line":2}},{"line":57,"address":[4177640],"length":1,"stats":{"Line":2}},{"line":63,"address":[4123681],"length":1,"stats":{"Line":2}},{"line":64,"address":[4123693],"length":1,"stats":{"Line":2}},{"line":66,"address":[4123782,4123704,4124095],"length":1,"stats":{"Line":6}},{"line":67,"address":[4125380,4124132],"length":1,"stats":{"Line":4}},{"line":68,"address":[3358486,3358441],"length":1,"stats":{"Line":4}},{"line":69,"address":[4179301],"length":1,"stats":{"Line":2}},{"line":70,"address":[4125426],"length":1,"stats":{"Line":2}},{"line":75,"address":[4124166,4124015],"length":1,"stats":{"Line":4}},{"line":76,"address":[4178058],"length":1,"stats":{"Line":2}},{"line":82,"address":[4124326],"length":1,"stats":{"Line":2}},{"line":83,"address":[4178225],"length":1,"stats":{"Line":2}},{"line":84,"address":[3357433,3357504],"length":1,"stats":{"Line":0}},{"line":86,"address":[3357622,3357516,3357412],"length":1,"stats":{"Line":6}},{"line":87,"address":[4125109,4125254,4124591,4124961,4124841],"length":1,"stats":{"Line":8}},{"line":89,"address":[4124624,4124546],"length":1,"stats":{"Line":4}},{"line":90,"address":[3357840],"length":1,"stats":{"Line":0}},{"line":93,"address":[3357741],"length":1,"stats":{"Line":2}},{"line":94,"address":[3357693],"length":1,"stats":{"Line":2}},{"line":100,"address":[4125568,4126306],"length":1,"stats":{"Line":2}},{"line":101,"address":[3358692],"length":1,"stats":{"Line":2}},{"line":102,"address":[4125663],"length":1,"stats":{"Line":2}},{"line":104,"address":[4125674,4125864,4125761],"length":1,"stats":{"Line":6}},{"line":105,"address":[3359178,3358945],"length":1,"stats":{"Line":4}},{"line":106,"address":[4126154],"length":1,"stats":{"Line":2}},{"line":108,"address":[3359244,3359349],"length":1,"stats":{"Line":8}},{"line":109,"address":[4126275],"length":1,"stats":{"Line":2}},{"line":115,"address":[4125972,4125917,4125853],"length":1,"stats":{"Line":4}},{"line":116,"address":[4125933,4125979],"length":1,"stats":{"Line":4}},{"line":118,"address":[4125960],"length":1,"stats":{"Line":0}}],"covered":38,"coverable":42},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","utils.rs"],"content":"/// Calculate cosine distance between two vectors (range 0.0 to 2.0)\n/// Higher values mean less similarity.\npub fn cosine_distance(a: \u0026[f32], b: \u0026[f32]) -\u003e f32 {\n    let dot_product: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();\n    let norm_a: f32 = a.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n    let norm_b: f32 = b.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n\n    // Handle zero vectors to avoid division by zero and return max distance\n    if norm_a == 0.0 || norm_b == 0.0 {\n        return 2.0; // Max distance for cosine similarity interpretation (1.0 - (-1.0))\n    }\n\n    // Calculate cosine similarity\n    let similarity = dot_product / (norm_a * norm_b);\n\n    // Clamp similarity to [-1.0, 1.0] to handle potential floating point inaccuracies\n    let clamped_similarity = similarity.clamp(-1.0, 1.0);\n\n    // Convert similarity to distance: distance = 1.0 - similarity\n    1.0 - clamped_similarity\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_cosine_distance_basic() {\n        let vec1 = vec![1.0, 0.0, 0.0];\n        let vec2 = vec![1.0, 0.0, 0.0];\n        let vec3 = vec![0.0, 1.0, 0.0];\n        let vec4 = vec![-1.0, 0.0, 0.0];\n        let vec5 = vec![0.0, 0.0, 0.0];\n\n        // Use approximate comparison for floating point results\n        assert!((cosine_distance(\u0026vec1, \u0026vec2) - 0.0).abs() \u003c 1e-6);\n        assert!((cosine_distance(\u0026vec1, \u0026vec3) - 1.0).abs() \u003c 1e-6); // Orthogonal\n        assert!((cosine_distance(\u0026vec1, \u0026vec4) - 2.0).abs() \u003c 1e-6); // Opposite\n        assert!((cosine_distance(\u0026vec1, \u0026vec5) - 2.0).abs() \u003c 1e-6); // Zero vector\n        assert!((cosine_distance(\u0026vec5, \u0026vec5) - 2.0).abs() \u003c 1e-6); // Zero vector\n    }\n\n    #[test]\n    fn test_cosine_distance_non_unit() {\n        let vec1 = vec![2.0, 0.0];\n        let vec2 = vec![4.0, 0.0];\n        let vec3 = vec![0.0, 3.0];\n        assert!(cosine_distance(\u0026vec1, \u0026vec2) \u003c 1e-6);\n        assert!((cosine_distance(\u0026vec1, \u0026vec3) - 1.0).abs() \u003c 1e-6);\n    }\n\n    // Remove the near_normalized test as it's covered by non_unit\n    // #[test]\n    // fn test_cosine_distance_near_normalized() { ... }\n\n} ","traces":[{"line":3,"address":[3449424],"length":1,"stats":{"Line":2}},{"line":4,"address":[3582768,3582811],"length":1,"stats":{"Line":6}},{"line":5,"address":[3449597],"length":1,"stats":{"Line":8}},{"line":6,"address":[3582896,3582910],"length":1,"stats":{"Line":12}},{"line":9,"address":[3449712],"length":1,"stats":{"Line":4}},{"line":10,"address":[3449740],"length":1,"stats":{"Line":2}},{"line":14,"address":[3449774],"length":1,"stats":{"Line":4}},{"line":17,"address":[3449791],"length":1,"stats":{"Line":4}},{"line":20,"address":[3449824],"length":1,"stats":{"Line":4}}],"covered":9,"coverable":9}]};
        var previousData = {"files":[{"path":["/","home","adam","repos","vectordb-cli","src","bin","onnx_benchmark.rs"],"content":"use anyhow::Result;\nuse clap::{Parser, ValueEnum};\nuse std::path::PathBuf;\nuse std::time::{Duration, Instant};\nuse vectordb_cli::vectordb::provider::onnx::{\n    OnnxEmbeddingProvider,\n};\nuse vectordb_cli::vectordb::provider::EmbeddingProvider;\nuse std::path::Path;\nuse std::env;\nuse vectordb_cli::vectordb::embedding::EmbeddingModel;\n\n/// Command line arguments\n#[derive(Parser, Debug)]\n#[clap(author, version, about = \"Benchmark for ONNX embedding optimizations\")]\nstruct Args {\n    /// Path to ONNX model file\n    #[clap(long, default_value = \"onnx/all-minilm-l12-v2.onnx\")]\n    model_path: String,\n\n    /// Path to tokenizer directory\n    #[clap(long, default_value = \"onnx/minilm_tokenizer\")]\n    tokenizer_path: String,\n\n    /// Number of warmup iterations\n    #[clap(long, default_value = \"3\")]\n    warmup_iterations: usize,\n\n    /// Number of benchmark iterations\n    #[clap(long, default_value = \"10\")]\n    bench_iterations: usize,\n\n    /// Batch sizes to test\n    #[clap(long, default_value = \"1,4,8,16,32\")]\n    batch_sizes: String,\n\n    /// Provider to benchmark\n    #[clap(long, value_enum, default_value = \"basic\")]\n    provider: ProviderType,\n\n    /// Text file with sample inputs (one per line)\n    #[clap(long, default_value = \"samples.txt\")]\n    samples_file: String,\n\n    /// Whether to pre-warm the session pool\n    #[clap(long, default_value = \"true\")]\n    pre_warm: bool,\n\n    /// Whether to use dynamic batching\n    #[clap(long, default_value = \"false\")]\n    dynamic_batching: bool,\n\n    /// Output results in CSV format\n    #[clap(long, default_value = \"false\")]\n    csv: bool,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, Debug, ValueEnum)]\nenum ProviderType {\n    /// Basic ONNX provider\n    Basic,\n}\n\n/// Create sample texts with varying lengths\nfn create_sample_texts() -\u003e Vec\u003cString\u003e {\n    // Short texts\n    let short_texts = vec![\n        \"This is a short text\".to_string(),\n        \"Another short text example\".to_string(),\n        \"Hello, world!\".to_string(),\n        \"ONNX Runtime is fast\".to_string(),\n    ];\n\n    // Medium texts\n    let medium_texts = vec![\n        \"This is a medium length text that should have more tokens than the shorter examples above. It contains multiple sentences to ensure adequate length.\".to_string(),\n        \"Embedding models like MiniLM are designed to produce fixed-length vector representations of text that capture semantic meaning. These vectors can be used for similarity search.\".to_string(),\n        \"The Rust programming language offers memory safety without a garbage collector, making it suitable for performance-critical applications like embedding generation.\".to_string(),\n    ];\n\n    // Long texts\n    let long_texts = vec![\n        \"This is a longer text that will require more tokens to process. It contains multiple sentences and paragraphs to ensure that batch processing logic can be properly tested. Batch processing is an important optimization when working with ONNX models and transformer-based architectures. By grouping multiple inputs together, we can better utilize the parallel processing capabilities of modern hardware. This should have significantly more tokens than the short and medium examples.\".to_string(),\n        \"The ONNX Runtime provides an optimized inference engine for ONNX models. It includes various optimization capabilities such as operator fusion, memory planning, and parallelization across multiple compute resources. When working with embedding models, efficient batching and tokenization are critical for achieving good performance. The RunTime also supports hardware acceleration through CUDA, DirectML, and other platform-specific acceleration technologies. This longer text will require more tokens and serve as a good test case for batching efficiency.\".to_string(),\n    ];\n\n    // Combine all texts\n    let mut all_texts = Vec::new();\n    all_texts.extend(short_texts);\n    all_texts.extend(medium_texts);\n    all_texts.extend(long_texts);\n\n    // Create repeated sets to have sufficient data\n    let mut result = Vec::new();\n    for _ in 0..5 {\n        result.extend(all_texts.clone());\n    }\n\n    result\n}\n\n/// Load sample texts from a file\nfn load_sample_texts(path: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    match std::fs::read_to_string(path) {\n        Ok(content) =\u003e {\n            let lines: Vec\u003cString\u003e = content\n                .lines()\n                .map(|line| line.trim().to_string())\n                .filter(|line| !line.is_empty())\n                .collect();\n\n            if lines.is_empty() {\n                println!(\"Warning: No samples found in file. Using generated samples.\");\n                Ok(create_sample_texts())\n            } else {\n                println!(\"Loaded {} sample texts from {}\", lines.len(), path);\n                Ok(lines)\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"Warning: Failed to load samples file ({}): {}\", path, e);\n            println!(\"Using generated samples instead.\");\n            Ok(create_sample_texts())\n        }\n    }\n}\n\n/// Run benchmark with the basic ONNX provider\nfn benchmark_basic(\n    model_path: \u0026str,\n    tokenizer_path: \u0026str,\n    samples: \u0026[String],\n    batch_size: usize,\n    iterations: usize,\n) -\u003e Result\u003cVec\u003cDuration\u003e\u003e {\n    // Create the provider\n    let model_path = PathBuf::from(model_path);\n    let tokenizer_path = PathBuf::from(tokenizer_path);\n    let provider = OnnxEmbeddingProvider::new(\u0026model_path, \u0026tokenizer_path)?;\n\n    // Prepare batches\n    let mut results = Vec::with_capacity(iterations);\n    for _ in 0..iterations {\n        // Select a random subset of samples for this iteration\n        let batch_start = fastrand::usize(0..samples.len().saturating_sub(batch_size));\n        let batch_texts: Vec\u003c\u0026str\u003e = samples[batch_start..batch_start + batch_size]\n            .iter()\n            .map(|s| s.as_str())\n            .collect();\n\n        // Time the embedding generation\n        let start = Instant::now();\n        let embeddings = provider.embed_batch(\u0026batch_texts)?;\n        let duration = start.elapsed();\n\n        // Verify the embeddings\n        assert_eq!(embeddings.len(), batch_size);\n\n        results.push(duration);\n    }\n\n    Ok(results)\n}\n\n/// Format a duration as milliseconds with 2 decimal places\nfn format_ms(duration: Duration) -\u003e String {\n    let ms = duration.as_secs_f64() * 1000.0;\n    format!(\"{:.2}\", ms)\n}\n\n/// Calculate statistics for a set of durations\nfn calculate_stats(durations: \u0026[Duration]) -\u003e (Duration, Duration, Duration) {\n    let mut sorted = durations.to_vec();\n    sorted.sort();\n\n    let total = sorted.iter().sum::\u003cDuration\u003e();\n    let mean = total / durations.len() as u32;\n\n    let median = if sorted.is_empty() {\n        Duration::from_secs(0)\n    } else if sorted.len() % 2 == 1 {\n        sorted[sorted.len() / 2]\n    } else {\n        (sorted[sorted.len() / 2 - 1] + sorted[sorted.len() / 2]) / 2\n    };\n\n    (mean, median, total)\n}\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Parse arguments\n    let args = Args::parse();\n\n    // Load sample texts\n    let samples = load_sample_texts(\u0026args.samples_file)?;\n    println!(\"Using {} sample texts for benchmarking\", samples.len());\n\n    // Parse batch sizes\n    let batch_sizes: Vec\u003cusize\u003e = args\n        .batch_sizes\n        .split(',')\n        .map(|s| s.trim().parse::\u003cusize\u003e())\n        .collect::\u003cstd::result::Result\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n    // Print configuration\n    println!(\"\\nBenchmark Configuration:\");\n    println!(\"------------------------\");\n    println!(\n        \"Provider:         {}\",\n        match args.provider {\n            ProviderType::Basic =\u003e \"Basic ONNX\",\n        }\n    );\n    println!(\"Model:            {}\", args.model_path);\n    println!(\"Tokenizer:        {}\", args.tokenizer_path);\n    println!(\"Warmup iterations: {}\", args.warmup_iterations);\n    println!(\"Bench iterations:  {}\", args.bench_iterations);\n    println!(\"Batch sizes:       {}\", args.batch_sizes);\n    println!(\"Pre-warm pool:     {}\", args.pre_warm);\n    println!(\"Dynamic batching:  {}\", args.dynamic_batching);\n\n    if args.csv {\n        // CSV header\n        println!(\"\\nprovider,batch_size,mean_ms,median_ms,total_ms,throughput\");\n    } else {\n        println!(\"\\nResults:\");\n        println!(\"--------\");\n    }\n\n    // Run benchmarks for each batch size\n    for batch_size in batch_sizes {\n        if batch_size \u003e samples.len() {\n            println!(\n                \"Warning: Batch size {} exceeds number of samples {}. Skipping.\",\n                batch_size,\n                samples.len()\n            );\n            continue;\n        }\n\n        // Run warmup iterations first\n        println!(\n            \"Running {} warmup iterations with batch size {}...\",\n            args.warmup_iterations, batch_size\n        );\n        let warmup_result = match args.provider {\n            ProviderType::Basic =\u003e benchmark_basic(\n                \u0026args.model_path,\n                \u0026args.tokenizer_path,\n                \u0026samples,\n                batch_size,\n                args.warmup_iterations,\n            ),\n        };\n\n        if warmup_result.is_err() {\n            println!(\"Error during warmup: {:?}\", warmup_result.err());\n            continue;\n        }\n\n        // Run actual benchmark\n        println!(\n            \"Running {} benchmark iterations with batch size {}...\",\n            args.bench_iterations, batch_size\n        );\n        let bench_result = match args.provider {\n            ProviderType::Basic =\u003e benchmark_basic(\n                \u0026args.model_path,\n                \u0026args.tokenizer_path,\n                \u0026samples,\n                batch_size,\n                args.bench_iterations,\n            ),\n        };\n\n        match bench_result {\n            Ok(durations) =\u003e {\n                // Calculate statistics\n                let (mean, median, total) = calculate_stats(\u0026durations);\n                let throughput =\n                    batch_size as f64 * args.bench_iterations as f64 / total.as_secs_f64();\n\n                // Output results\n                if args.csv {\n                    let provider_name = match args.provider {\n                        ProviderType::Basic =\u003e \"basic\",\n                    };\n                    println!(\n                        \"{},{},{},{},{},{:.2}\",\n                        provider_name,\n                        batch_size,\n                        format_ms(mean),\n                        format_ms(median),\n                        format_ms(total),\n                        throughput\n                    );\n                } else {\n                    println!(\"Batch size {}:\", batch_size);\n                    println!(\"  Mean time:   {} ms\", format_ms(mean));\n                    println!(\"  Median time: {} ms\", format_ms(median));\n                    println!(\"  Total time:  {} ms\", format_ms(total));\n                    println!(\"  Throughput:  {:.2} samples/sec\", throughput);\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"Error benchmarking batch size {}: {}\", batch_size, e);\n            }\n        }\n    }\n\n    // --- Create model to get dimension ---\n    let model_path_str = env::var(\"VECTORDB_ONNX_MODEL\")\n        .unwrap_or_else(|_| \"onnx/all-minilm-l12-v2.onnx\".to_string());\n    let tokenizer_path_str = env::var(\"VECTORDB_ONNX_TOKENIZER\")\n        .unwrap_or_else(|_| \"onnx\".to_string());\n\n    let model_path = Path::new(\u0026model_path_str);\n    let tokenizer_path = Path::new(\u0026tokenizer_path_str);\n\n    println!(\n        \"Starting ONNX benchmark with model: {} and tokenizer: {}\",\n        model_path.display(),\n        tokenizer_path.display()\n    );\n\n    let model = EmbeddingModel::new_onnx(model_path, tokenizer_path)?;\n    let embedding_dim = model.dim();\n    println!(\"Detected Embedding Dimension: {}\", embedding_dim);\n\n    Ok(())\n}\n","traces":[{"line":65,"address":[2705744,2707689,2707752],"length":1,"stats":{"Line":0}},{"line":67,"address":[2707781,2705893,2705761,2706026,2705834,2705958,2706247],"length":1,"stats":{"Line":0}},{"line":68,"address":[2705805],"length":1,"stats":{"Line":0}},{"line":69,"address":[2705866],"length":1,"stats":{"Line":0}},{"line":70,"address":[2705931],"length":1,"stats":{"Line":0}},{"line":71,"address":[2705999],"length":1,"stats":{"Line":0}},{"line":75,"address":[2706357,2707747,2706484,2706230,2706416,2706314],"length":1,"stats":{"Line":0}},{"line":76,"address":[2706322],"length":1,"stats":{"Line":0}},{"line":77,"address":[2706389],"length":1,"stats":{"Line":0}},{"line":78,"address":[2706457],"length":1,"stats":{"Line":0}},{"line":82,"address":[2706801,2706758,2707720,2706700,2706860],"length":1,"stats":{"Line":0}},{"line":83,"address":[2706766],"length":1,"stats":{"Line":0}},{"line":84,"address":[2706833],"length":1,"stats":{"Line":0}},{"line":88,"address":[2707042],"length":1,"stats":{"Line":0}},{"line":89,"address":[2707102],"length":1,"stats":{"Line":0}},{"line":90,"address":[2707211],"length":1,"stats":{"Line":0}},{"line":91,"address":[2707285],"length":1,"stats":{"Line":0}},{"line":94,"address":[2707359],"length":1,"stats":{"Line":0}},{"line":95,"address":[2707456,2707378],"length":1,"stats":{"Line":0}},{"line":96,"address":[2707650,2707579],"length":1,"stats":{"Line":0}},{"line":99,"address":[2707537],"length":1,"stats":{"Line":0}},{"line":103,"address":[2707792,2708845],"length":1,"stats":{"Line":0}},{"line":104,"address":[2707819],"length":1,"stats":{"Line":0}},{"line":105,"address":[2707880],"length":1,"stats":{"Line":0}},{"line":106,"address":[2707905,2708103],"length":1,"stats":{"Line":0}},{"line":108,"address":[2789525,2789472],"length":1,"stats":{"Line":0}},{"line":109,"address":[2789593,2789568],"length":1,"stats":{"Line":0}},{"line":112,"address":[2708793,2708184,2708249],"length":1,"stats":{"Line":0}},{"line":113,"address":[2708276,2708719],"length":1,"stats":{"Line":0}},{"line":114,"address":[2708746],"length":1,"stats":{"Line":0}},{"line":116,"address":[2708529,2708310,2708255],"length":1,"stats":{"Line":0}},{"line":117,"address":[2708619],"length":1,"stats":{"Line":0}},{"line":120,"address":[2707925],"length":1,"stats":{"Line":0}},{"line":121,"address":[2709018],"length":1,"stats":{"Line":0}},{"line":122,"address":[2709103],"length":1,"stats":{"Line":0}},{"line":123,"address":[2709156],"length":1,"stats":{"Line":0}},{"line":129,"address":[2709232,2711616,2711514],"length":1,"stats":{"Line":0}},{"line":137,"address":[2709375],"length":1,"stats":{"Line":0}},{"line":138,"address":[2709404],"length":1,"stats":{"Line":0}},{"line":139,"address":[2709905,2709567,2709463,2711595],"length":1,"stats":{"Line":0}},{"line":142,"address":[2709875],"length":1,"stats":{"Line":0}},{"line":143,"address":[2710074,2709990],"length":1,"stats":{"Line":0}},{"line":145,"address":[2710378,2710258],"length":1,"stats":{"Line":0}},{"line":146,"address":[2710758,2710409],"length":1,"stats":{"Line":0}},{"line":148,"address":[2789616,2789641],"length":1,"stats":{"Line":0}},{"line":152,"address":[2710934,2710861],"length":1,"stats":{"Line":0}},{"line":153,"address":[2711173,2710949],"length":1,"stats":{"Line":0}},{"line":154,"address":[2711259,2711137],"length":1,"stats":{"Line":0}},{"line":157,"address":[2711295],"length":1,"stats":{"Line":0}},{"line":159,"address":[2711451],"length":1,"stats":{"Line":0}},{"line":162,"address":[2710176],"length":1,"stats":{"Line":0}},{"line":166,"address":[2711632],"length":1,"stats":{"Line":0}},{"line":167,"address":[2711658],"length":1,"stats":{"Line":0}},{"line":168,"address":[2712051,2711787],"length":1,"stats":{"Line":0}},{"line":172,"address":[2713186,2712192],"length":1,"stats":{"Line":0}},{"line":173,"address":[2712255],"length":1,"stats":{"Line":0}},{"line":174,"address":[2712347,2712268],"length":1,"stats":{"Line":0}},{"line":176,"address":[2712362],"length":1,"stats":{"Line":0}},{"line":177,"address":[2712520],"length":1,"stats":{"Line":0}},{"line":179,"address":[2712602],"length":1,"stats":{"Line":0}},{"line":180,"address":[2712656,2713166],"length":1,"stats":{"Line":0}},{"line":181,"address":[2712637,2712675],"length":1,"stats":{"Line":0}},{"line":182,"address":[2712703,2712738],"length":1,"stats":{"Line":0}},{"line":184,"address":[2712723,2712905],"length":1,"stats":{"Line":0}},{"line":187,"address":[2712840],"length":1,"stats":{"Line":0}},{"line":190,"address":[2724754,2717582,2713216],"length":1,"stats":{"Line":0}},{"line":192,"address":[2713238],"length":1,"stats":{"Line":0}},{"line":195,"address":[2713518,2724736,2713362,2713267],"length":1,"stats":{"Line":0}},{"line":196,"address":[2713619,2713737,2713491],"length":1,"stats":{"Line":0}},{"line":199,"address":[2724681,2714096,2713806,2714079],"length":1,"stats":{"Line":0}},{"line":202,"address":[2789664,2789717],"length":1,"stats":{"Line":0}},{"line":206,"address":[2714053,2714170],"length":1,"stats":{"Line":0}},{"line":207,"address":[2714189],"length":1,"stats":{"Line":0}},{"line":208,"address":[2714341],"length":1,"stats":{"Line":0}},{"line":214,"address":[2714520],"length":1,"stats":{"Line":0}},{"line":215,"address":[2714589,2714687],"length":1,"stats":{"Line":0}},{"line":216,"address":[2714854,2714756],"length":1,"stats":{"Line":0}},{"line":217,"address":[2714923,2715021],"length":1,"stats":{"Line":0}},{"line":218,"address":[2715188,2715090],"length":1,"stats":{"Line":0}},{"line":219,"address":[2715257,2715355],"length":1,"stats":{"Line":0}},{"line":220,"address":[2715424,2715522],"length":1,"stats":{"Line":0}},{"line":222,"address":[2715591],"length":1,"stats":{"Line":0}},{"line":224,"address":[2715627,2715789],"length":1,"stats":{"Line":0}},{"line":226,"address":[2715601,2715656],"length":1,"stats":{"Line":0}},{"line":227,"address":[2715675],"length":1,"stats":{"Line":0}},{"line":231,"address":[2715810,2715722,2715969,2716015,2724118],"length":1,"stats":{"Line":0}},{"line":232,"address":[2717699,2716031],"length":1,"stats":{"Line":0}},{"line":233,"address":[2724553],"length":1,"stats":{"Line":0}},{"line":242,"address":[2718034,2717709],"length":1,"stats":{"Line":0}},{"line":248,"address":[2718127],"length":1,"stats":{"Line":0}},{"line":249,"address":[2718182],"length":1,"stats":{"Line":0}},{"line":250,"address":[2718245],"length":1,"stats":{"Line":0}},{"line":252,"address":[2718328],"length":1,"stats":{"Line":0}},{"line":256,"address":[2718389,2718451],"length":1,"stats":{"Line":0}},{"line":257,"address":[2718557,2724259,2724131],"length":1,"stats":{"Line":0}},{"line":262,"address":[2718457,2718733],"length":1,"stats":{"Line":0}},{"line":268,"address":[2718826],"length":1,"stats":{"Line":0}},{"line":269,"address":[2718881],"length":1,"stats":{"Line":0}},{"line":270,"address":[2718938],"length":1,"stats":{"Line":0}},{"line":272,"address":[2719003],"length":1,"stats":{"Line":0}},{"line":276,"address":[2719048],"length":1,"stats":{"Line":0}},{"line":277,"address":[2719083],"length":1,"stats":{"Line":0}},{"line":279,"address":[2719332,2719123],"length":1,"stats":{"Line":0}},{"line":280,"address":[2719447],"length":1,"stats":{"Line":0}},{"line":284,"address":[2719574],"length":1,"stats":{"Line":0}},{"line":286,"address":[2719699],"length":1,"stats":{"Line":0}},{"line":288,"address":[2721525],"length":1,"stats":{"Line":0}},{"line":298,"address":[2719841],"length":1,"stats":{"Line":0}},{"line":299,"address":[2719927,2720046],"length":1,"stats":{"Line":0}},{"line":300,"address":[2720195,2720314],"length":1,"stats":{"Line":0}},{"line":301,"address":[2720588,2720446],"length":1,"stats":{"Line":0}},{"line":302,"address":[2721094,2720830],"length":1,"stats":{"Line":0}},{"line":305,"address":[2719143],"length":1,"stats":{"Line":0}},{"line":306,"address":[2724003],"length":1,"stats":{"Line":0}},{"line":312,"address":[2716061],"length":1,"stats":{"Line":0}},{"line":313,"address":[2789776,2789760],"length":1,"stats":{"Line":0}},{"line":314,"address":[2716197,2716122],"length":1,"stats":{"Line":0}},{"line":315,"address":[2789872,2789888],"length":1,"stats":{"Line":0}},{"line":317,"address":[2716319,2716227],"length":1,"stats":{"Line":0}},{"line":318,"address":[2716357],"length":1,"stats":{"Line":0}},{"line":320,"address":[2716808],"length":1,"stats":{"Line":0}},{"line":326,"address":[2717607,2716925,2717161],"length":1,"stats":{"Line":0}},{"line":327,"address":[2717262,2717134],"length":1,"stats":{"Line":0}},{"line":328,"address":[2717380],"length":1,"stats":{"Line":0}},{"line":330,"address":[2717449],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":125},{"path":["/","home","adam","repos","vectordb-cli","src","cli","commands.rs"],"content":"// use crate::vectordb::embedding::EmbeddingModelType;\nuse crate::vectordb::error::VectorDBError;\n// use crate::vectordb::search::Search; // Removed\nuse crate::vectordb::VectorDB;\n// use crate::vectordb::cache::CacheCheckResult; // Removed\nuse anyhow::{anyhow, Result};\nuse clap::Parser;\nuse log::{debug, error, warn};\nuse num_cpus;\nuse rayon;\nuse std::path::{Path, PathBuf};\nuse std::time::Instant;\n// use crate::vectordb::search::result::SearchResult; // Removed\n// use crate::vectordb::search::{chunking, snippet}; // Removed\n// use std::collections::HashMap; // Removed\nuse std::fs;\n// use std::collections::HashSet; // Removed\n// use crate::vectordb::utils::cosine_distance; // Removed\n// use walkdir::WalkDir; // Removed\n// use chrono::{DateTime, Utc, TimeZone, Local}; // Removed DateTime, TimeZone, Local\nuse chrono::{Utc, Local, TimeZone}; // Add back Local and TimeZone\n\n// Global flag for handling interrupts\npub static mut INTERRUPT_RECEIVED: bool = false;\n\n#[derive(Parser, Debug)]\npub enum Command {\n    /// Index files in one or more directories\n    Index {\n        /// Directories to index (provide one or more paths)\n        #[arg(required = true)]\n        dirs: Vec\u003cString\u003e,\n\n        /// File types to index (e.g. rs,rb,go,js,ts,yaml,md)\n        #[arg(short = 't', long = \"file-types\", value_delimiter = ',')]\n        file_types: Vec\u003cString\u003e,\n\n        /// Number of threads to use for indexing (defaults to available CPUs)\n        #[arg(short = 'j', long = \"threads\")]\n        threads: Option\u003cusize\u003e,\n\n        /// Path to ONNX model file (required if not set via env var)\n        #[arg(long = \"onnx-model\")]\n        onnx_model: Option\u003cString\u003e,\n\n        /// Path to ONNX tokenizer file (required if not set via env var)\n        #[arg(long = \"onnx-tokenizer\")]\n        onnx_tokenizer: Option\u003cString\u003e,\n    },\n\n    /// Search across indexed text chunks using semantic similarity\n    Query {\n        /// Search query string\n        #[arg(required = true)]\n        query: String,\n\n        /// Maximum number of relevant chunks to return (default: 20)\n        #[arg(short = 'l', long = \"limit\")]\n        max_results: Option\u003cusize\u003e,\n\n        /// Only show chunks from files with these extensions (e.g. rs,md,py)\n        #[arg(short = 't', long = \"file-types\", value_delimiter = ',')]\n        file_types: Option\u003cVec\u003cString\u003e\u003e,\n    },\n\n    /// Show database statistics\n    Stats,\n\n    /// Clear the database\n    Clear {},\n\n    /// List the unique top-level directories found in the index\n    List,\n}\n\npub fn execute_command(command: Command, mut db: VectorDB) -\u003e Result\u003c()\u003e {\n    match command {\n        Command::Index {\n            dirs,\n            file_types,\n            threads,\n            onnx_model,\n            onnx_tokenizer,\n        } =\u003e {\n            debug!(\"Executing Index command for directories: {:?}\", dirs);\n            println!(\"Indexing files in {:?}...\", dirs);\n\n            // Try to set paths from args or env vars\n            let model_path_opt = onnx_model.or_else(|| std::env::var(\"VECTORDB_ONNX_MODEL\").ok());\n            let tokenizer_path_opt = onnx_tokenizer.or_else(|| std::env::var(\"VECTORDB_ONNX_TOKENIZER\").ok());\n\n            if let (Some(mp), Some(tp)) = (\u0026model_path_opt, \u0026tokenizer_path_opt) {\n                match db.set_onnx_paths(Some(PathBuf::from(mp)), Some(PathBuf::from(tp))) {\n                    Ok(_) =\u003e {\n                        // Setting paths implies using ONNX, no need to set type explicitly\n                        debug!(\"Successfully set ONNX model paths.\");\n                        println!(\"Using ONNX embedding model:\");\n                        println!(\"  - Model: {}\", mp);\n                        println!(\"  - Tokenizer: {}\", tp);\n                    }\n                    Err(e) =\u003e {\n                        // Error during path setting likely means validation failed (e.g., file not found)\n                        error!(\"Failed to validate ONNX model/tokenizer paths: {}\", e);\n                        eprintln!(\"Error configuring ONNX model: {}\", e);\n                        eprintln!(\"Please ensure the specified ONNX model and tokenizer files exist and are valid.\");\n                        return Err(e.into()); // Return error\n                    }\n                }\n            } else {\n                // Paths not provided via args or env vars\n                error!(\"ONNX model and tokenizer paths are required but not set.\");\n                eprintln!(\"Error: ONNX model and tokenizer paths must be provided either via --onnx-model/--onnx-tokenizer arguments or VECTORDB_ONNX_MODEL/VECTORDB_ONNX_TOKENIZER environment variables.\");\n                // Return an appropriate error\n                return Err(VectorDBError::EmbeddingError(\"ONNX paths not configured\".to_string()).into());\n            }\n            \n            // Setup thread pool\n            let num_threads = threads.unwrap_or_else(num_cpus::get);\n            rayon::ThreadPoolBuilder::new()\n                .num_threads(num_threads)\n                .build_global()\n                .map_err(|e| anyhow::anyhow!(\"Failed to build thread pool: {}\", e))?;\n\n            let start = Instant::now();\n            let mut overall_result = Ok(()); // Track overall success\n\n            // Determine file types to use based on input flags\n            let file_types_to_use = if file_types.is_empty() {\n                let supported = VectorDB::get_supported_file_types();\n                println!(\n                    \"No file types specified, using all supported types: {}\",\n                    supported.join(\", \")\n                );\n                supported\n            } else {\n                println!(\"Indexing file types: {}\", file_types.join(\", \"));\n                file_types\n            };\n\n            // Loop through each directory provided\n            for dir_path_str in dirs {\n                 // Canonicalize the input path string\n                 let canonical_dir = match fs::canonicalize(\u0026dir_path_str) {\n                     Ok(path) =\u003e path,\n                     Err(e) =\u003e {\n                         error!(\"Failed to find or canonicalize directory '{}': {}\", dir_path_str, e);\n                         eprintln!(\"Error: Invalid directory '{}': {}\", dir_path_str, e);\n                         if overall_result.is_ok() {\n                             overall_result = Err(anyhow!(\"Invalid directory: {}\", dir_path_str));\n                         }\n                         continue; // Skip to the next directory\n                     }\n                 };\n                 let canonical_dir_str = canonical_dir.to_string_lossy().to_string();\n\n                 println!(\"Starting indexing for: {}\", canonical_dir_str);\n                 debug!(\n                    \"Starting directory indexing: {}, file types: {:?}\",\n                    canonical_dir_str,\n                    \u0026file_types_to_use\n                 );\n                // Index the current canonical directory\n                match db.index_directory(\u0026canonical_dir_str, \u0026file_types_to_use) {\n                    Ok(_) =\u003e {\n                        if unsafe { INTERRUPT_RECEIVED } {\n                            debug!(\"Indexing interrupted for {}, data saved safely\", canonical_dir_str);\n                            println!(\"Indexing interrupted for {}, data saved safely.\", canonical_dir_str);\n                            // Set overall result to error if interrupted\n                            overall_result = Err(anyhow!(\"Indexing interrupted\"));\n                            break; // Stop processing more directories if interrupted\n                        } else {\n                            debug!(\n                                \"Indexing for {} completed successfully\",\n                                canonical_dir_str\n                            );\n                            println!(\"Finished indexing for: {}\", canonical_dir_str);\n                            // Get current UTC timestamp and update\n                            let now_ts = Utc::now().timestamp() as u64;\n                            db.update_indexed_root_timestamp(canonical_dir_str, now_ts); \n                        }\n                    }\n                    Err(e) =\u003e {\n                        if unsafe { INTERRUPT_RECEIVED } {\n                            debug!(\"Indexing interrupted for {}, data saved safely\", canonical_dir_str);\n                            println!(\"Indexing interrupted for {}, data saved safely.\", canonical_dir_str);\n                             overall_result = Err(anyhow!(\"Indexing interrupted\"));\n                            break; // Stop processing more directories\n                        } else {\n                            error!(\"Indexing failed for {}: {}\", canonical_dir_str, e);\n                            eprintln!(\"Error indexing {}: {}\", canonical_dir_str, e);\n                            // Store the first error encountered, but continue if possible\n                            if overall_result.is_ok() {\n                                overall_result = Err(e.into());\n                            }\n                            // Do not break here, allow indexing other directories if requested\n                        }\n                    }\n                }\n            }\n\n            // Save db once after all directories are processed (save includes HNSW rebuild)\n             if overall_result.is_ok() {\n                  if let Err(e) = db.save() {\n                      error!(\"Failed to save database after indexing: {}\", e);\n                      overall_result = Err(e.into());\n                  }\n              }\n            \n            // Final summary message based on overall result\n            let duration = start.elapsed();\n            if overall_result.is_ok() {\n                debug!(\n                    \"All indexing tasks completed successfully in {:.2} seconds\",\n                    duration.as_secs_f32()\n                );\n                println!(\n                    \"\\nTotal indexing time: {:.2} seconds!\",\n                    duration.as_secs_f32()\n                );\n            } else if unsafe { INTERRUPT_RECEIVED } {\n                // Message already printed during the loop for interruption\n                println!(\"\\nTotal time before interruption: {:.2} seconds.\", duration.as_secs_f32());\n            } else {\n                // Report that some errors occurred\n                eprintln!(\n                    \"\\nIndexing completed with errors in {:.2} seconds. Check logs for details.\",\n                    duration.as_secs_f32()\n                );\n            }\n\n            return overall_result; // Return the final result (Ok or the first error)\n        }\n        Command::Query {\n            query,\n            max_results,\n            file_types,\n        } =\u003e {\n            debug!(\"Executing Query command with query: '{}'\", query);\n            let start_time = Instant::now();\n\n            // --- Define QueryResultChunk struct ---\n            #[derive(Debug)] // Added Debug derive for easier printing/logging\n            struct QueryResultChunk {\n                file_path: String,\n                start_line: usize,\n                end_line: usize,\n                text: String,\n                score: f32,\n            }\n\n            // Get search limit\n            let limit = max_results.unwrap_or(20);\n\n            // --- New Chunk-Based Query Logic ---\n\n            // 1. Create Embedding Model\n            let model = match db.create_embedding_model() {\n                Ok(m) =\u003e m,\n                Err(e) =\u003e {\n                    error!(\"Failed to create embedding model for query: {}\", e);\n                    eprintln!(\"Error initializing embedding model: {}. Have you indexed any data?\", e);\n                    return Err(e.into());\n                }\n            };\n\n            // 2. Generate Query Embedding\n            let query_embedding = match model.embed(\u0026query) {\n                Ok(emb) =\u003e emb,\n                Err(e) =\u003e {\n                    error!(\"Failed to generate embedding for query '{}': {}\", query, e);\n                    eprintln!(\"Error generating query embedding: {}\", e);\n                    return Err(e.into());\n                }\n            };\n            debug!(\"Query embedding generated (dim={})\", query_embedding.len());\n\n            // 3. Access HNSW Index\n            let hnsw_index = match db.hnsw_index() {\n                Some(index) =\u003e index,\n                None =\u003e {\n                    warn!(\"HNSW index is not available. No search results can be returned.\");\n                    eprintln!(\"Search index is not built. Please run the 'index' command first.\");\n                    return Ok(()); // Or return an error?\n                }\n            };\n\n            // Verify index dimension matches query embedding dimension\n            if hnsw_index.get_config().dimension != query_embedding.len() {\n                error!(\n                    \"Query embedding dimension ({}) does not match HNSW index dimension ({}).\",\n                    query_embedding.len(),\n                    hnsw_index.get_config().dimension\n                );\n                eprintln!(\n                    \"Error: Query embedding dimension ({}) does not match the index dimension ({}). \\\\\n                     The index might be corrupted or built with a different model. Please re-index.\",\n                    query_embedding.len(),\n                    hnsw_index.get_config().dimension\n                );\n                return Err(anyhow!(\"Index dimension mismatch\"));\n            }\n\n            // 4. Perform HNSW Search\n            // TODO: Make ef_search configurable?\n            let ef_search = 100; // Example value\n            debug!(\"Performing HNSW search with k={}, ef_search={}\", limit, ef_search);\n            let search_results = hnsw_index.search_parallel(\u0026query_embedding, limit, ef_search)?;\n            debug!(\"HNSW search returned {} results\", search_results.len());\n\n            // 5. Process HNSW Results\n            let mut chunk_results: Vec\u003cQueryResultChunk\u003e = Vec::with_capacity(search_results.len());\n            for (node_id, distance) in search_results {\n                if let Some(chunk_data) = db.indexed_chunks.get(node_id) {\n                    let similarity = 1.0 - distance;\n                    // Basic filtering (optional, can add more like file_type filtering here if needed)\n                    if similarity \u003c 0.0 { continue; } // Skip results with negative similarity (highly dissimilar)\n\n                    // Filter by file type if specified\n                    if let Some(ref allowed_types) = file_types {\n                        if !allowed_types.is_empty() {\n                             if let Some(extension) = Path::new(\u0026chunk_data.file_path).extension().and_then(|ext| ext.to_str()) {\n                                 if !allowed_types.iter().any(|ft| ft.eq_ignore_ascii_case(extension)) {\n                                     debug!(\"Skipping chunk from file {} due to file type filter\", chunk_data.file_path);\n                                     continue; // Skip chunk if file type doesn't match\n                                 }\n                             } else {\n                                 continue; // Skip files with no extension if filtering\n                             }\n                        }\n                    }\n\n                    chunk_results.push(QueryResultChunk {\n                        file_path: chunk_data.file_path.clone(),\n                        start_line: chunk_data.start_line,\n                        end_line: chunk_data.end_line,\n                        text: chunk_data.text.clone(),\n                        score: similarity,\n                    });\n                } else {\n                    error!(\"Invalid node ID {} returned from HNSW search, data mismatch!\", node_id);\n                    // This indicates a potential corruption or bug\n                }\n            }\n\n            // 6. Display Results\n            let elapsed = start_time.elapsed();\n            if chunk_results.is_empty() {\n                println!(\"No relevant chunks found for query '{}'\", query);\n            } else {\n                println!(\"Found {} relevant chunks ({:.2} seconds):\", chunk_results.len(), elapsed.as_secs_f32());\n                println!(\"---\");\n                for (i, result) in chunk_results.iter().enumerate() {\n                    // Use canonicalize to try and resolve symlinks/relative paths\n                    let display_path = match fs::canonicalize(\u0026result.file_path) {\n                         Ok(p) =\u003e p.to_string_lossy().into_owned(),\n                         Err(_) =\u003e result.file_path.clone(), // Fallback to original path if canonicalization fails\n                    };\n                    println!(\n                        \"{}. {} (Lines {}-{}) (score: {:.4})\",\n                        i + 1,\n                        display_path,\n                        result.start_line,\n                        result.end_line,\n                        result.score\n                    );\n                    // Indent the chunk text slightly\n                    for line in result.text.lines() {\n                        println!(\"  {}\", line);\n                    }\n                    println!(\"---\");\n                }\n            }\n            debug!(\"Query processing took {:.4} seconds\", elapsed.as_secs_f32());\n\n            Ok(())\n        }\n        Command::Stats =\u003e {\n            let stats = db.stats();\n            println!(\"Database Statistics:\");\n            println!(\"  DB Path: {}\", stats.db_path);\n            println!(\"  Model Type: {}\", stats.embedding_model_type);\n            println!(\"  Embedding Dimension: {}\", stats.embedding_dimension);\n            println!(\"  Unique Files Indexed: {}\", stats.unique_files);\n            println!(\"  Total Chunks Indexed: {}\", stats.indexed_chunks);\n            println!(\"  Cached Files (hashes): {}\", stats.cached_files);\n            if let Some(hnsw_stats) = stats.hnsw_stats {\n                println!(\"  HNSW Index:\");\n                println!(\"    Total Nodes: {}\", hnsw_stats.total_nodes);\n                println!(\"    Layers: {}\", hnsw_stats.layers);\n                // Add more HNSW stats if desired\n            } else {\n                println!(\"  HNSW Index: Not built\");\n            }\n            Ok(())\n        }\n        Command::Clear {} =\u003e {\n            println!(\"Clearing database...\");\n            db.clear()?;\n            println!(\"Database cleared successfully.\");\n            Ok(())\n        }\n        Command::List =\u003e {\n            debug!(\"Executing List command\");\n            println!(\"Retrieving indexed directories...\");\n\n            let indexed_roots_map = db.indexed_roots();\n\n            if indexed_roots_map.is_empty() {\n                println!(\"  No directories have been explicitly indexed yet.\");\n                return Ok(());\n            }\n\n            // Convert HashMap to Vec for sorting\n            let mut sorted_roots: Vec\u003c(String, u64)\u003e = indexed_roots_map.iter()\n                                                    .map(|(k, v)| (k.clone(), *v))\n                                                    .collect();\n            // Sort by path (the String key)\n            sorted_roots.sort_by(|a, b| a.0.cmp(\u0026b.0));\n\n            println!(\"Indexed Directories (Last Indexed):\");\n\n            // Print path and formatted timestamp\n            for (root_path_str, timestamp) in sorted_roots {\n                 // Convert UNIX timestamp to DateTime\u003cLocal\u003e\n                let dt = match Utc.timestamp_opt(timestamp as i64, 0) {\n                    chrono::LocalResult::Single(dt) =\u003e dt.with_timezone(\u0026Local),\n                    _ =\u003e { // Handle potential invalid timestamp\n                         warn!(\"Invalid timestamp ({}) found for directory {}\", timestamp, root_path_str);\n                         // Print placeholder or skip?\n                         println!(\"  - {} (Invalid Timestamp)\", root_path_str);\n                         continue;\n                    }\n                 };\n                 // Format the timestamp\n                 let formatted_time = dt.format(\"%Y-%m-%d %H:%M:%S\").to_string();\n                 println!(\"  - {} ({})\", root_path_str, formatted_time);\n            }\n            Ok(())\n        }\n    }\n}\n","traces":[{"line":76,"address":[3986993,3983200,4018909],"length":1,"stats":{"Line":0}},{"line":77,"address":[4093267],"length":1,"stats":{"Line":0}},{"line":78,"address":[3792987],"length":1,"stats":{"Line":0}},{"line":85,"address":[3983643,3984327,3983990,3984159],"length":1,"stats":{"Line":0}},{"line":86,"address":[3984506],"length":1,"stats":{"Line":0}},{"line":89,"address":[3793947],"length":1,"stats":{"Line":0}},{"line":90,"address":[3618157,3618144],"length":1,"stats":{"Line":0}},{"line":92,"address":[3794117,3794273],"length":1,"stats":{"Line":0}},{"line":93,"address":[4094980,4094913,4108759],"length":1,"stats":{"Line":0}},{"line":96,"address":[3794742,3794825,3794586],"length":1,"stats":{"Line":0}},{"line":97,"address":[3795038,3794748],"length":1,"stats":{"Line":0}},{"line":98,"address":[3985815],"length":1,"stats":{"Line":0}},{"line":99,"address":[3795346],"length":1,"stats":{"Line":0}},{"line":101,"address":[4095239],"length":1,"stats":{"Line":0}},{"line":103,"address":[3985335,3998486,3998149,3998318],"length":1,"stats":{"Line":0}},{"line":104,"address":[4108512],"length":1,"stats":{"Line":0}},{"line":105,"address":[3998734],"length":1,"stats":{"Line":0}},{"line":106,"address":[4108626],"length":1,"stats":{"Line":0}},{"line":111,"address":[3998949,3984861,3999032],"length":1,"stats":{"Line":0}},{"line":112,"address":[3808476,3808186],"length":1,"stats":{"Line":0}},{"line":114,"address":[4109103],"length":1,"stats":{"Line":0}},{"line":118,"address":[3795431],"length":1,"stats":{"Line":0}},{"line":119,"address":[3795699,3807327,3795469],"length":1,"stats":{"Line":0}},{"line":122,"address":[3618328,3618208,3618463],"length":1,"stats":{"Line":0}},{"line":124,"address":[3795739,3795657],"length":1,"stats":{"Line":0}},{"line":125,"address":[3986418],"length":1,"stats":{"Line":0}},{"line":128,"address":[3987421,3986438,3986512],"length":1,"stats":{"Line":0}},{"line":129,"address":[3795897],"length":1,"stats":{"Line":0}},{"line":130,"address":[3987241],"length":1,"stats":{"Line":0}},{"line":134,"address":[4097313],"length":1,"stats":{"Line":0}},{"line":136,"address":[4096462,4096531,4096675],"length":1,"stats":{"Line":0}},{"line":137,"address":[3986867],"length":1,"stats":{"Line":0}},{"line":141,"address":[3796937,3796255,3796994,3796802],"length":1,"stats":{"Line":0}},{"line":143,"address":[4097650,4097701],"length":1,"stats":{"Line":0}},{"line":144,"address":[3797128],"length":1,"stats":{"Line":0}},{"line":145,"address":[3987895],"length":1,"stats":{"Line":0}},{"line":146,"address":[4106793,4097847,4106624,4107071],"length":1,"stats":{"Line":0}},{"line":147,"address":[3806768],"length":1,"stats":{"Line":0}},{"line":148,"address":[3806861,3807274],"length":1,"stats":{"Line":0}},{"line":149,"address":[4107749,4107628],"length":1,"stats":{"Line":0}},{"line":154,"address":[3797200,3797355],"length":1,"stats":{"Line":0}},{"line":156,"address":[3797607],"length":1,"stats":{"Line":0}},{"line":157,"address":[4098718,4098284,4098424],"length":1,"stats":{"Line":0}},{"line":163,"address":[3989009,3988414],"length":1,"stats":{"Line":0}},{"line":165,"address":[3798453],"length":1,"stats":{"Line":0}},{"line":166,"address":[4100172,4100340,4099169,4100003],"length":1,"stats":{"Line":0}},{"line":167,"address":[3990597],"length":1,"stats":{"Line":0}},{"line":169,"address":[3799980],"length":1,"stats":{"Line":0}},{"line":172,"address":[3989508,3989676,3989339,3989198],"length":1,"stats":{"Line":0}},{"line":176,"address":[4099781],"length":1,"stats":{"Line":0}},{"line":178,"address":[4099850],"length":1,"stats":{"Line":0}},{"line":179,"address":[3799312],"length":1,"stats":{"Line":0}},{"line":182,"address":[4099072],"length":1,"stats":{"Line":0}},{"line":183,"address":[3798498],"length":1,"stats":{"Line":0}},{"line":184,"address":[3992439,3990923,3992270,3992607],"length":1,"stats":{"Line":0}},{"line":185,"address":[3992786],"length":1,"stats":{"Line":0}},{"line":186,"address":[4102757],"length":1,"stats":{"Line":0}},{"line":189,"address":[4101384,4100796,4100937,4101106],"length":1,"stats":{"Line":0}},{"line":190,"address":[3991771],"length":1,"stats":{"Line":0}},{"line":192,"address":[4102020,4101782],"length":1,"stats":{"Line":0}},{"line":193,"address":[4101828],"length":1,"stats":{"Line":0}},{"line":202,"address":[3803378,3802420],"length":1,"stats":{"Line":0}},{"line":203,"address":[3994067,3993210],"length":1,"stats":{"Line":0}},{"line":204,"address":[3993602,3993770,3993327,3993455],"length":1,"stats":{"Line":0}},{"line":205,"address":[3993461,3993957],"length":1,"stats":{"Line":0}},{"line":210,"address":[3994151,3993165],"length":1,"stats":{"Line":0}},{"line":211,"address":[3803436],"length":1,"stats":{"Line":0}},{"line":212,"address":[4105380],"length":1,"stats":{"Line":0}},{"line":216,"address":[4106130,4106394],"length":1,"stats":{"Line":0}},{"line":220,"address":[4104071],"length":1,"stats":{"Line":0}},{"line":222,"address":[3804245,3803554,3804509,3804126],"length":1,"stats":{"Line":0}},{"line":225,"address":[3994327,3994275],"length":1,"stats":{"Line":0}},{"line":231,"address":[4104679],"length":1,"stats":{"Line":0}},{"line":233,"address":[3793075],"length":1,"stats":{"Line":0}},{"line":238,"address":[4109677,4109845,4109594,4093771],"length":1,"stats":{"Line":0}},{"line":239,"address":[3809447,3808992],"length":1,"stats":{"Line":0}},{"line":252,"address":[4110070],"length":1,"stats":{"Line":0}},{"line":257,"address":[4000288],"length":1,"stats":{"Line":0}},{"line":258,"address":[4000346],"length":1,"stats":{"Line":0}},{"line":259,"address":[4110334],"length":1,"stats":{"Line":0}},{"line":260,"address":[3822534,3809782,3822703,3822865],"length":1,"stats":{"Line":0}},{"line":261,"address":[3823038],"length":1,"stats":{"Line":0}},{"line":262,"address":[3823107],"length":1,"stats":{"Line":0}},{"line":267,"address":[4000482,4000672],"length":1,"stats":{"Line":0}},{"line":268,"address":[4000725],"length":1,"stats":{"Line":0}},{"line":269,"address":[4110655],"length":1,"stats":{"Line":0}},{"line":270,"address":[4122397,4122228,4122675,4110711],"length":1,"stats":{"Line":0}},{"line":271,"address":[4013213],"length":1,"stats":{"Line":0}},{"line":272,"address":[3822331],"length":1,"stats":{"Line":0}},{"line":275,"address":[4000992,4001287,4001076,4000789],"length":1,"stats":{"Line":0}},{"line":278,"address":[3810676,3810216],"length":1,"stats":{"Line":0}},{"line":279,"address":[4001556],"length":1,"stats":{"Line":0}},{"line":281,"address":[4001511,4001609,4001692],"length":1,"stats":{"Line":0}},{"line":282,"address":[4001905,4001615],"length":1,"stats":{"Line":0}},{"line":283,"address":[4001924],"length":1,"stats":{"Line":0}},{"line":288,"address":[4111398,4111764],"length":1,"stats":{"Line":0}},{"line":289,"address":[4121405],"length":1,"stats":{"Line":0}},{"line":294,"address":[3821117,3820508],"length":1,"stats":{"Line":0}},{"line":300,"address":[4122061],"length":1,"stats":{"Line":0}},{"line":305,"address":[3811216],"length":1,"stats":{"Line":0}},{"line":306,"address":[4002226,4002134,4002504,4002034],"length":1,"stats":{"Line":0}},{"line":307,"address":[3811342,3811913,3820466,3812119],"length":1,"stats":{"Line":0}},{"line":308,"address":[3812074,3812495,3812288,3812208],"length":1,"stats":{"Line":0}},{"line":311,"address":[4003036,4003512],"length":1,"stats":{"Line":0}},{"line":312,"address":[3812704,3812807,3812934,3812968],"length":1,"stats":{"Line":0}},{"line":313,"address":[3818641,3813011],"length":1,"stats":{"Line":0}},{"line":314,"address":[4009657],"length":1,"stats":{"Line":0}},{"line":316,"address":[4009687],"length":1,"stats":{"Line":0}},{"line":319,"address":[3818834],"length":1,"stats":{"Line":0}},{"line":320,"address":[3818940,3818885],"length":1,"stats":{"Line":0}},{"line":321,"address":[3092190,3092176],"length":1,"stats":{"Line":0}},{"line":322,"address":[3618576,3618608],"length":1,"stats":{"Line":0}},{"line":323,"address":[3819341,3819450,3819602],"length":1,"stats":{"Line":0}},{"line":332,"address":[4010828],"length":1,"stats":{"Line":0}},{"line":333,"address":[4009826],"length":1,"stats":{"Line":0}},{"line":334,"address":[4120397],"length":1,"stats":{"Line":0}},{"line":335,"address":[4010724],"length":1,"stats":{"Line":0}},{"line":336,"address":[3819813],"length":1,"stats":{"Line":0}},{"line":340,"address":[4011188,4011020,4009701,4010963],"length":1,"stats":{"Line":0}},{"line":346,"address":[4113645],"length":1,"stats":{"Line":0}},{"line":347,"address":[4003959],"length":1,"stats":{"Line":0}},{"line":348,"address":[3817630],"length":1,"stats":{"Line":0}},{"line":350,"address":[4004934,4003998,4004418,4004148,4004702,4004274],"length":1,"stats":{"Line":0}},{"line":351,"address":[4005068],"length":1,"stats":{"Line":0}},{"line":352,"address":[4115167,4114863],"length":1,"stats":{"Line":0}},{"line":354,"address":[4115223],"length":1,"stats":{"Line":0}},{"line":355,"address":[4115358,4115265],"length":1,"stats":{"Line":0}},{"line":356,"address":[4005618,4005861],"length":1,"stats":{"Line":0}},{"line":358,"address":[4005965,4005871,4006085],"length":1,"stats":{"Line":0}},{"line":367,"address":[4008019,4008251],"length":1,"stats":{"Line":0}},{"line":368,"address":[4008436],"length":1,"stats":{"Line":0}},{"line":370,"address":[3817324,3817497],"length":1,"stats":{"Line":0}},{"line":373,"address":[4008911,4008701,4009175,4005397,4008613],"length":1,"stats":{"Line":0}},{"line":375,"address":[4008619],"length":1,"stats":{"Line":0}},{"line":378,"address":[4123864,4093835],"length":1,"stats":{"Line":0}},{"line":379,"address":[4123872,4123942],"length":1,"stats":{"Line":0}},{"line":380,"address":[4124071],"length":1,"stats":{"Line":0}},{"line":381,"address":[3823630,3823532],"length":1,"stats":{"Line":0}},{"line":382,"address":[4014666,4014764],"length":1,"stats":{"Line":0}},{"line":383,"address":[3823866,3823964],"length":1,"stats":{"Line":0}},{"line":384,"address":[4124641,4124739],"length":1,"stats":{"Line":0}},{"line":385,"address":[4015167,4015265],"length":1,"stats":{"Line":0}},{"line":386,"address":[3824367],"length":1,"stats":{"Line":0}},{"line":387,"address":[4125066,4125161],"length":1,"stats":{"Line":0}},{"line":388,"address":[3824670,3824572],"length":1,"stats":{"Line":0}},{"line":389,"address":[4015808,4015710],"length":1,"stats":{"Line":0}},{"line":392,"address":[4125560,4125092],"length":1,"stats":{"Line":0}},{"line":394,"address":[4125529],"length":1,"stats":{"Line":0}},{"line":397,"address":[3793237,3825211],"length":1,"stats":{"Line":0}},{"line":398,"address":[4125854,4126052,4125936],"length":1,"stats":{"Line":0}},{"line":399,"address":[4016297,4016402],"length":1,"stats":{"Line":0}},{"line":400,"address":[3825422],"length":1,"stats":{"Line":0}},{"line":403,"address":[3825541,3825464,3793266],"length":1,"stats":{"Line":0}},{"line":404,"address":[4016469,4016738],"length":1,"stats":{"Line":0}},{"line":406,"address":[4126374],"length":1,"stats":{"Line":0}},{"line":408,"address":[3825791],"length":1,"stats":{"Line":0}},{"line":409,"address":[4018873,4016843],"length":1,"stats":{"Line":0}},{"line":410,"address":[4018892],"length":1,"stats":{"Line":0}},{"line":414,"address":[4126425,4126489],"length":1,"stats":{"Line":0}},{"line":415,"address":[3092288,3092335],"length":1,"stats":{"Line":0}},{"line":418,"address":[3618784,3618827],"length":1,"stats":{"Line":0}},{"line":420,"address":[4017025],"length":1,"stats":{"Line":0}},{"line":423,"address":[3826287,3826047,3826237],"length":1,"stats":{"Line":0}},{"line":425,"address":[4017493,4017374],"length":1,"stats":{"Line":0}},{"line":426,"address":[4017506],"length":1,"stats":{"Line":0}},{"line":428,"address":[4018136,4017568,4018299,4018571],"length":1,"stats":{"Line":0}},{"line":430,"address":[4018760],"length":1,"stats":{"Line":0}},{"line":435,"address":[4017613],"length":1,"stats":{"Line":0}},{"line":436,"address":[4018006],"length":1,"stats":{"Line":0}},{"line":438,"address":[4017408],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":170},{"path":["/","home","adam","repos","vectordb-cli","src","cli","mod.rs"],"content":"pub mod commands;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","lib.rs"],"content":"// Module exports\npub mod cli;\npub mod utils;\npub mod vectordb;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","main.rs"],"content":"#![allow(dead_code)]\n\nuse anyhow::Result;\nuse clap::Parser;\nuse dirs::data_local_dir;\nuse log::debug;\nuse std::path::PathBuf;\nuse tracing_subscriber;\nuse std::fs;\n\nmod cli;\nmod utils;\nmod vectordb;\n\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    #[command(subcommand)]\n    command: cli::commands::Command,\n\n    /// Optional path to the database file (defaults to system's local data dir)\n    #[arg(long = \"db-path\", global = true)]\n    db_path: Option\u003cString\u003e,\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), anyhow::Error\u003e {\n    tracing_subscriber::fmt::init();\n    // Initialize the logger\n\n    let cli = Cli::parse();\n\n    debug!(\"Initializing vectordb-cli with command: {:?}\", cli.command);\n\n    // Get the database path\n    let base_db_path = match cli.db_path {\n        Some(path) =\u003e PathBuf::from(path),\n        None =\u003e {\n            // Default path logic\n            let default_dir = data_local_dir()\n                .unwrap_or_else(|| PathBuf::from(\".\")) // Fallback to current dir if data_local_dir fails\n                .join(\"vectordb-cli\");\n\n            // Ensure the default directory exists\n            fs::create_dir_all(\u0026default_dir)?;\n            default_dir.join(\"db.json\")\n        }\n    };\n\n    // Ensure the directory for the specified or default db file exists\n    if let Some(parent_dir) = base_db_path.parent() {\n         if !parent_dir.exists() { // Only create if it doesn't exist\n              debug!(\"Creating database directory: {}\", parent_dir.display());\n              fs::create_dir_all(parent_dir)?;\n         }\n    }\n\n    let db_path_str = base_db_path.to_string_lossy().to_string();\n    debug!(\"Using database path: {}\", db_path_str);\n\n    // Create or load the database using the determined path\n    let db = vectordb::VectorDB::new(db_path_str)?;\n\n    // Execute the command\n    let result = cli::commands::execute_command(cli.command, db.clone());\n\n    // Clean up\n    if !matches!(result, Ok(())) {\n        // Handle cleanup on error if needed in the future\n        debug!(\"Command execution resulted in an error: {:?}\", result.as_ref().err());\n    }\n\n    result\n}\n","traces":[{"line":27,"address":[4211024,4211394],"length":1,"stats":{"Line":0}},{"line":28,"address":[3693041],"length":1,"stats":{"Line":0}},{"line":31,"address":[3693160],"length":1,"stats":{"Line":0}},{"line":33,"address":[3693414,3693207,3693316,3693582],"length":1,"stats":{"Line":0}},{"line":36,"address":[3693322],"length":1,"stats":{"Line":0}},{"line":37,"address":[3694433,3693780],"length":1,"stats":{"Line":0}},{"line":40,"address":[3693846,3693967,3693761],"length":1,"stats":{"Line":0}},{"line":41,"address":[3697548,3697536],"length":1,"stats":{"Line":0}},{"line":45,"address":[3694388,3694188,3694070],"length":1,"stats":{"Line":0}},{"line":46,"address":[3694289,3694165],"length":1,"stats":{"Line":0}},{"line":51,"address":[3694495,3694348],"length":1,"stats":{"Line":0}},{"line":52,"address":[3694686,3695326,3694631],"length":1,"stats":{"Line":0}},{"line":53,"address":[3694692,3695075,3694836],"length":1,"stats":{"Line":0}},{"line":54,"address":[3695331,3695262,3694766],"length":1,"stats":{"Line":0}},{"line":58,"address":[3694653,3695466],"length":1,"stats":{"Line":0}},{"line":59,"address":[3695771,3695933,3695605],"length":1,"stats":{"Line":0}},{"line":62,"address":[3695663,3696391,3696122,3697342],"length":1,"stats":{"Line":0}},{"line":65,"address":[3696469,3697309,3696248],"length":1,"stats":{"Line":0}},{"line":68,"address":[3696567],"length":1,"stats":{"Line":0}},{"line":70,"address":[3696792,3696744,3696624,3697014],"length":1,"stats":{"Line":0}},{"line":73,"address":[3696666],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","home","adam","repos","vectordb-cli","src","model_inspector.rs"],"content":"use std::path::Path;\nuse anyhow::{Result, Context};\nuse ort::{GraphOptimizationLevel, Session};\n\nfn main() -\u003e Result\u003c()\u003e {\n    // Path to ONNX model\n    let model_path = Path::new(\"onnx/all-minilm-l12-v2.onnx\");\n    println!(\"Analyzing model: {}\", model_path.display());\n    \n    // Load model without optimization to inspect raw structure\n    let session = Session::builder()?\n        .with_optimization_level(GraphOptimizationLevel::Disable)?\n        .commit_from_file(model_path)\n        .context(\"Failed to load ONNX model\")?;\n    \n    // Print model metadata\n    println!(\"\\nModel Metadata:\");\n    if let Some(metadata) = session.metadata() {\n        println!(\"  Name: {}\", metadata.name().unwrap_or(\"Unknown\"));\n        println!(\"  Producer: {}\", metadata.producer().unwrap_or(\"Unknown\"));\n        println!(\"  Domain: {}\", metadata.domain().unwrap_or(\"Unknown\"));\n        println!(\"  Description: {}\", metadata.description().unwrap_or(\"Unknown\"));\n        println!(\"  Version: {}\", metadata.version());\n    } else {\n        println!(\"  No metadata available\");\n    }\n    \n    // Print input information\n    println!(\"\\nInput Nodes:\");\n    for (i, input) in session.inputs.iter().enumerate() {\n        let shape_str = format_shape(\u0026input.dimensions);\n        println!(\"  [{}] Name: {}\", i, input.name);\n        println!(\"      Shape: {}\", shape_str);\n        println!(\"      Type: {:?}\", input.input_type);\n    }\n    \n    // Print output information\n    println!(\"\\nOutput Nodes:\");\n    for (i, output) in session.outputs.iter().enumerate() {\n        let shape_str = format_shape(\u0026output.dimensions);\n        println!(\"  [{}] Name: {}\", i, output.name);\n        println!(\"      Shape: {}\", shape_str);\n        println!(\"      Type: {:?}\", output.output_type);\n    }\n    \n    println!(\"\\nAnalysis complete.\");\n    Ok(())\n}\n\n// Helper function to format shape information\nfn format_shape(dimensions: \u0026Option\u003cVec\u003ci64\u003e\u003e) -\u003e String {\n    match dimensions {\n        Some(dims) =\u003e {\n            let dims_str: Vec\u003cString\u003e = dims.iter()\n                .map(|d| if *d \u003c 0 { \"?\".to_string() } else { d.to_string() })\n                .collect();\n            format!(\"[{}]\", dims_str.join(\", \"))\n        },\n        None =\u003e \"[unknown]\".to_string(),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","utils","mod.rs"],"content":"// Utility functions will be added here as needed\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","cache.rs"],"content":"use crate::vectordb::embedding::EmbeddingModelType;\nuse crate::vectordb::error::{Result, VectorDBError};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct CacheEntry {\n    // embedding: Vec\u003cf32\u003e, // Removed embedding\n    timestamp: u64,\n    file_hash: u64,\n    model_type: EmbeddingModelType,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct CacheFile {\n    entries: HashMap\u003cString, CacheEntry\u003e,\n}\n\npub enum CacheCheckResult {\n    // Hit(Vec\u003cf32\u003e), // Removed Hit variant with embedding\n    Hit,             // Simplified Hit variant\n    Miss(Option\u003cu64\u003e), // Cache miss, contains Option\u003cfile_hash\u003e\n}\n\n/// Cache structure\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct EmbeddingCache {\n    entries: HashMap\u003cString, CacheEntry\u003e,\n    #[serde(skip)]\n    cache_path: String,\n    #[serde(skip)]\n    ttl: u64, // Time-to-live in seconds\n    #[serde(skip)]\n    current_model_type: EmbeddingModelType, // Track current model type\n}\n\nimpl EmbeddingCache {\n    pub fn new(cache_path: String) -\u003e Result\u003cSelf\u003e {\n        let ttl = 86400 * 7; // Default TTL: 7 days\n\n        if Path::new(\u0026cache_path).exists() {\n            let contents = fs::read_to_string(\u0026cache_path)\n                .map_err(|e| VectorDBError::CacheError(e.to_string()))?;\n            let mut cache: Self = serde_json::from_str(\u0026contents)\n                .map_err(|e| VectorDBError::CacheError(e.to_string()))?;\n            cache.cache_path = cache_path;\n            cache.ttl = ttl;\n            // Default model type on load, user should set it via db\n            cache.current_model_type = EmbeddingModelType::Onnx; // Default to Onnx\n            Ok(cache)\n        } else {\n            Ok(Self {\n                entries: HashMap::new(),\n                cache_path,\n                ttl,\n                current_model_type: EmbeddingModelType::Onnx, // Default to Onnx\n            })\n        }\n    }\n\n    /// Set the current model type\n    pub fn set_model_type(\u0026mut self, model_type: EmbeddingModelType) {\n        self.current_model_type = model_type;\n    }\n\n    pub fn clear(\u0026mut self) -\u003e Result\u003c()\u003e {\n        self.entries.clear();\n        self.save()?;\n        Ok(())\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.entries.len()\n    }\n\n    pub fn save(\u0026self) -\u003e Result\u003c()\u003e {\n        if let Some(parent) = Path::new(\u0026self.cache_path).parent() {\n            std::fs::create_dir_all(parent).map_err(|e| VectorDBError::DirectoryCreationError {\n                path: parent.to_path_buf(),\n                source: e,\n            })?;\n        }\n\n        let cache_file = CacheFile {\n            entries: self.entries.clone(),\n        };\n\n        // Create a temporary file first\n        let temp_path = format!(\"{}.tmp\", self.cache_path);\n\n        // Write to temporary file first\n        let contents =\n            serde_json::to_string_pretty(\u0026cache_file).map_err(VectorDBError::SerializationError)?;\n        std::fs::write(\u0026temp_path, contents).map_err(|e| VectorDBError::FileWriteError {\n            path: Path::new(\u0026temp_path).to_path_buf(),\n            source: e,\n        })?;\n\n        // Atomically rename the temporary file to the actual file\n        std::fs::rename(\u0026temp_path, \u0026self.cache_path).map_err(|e| {\n            VectorDBError::FileWriteError {\n                path: Path::new(\u0026self.cache_path).to_path_buf(),\n                source: e,\n            }\n        })?;\n\n        Ok(())\n    }\n\n    pub fn get_file_hash(path: \u0026Path) -\u003e Result\u003cu64\u003e {\n        let metadata = std::fs::metadata(path).map_err(|e| VectorDBError::MetadataError {\n            path: path.to_path_buf(),\n            source: e,\n        })?;\n\n        let modified = metadata\n            .modified()\n            .map_err(|e| VectorDBError::MetadataError {\n                path: path.to_path_buf(),\n                source: e,\n            })?\n            .duration_since(UNIX_EPOCH)\n            .map_err(|e| VectorDBError::CacheError(e.to_string()))?\n            .as_secs();\n\n        let size = metadata.len();\n\n        Ok(modified.wrapping_mul(31).wrapping_add(size as u64))\n    }\n\n    /// Cleans the cache by removing entries whose model type doesn't match the current one.\n    pub fn invalidate_different_model_types(\u0026mut self) {\n        self.entries\n            .retain(|_, entry| entry.model_type == self.current_model_type);\n    }\n\n    /// Checks the cache for a file, considering TTL, model type, and file modification.\n    /// Returns Hit if valid, or Miss(Option\u003cfile_hash\u003e) if missed or invalid.\n    pub fn check_cache_and_get_hash(\n        \u0026self,\n        file_path_str: \u0026str,\n        file_path: \u0026Path,\n    ) -\u003e Result\u003cCacheCheckResult\u003e {\n        if let Some(entry) = self.entries.get(file_path_str) {\n            let now = SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .map_err(|e| VectorDBError::CacheError(format!(\"System time error: {}\", e)))?\n                .as_secs();\n\n            // 1. Check TTL\n            if now.saturating_sub(entry.timestamp) \u003e= self.ttl {\n                // TTL expired, treat as miss but calculate hash\n                let hash = Self::get_file_hash(file_path)?;\n                return Ok(CacheCheckResult::Miss(Some(hash)));\n            }\n\n            // 2. Check model type\n            if entry.model_type != self.current_model_type {\n                // Model mismatch, treat as miss but calculate hash\n                let hash = Self::get_file_hash(file_path)?;\n                return Ok(CacheCheckResult::Miss(Some(hash)));\n            }\n\n            // 3. Check file hash (modification check)\n            match Self::get_file_hash(file_path) {\n                Ok(current_hash) =\u003e {\n                    if entry.file_hash == current_hash {\n                        // Cache hit and valid\n                        // Ok(CacheCheckResult::Hit(entry.embedding.clone())) // Removed embedding\n                        Ok(CacheCheckResult::Hit) // Simplified Hit\n                    } else {\n                        // File modified, treat as miss, return new hash\n                        Ok(CacheCheckResult::Miss(Some(current_hash)))\n                    }\n                }\n                Err(e) =\u003e {\n                    // Error getting current hash (e.g., file deleted), treat as cache miss\n                    // Log the error for debugging\n                    eprintln!(\n                        \"Warning: Could not get file hash for cache check {}: {}\",\n                        file_path.display(),\n                        e\n                    );\n                    Ok(CacheCheckResult::Miss(None)) // Indicate hash couldn't be determined\n                }\n            }\n        } else {\n            // Not in cache map, treat as miss\n            let hash_opt = Self::get_file_hash(file_path).ok();\n            Ok(CacheCheckResult::Miss(hash_opt))\n        }\n    }\n\n    /// Insert a file hash entry. Used after successful processing of a file's chunks.\n    /// Does not save immediately.\n    pub fn insert_file_hash(\n        \u0026mut self,\n        file_path: String,\n        file_hash: u64,\n    ) -\u003e Result\u003c()\u003e {\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map_err(|e| VectorDBError::CacheError(e.to_string()))?\n            .as_secs();\n\n        let entry = CacheEntry {\n            // embedding, // Removed\n            timestamp: now,\n            file_hash,\n            model_type: self.current_model_type.clone(),\n        };\n\n        self.entries.insert(file_path, entry);\n        // No save here - intended for batch inserts\n        Ok(())\n    }\n\n    /// Removes an entry from the cache if it exists.\n    #[allow(dead_code)] // Suppress warning, used by VectorDB::remove\n    pub fn remove(\u0026mut self, key: \u0026str) -\u003e Result\u003cOption\u003cCacheEntry\u003e\u003e {\n        let removed = self.entries.remove(key);\n        if removed.is_some() {\n            // Save the cache if an entry was actually removed\n            self.save()?;\n        }\n        Ok(removed)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_cache_basic() -\u003e Result\u003c()\u003e {\n        let dir = tempdir()?;\n        let cache_path = dir.path().join(\"cache.json\").to_string_lossy().to_string();\n\n        let mut cache = EmbeddingCache::new(cache_path.clone())?;\n        assert_eq!(cache.len(), 0);\n\n        // Insert an item\n        // let embedding = vec![1.0, 2.0, 3.0]; // Removed\n        let file_hash = 12345u64; // Example hash\n        // cache.insert_with_hash(\"test\".to_string(), embedding.clone(), file_hash)?; // Removed\n        cache.insert_file_hash(\"test\".to_string(), file_hash)?; // Use new method\n        assert_eq!(cache.len(), 1);\n\n        // Check cache hit\n        let temp_file = dir.path().join(\"test_file.txt\");\n        fs::write(\u0026temp_file, \"content\")?;\n        let file_hash_check = EmbeddingCache::get_file_hash(\u0026temp_file)?;\n        // Need to insert again with the actual hash for check to work\n        cache.insert_file_hash(\"test_file.txt\".to_string(), file_hash_check)?;\n\n        let check_result = cache.check_cache_and_get_hash(\"test_file.txt\", \u0026temp_file)?;\n        match check_result {\n            // CacheCheckResult::Hit(cached_embedding) =\u003e assert_eq!(cached_embedding, embedding),\n            CacheCheckResult::Hit =\u003e { /* Correct */ },\n            CacheCheckResult::Miss(_) =\u003e panic!(\"Expected cache hit\"),\n        }\n\n        // Save and reload\n        cache.save()?;\n        let reloaded_cache = EmbeddingCache::new(cache_path)?;\n        assert_eq!(reloaded_cache.len(), 2); // test and test_file.txt\n        Ok(())\n    }\n\n    #[test]\n    fn test_cache_ttl() -\u003e Result\u003c()\u003e {\n        let dir = tempdir()?;\n        let cache_path = dir.path().join(\"cache.json\").to_string_lossy().to_string();\n        let mut cache = EmbeddingCache::new(cache_path.clone())?;\n        cache.ttl = 1; // Set TTL to 1 second for testing\n\n        let file_path = \"ttl_test.txt\".to_string();\n        let temp_file_path = dir.path().join(\u0026file_path);\n        fs::write(\u0026temp_file_path, \"some data\")?;\n        let file_hash = EmbeddingCache::get_file_hash(\u0026temp_file_path)?;\n\n        // Insert entry\n        cache.insert_file_hash(file_path.clone(), file_hash)?;\n\n        // Check immediately (should be hit)\n        match cache.check_cache_and_get_hash(\u0026file_path, \u0026temp_file_path)? {\n            CacheCheckResult::Hit =\u003e { /* OK */ }\n            _ =\u003e panic!(\"Expected immediate cache hit\"),\n        }\n\n        // Wait for TTL to expire\n        std::thread::sleep(std::time::Duration::from_secs(2));\n\n        // Check again (should be miss)\n        match cache.check_cache_and_get_hash(\u0026file_path, \u0026temp_file_path)? {\n            CacheCheckResult::Miss(Some(h)) =\u003e assert_eq!(h, file_hash),\n            _ =\u003e panic!(\"Expected cache miss due to TTL expiry\"),\n        }\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_cache_model_type() -\u003e Result\u003c()\u003e {\n        let dir = tempdir()?;\n        let cache_path = dir.path().join(\"cache.json\").to_string_lossy().to_string();\n        let mut cache = EmbeddingCache::new(cache_path.clone())?;\n\n        let file_path = \"model_test.txt\".to_string();\n        let temp_file_path = dir.path().join(\u0026file_path);\n        fs::write(\u0026temp_file_path, \"data\")?;\n        let file_hash = EmbeddingCache::get_file_hash(\u0026temp_file_path)?;\n\n        // Set initial model type (e.g., Onnx) and insert\n        cache.set_model_type(EmbeddingModelType::Onnx);\n        cache.insert_file_hash(file_path.clone(), file_hash)?;\n        assert_eq!(cache.len(), 1);\n\n        // Check (should be hit)\n        match cache.check_cache_and_get_hash(\u0026file_path, \u0026temp_file_path)? {\n            CacheCheckResult::Hit =\u003e { /* OK */ }\n            _ =\u003e panic!(\"Expected cache hit with matching model type\"),\n        }\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_file_hash_consistency() -\u003e Result\u003c()\u003e {\n        let dir = tempdir()?;\n        let file_path = dir.path().join(\"hash_test.txt\");\n\n        // Create file\n        fs::write(\u0026file_path, \"initial content\")?;\n        let hash1 = EmbeddingCache::get_file_hash(\u0026file_path)?;\n\n        // Check hash again without modification\n        let hash2 = EmbeddingCache::get_file_hash(\u0026file_path)?;\n        assert_eq!(hash1, hash2);\n\n        // Modify content\n        fs::write(\u0026file_path, \"modified content\")?;\n        let hash3 = EmbeddingCache::get_file_hash(\u0026file_path)?;\n        assert_ne!(hash1, hash3);\n\n        // Modify timestamp (tricky to do precisely, but changing content changes timestamp)\n        // Let's just assert hash changes after modification\n\n        Ok(())\n    }\n}\n","traces":[{"line":41,"address":[3673843,3673886,3672496],"length":1,"stats":{"Line":6}},{"line":42,"address":[3647572,3647494],"length":1,"stats":{"Line":6}},{"line":44,"address":[3647551,3647643],"length":1,"stats":{"Line":12}},{"line":45,"address":[3648083,3647885,3648900,3647688],"length":1,"stats":{"Line":4}},{"line":46,"address":[3950073],"length":1,"stats":{"Line":0}},{"line":47,"address":[3950562,3950199,3950051],"length":1,"stats":{"Line":4}},{"line":48,"address":[3950514],"length":1,"stats":{"Line":0}},{"line":49,"address":[3950669,3950456,3950587],"length":1,"stats":{"Line":4}},{"line":50,"address":[3648693],"length":1,"stats":{"Line":2}},{"line":53,"address":[3950709],"length":1,"stats":{"Line":2}},{"line":55,"address":[3672774],"length":1,"stats":{"Line":6}},{"line":56,"address":[3647664],"length":1,"stats":{"Line":6}},{"line":57,"address":[3949755],"length":1,"stats":{"Line":6}},{"line":65,"address":[3648944],"length":1,"stats":{"Line":2}},{"line":69,"address":[3673936],"length":1,"stats":{"Line":2}},{"line":70,"address":[3648998],"length":1,"stats":{"Line":2}},{"line":71,"address":[3649013,3649077],"length":1,"stats":{"Line":2}},{"line":72,"address":[3649068],"length":1,"stats":{"Line":2}},{"line":75,"address":[3674112],"length":1,"stats":{"Line":2}},{"line":76,"address":[3951141],"length":1,"stats":{"Line":2}},{"line":79,"address":[3952590,3951152,3952561],"length":1,"stats":{"Line":2}},{"line":80,"address":[3674166],"length":1,"stats":{"Line":2}},{"line":81,"address":[3674264,3674504],"length":1,"stats":{"Line":2}},{"line":82,"address":[3710397],"length":1,"stats":{"Line":0}},{"line":83,"address":[3042689],"length":1,"stats":{"Line":0}},{"line":88,"address":[3674340],"length":1,"stats":{"Line":2}},{"line":92,"address":[3951601],"length":1,"stats":{"Line":2}},{"line":95,"address":[3649746,3650050,3649817,3650643],"length":1,"stats":{"Line":4}},{"line":97,"address":[3710544,3710708,3710665],"length":1,"stats":{"Line":4}},{"line":98,"address":[3710567,3710635],"length":1,"stats":{"Line":0}},{"line":99,"address":[3042884],"length":1,"stats":{"Line":0}},{"line":103,"address":[3952508,3952320,3952214,3952468],"length":1,"stats":{"Line":4}},{"line":104,"address":[3043081],"length":1,"stats":{"Line":0}},{"line":105,"address":[3710827,3710759],"length":1,"stats":{"Line":0}},{"line":106,"address":[3710852],"length":1,"stats":{"Line":0}},{"line":110,"address":[3952381],"length":1,"stats":{"Line":2}},{"line":113,"address":[3952608],"length":1,"stats":{"Line":2}},{"line":114,"address":[3329302,3329345,3329200],"length":1,"stats":{"Line":2}},{"line":115,"address":[3710957],"length":1,"stats":{"Line":0}},{"line":116,"address":[3329297],"length":1,"stats":{"Line":0}},{"line":119,"address":[3675934,3676323,3676111,3675772],"length":1,"stats":{"Line":4}},{"line":121,"address":[3711206,3711104,3711249],"length":1,"stats":{"Line":0}},{"line":122,"address":[3711133],"length":1,"stats":{"Line":0}},{"line":123,"address":[3711201],"length":1,"stats":{"Line":0}},{"line":126,"address":[3676292],"length":1,"stats":{"Line":0}},{"line":129,"address":[3953230],"length":1,"stats":{"Line":2}},{"line":131,"address":[3953303],"length":1,"stats":{"Line":2}},{"line":135,"address":[3651472],"length":1,"stats":{"Line":0}},{"line":136,"address":[3651480,3651491],"length":1,"stats":{"Line":0}},{"line":137,"address":[3953407],"length":1,"stats":{"Line":0}},{"line":142,"address":[3651504,3653072],"length":1,"stats":{"Line":6}},{"line":147,"address":[3651610,3651900],"length":1,"stats":{"Line":6}},{"line":148,"address":[3953820,3953967,3953592],"length":1,"stats":{"Line":12}},{"line":150,"address":[3711567,3711440,3711680],"length":1,"stats":{"Line":0}},{"line":154,"address":[3953887,3953931],"length":1,"stats":{"Line":12}},{"line":156,"address":[3678247,3678143,3677011],"length":1,"stats":{"Line":4}},{"line":157,"address":[3653281],"length":1,"stats":{"Line":2}},{"line":161,"address":[3652088],"length":1,"stats":{"Line":6}},{"line":163,"address":[3653203,3652255,3653099],"length":1,"stats":{"Line":0}},{"line":164,"address":[3955018],"length":1,"stats":{"Line":0}},{"line":168,"address":[3954114],"length":1,"stats":{"Line":6}},{"line":169,"address":[3677215],"length":1,"stats":{"Line":6}},{"line":170,"address":[3652535,3652352],"length":1,"stats":{"Line":6}},{"line":173,"address":[3652542],"length":1,"stats":{"Line":6}},{"line":176,"address":[3677336],"length":1,"stats":{"Line":0}},{"line":179,"address":[3677258],"length":1,"stats":{"Line":0}},{"line":182,"address":[3677768],"length":1,"stats":{"Line":0}},{"line":187,"address":[3954882],"length":1,"stats":{"Line":0}},{"line":192,"address":[3651801],"length":1,"stats":{"Line":0}},{"line":193,"address":[3676744],"length":1,"stats":{"Line":0}},{"line":199,"address":[3678830,3678304,3678859],"length":1,"stats":{"Line":2}},{"line":204,"address":[3678352,3678438,3678644],"length":1,"stats":{"Line":10}},{"line":206,"address":[3711751,3711728],"length":1,"stats":{"Line":0}},{"line":213,"address":[3955711],"length":1,"stats":{"Line":6}},{"line":216,"address":[3678734],"length":1,"stats":{"Line":6}},{"line":218,"address":[3955821],"length":1,"stats":{"Line":6}},{"line":223,"address":[3955904],"length":1,"stats":{"Line":0}},{"line":224,"address":[3654077],"length":1,"stats":{"Line":0}},{"line":225,"address":[3654092],"length":1,"stats":{"Line":0}},{"line":227,"address":[3654152],"length":1,"stats":{"Line":0}},{"line":229,"address":[3654112],"length":1,"stats":{"Line":0}}],"covered":48,"coverable":81},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","db.rs"],"content":"use crate::vectordb::cache::{CacheCheckResult, EmbeddingCache};\nuse crate::vectordb::embedding::{EmbeddingModel, EmbeddingModelType};\nuse crate::vectordb::error::{Result, VectorDBError};\nuse crate::vectordb::hnsw::{HNSWConfig, HNSWIndex, HNSWStats};\nuse indicatif::{ProgressBar, ProgressStyle};\nuse indicatif::style::TemplateError;\nuse log::{debug, error, warn};\nuse rayon::iter::ParallelIterator;\nuse rayon::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse std::collections::{HashMap, HashSet};\nuse std::fs::{self, canonicalize};\nuse std::path::{Path, PathBuf};\nuse std::sync::mpsc::{self};\nuse std::sync::{Arc, Mutex};\nuse walkdir::WalkDir;\nuse std::time::Instant;\nuse chrono::{Utc};\nuse crate::vectordb::search::chunking::{chunk_by_paragraphs};\n\n// Add From implementation here\nimpl From\u003cTemplateError\u003e for VectorDBError {\n    fn from(error: TemplateError) -\u003e Self {\n        VectorDBError::GeneralError(format!(\"Progress bar template error: {}\", error))\n    }\n}\n\n/// Relevance feedback data for a query-file pair\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct FeedbackEntry {\n    pub relevant_count: usize,\n    pub irrelevant_count: usize,\n    pub relevance_score: f32,\n}\n\n/// Collection of query feedback data\n#[derive(Serialize, Deserialize, Clone, Debug, Default)]\npub struct FeedbackData {\n    pub query_feedback: HashMap\u003cString, HashMap\u003cString, FeedbackEntry\u003e\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct IndexedChunk {\n    pub file_path: String,\n    pub start_line: usize,\n    pub end_line: usize,\n    pub text: String,\n    // Embedding vector is stored in HNSW, not duplicated here by default\n    pub embedding: Vec\u003cf32\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct DBFile {\n    indexed_chunks: Vec\u003cIndexedChunk\u003e,\n    hnsw_config: Option\u003cHNSWConfig\u003e,\n    feedback: Option\u003cFeedbackData\u003e,\n    embedding_model_type: Option\u003cEmbeddingModelType\u003e,\n    onnx_model_path: Option\u003cString\u003e,\n    onnx_tokenizer_path: Option\u003cString\u003e,\n    #[serde(default)]\n    indexed_roots: HashMap\u003cString, u64\u003e,\n}\n\npub struct VectorDB {\n    pub indexed_chunks: Vec\u003cIndexedChunk\u003e,\n    db_path: String,\n    pub cache: EmbeddingCache,\n    pub hnsw_index: Option\u003cHNSWIndex\u003e,\n    feedback: FeedbackData,\n    pub embedding_model_type: EmbeddingModelType,\n    onnx_model_path: Option\u003cPathBuf\u003e,\n    onnx_tokenizer_path: Option\u003cPathBuf\u003e,\n    indexed_roots: HashMap\u003cString, u64\u003e,\n}\n\nimpl Clone for VectorDB {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            indexed_chunks: self.indexed_chunks.clone(),\n            db_path: self.db_path.clone(),\n            cache: self.cache.clone(),\n            hnsw_index: self.hnsw_index.clone(),\n            feedback: self.feedback.clone(),\n            embedding_model_type: self.embedding_model_type.clone(),\n            onnx_model_path: self.onnx_model_path.clone(),\n            onnx_tokenizer_path: self.onnx_tokenizer_path.clone(),\n            indexed_roots: self.indexed_roots.clone(),\n        }\n    }\n}\n\nimpl VectorDB {\n    pub fn new(db_path: String) -\u003e Result\u003cSelf\u003e {\n        debug!(\"Creating VectorDB with database path: {}\", db_path);\n\n        let (\n            indexed_chunks,\n            hnsw_config,\n            feedback,\n            embedding_model_type,\n            onnx_model_path,\n            onnx_tokenizer_path,\n            indexed_roots,\n        ) = if Path::new(\u0026db_path).exists() {\n            debug!(\"Database file exists, attempting to load\");\n            match fs::read_to_string(\u0026db_path) {\n                Ok(contents) =\u003e {\n                    debug!(\"Database file read successfully, parsing JSON\");\n                    let db_file: DBFile = serde_json::from_str(\u0026contents)?;\n\n                    // Determine model type - default to Onnx if missing or if Fast is found (treat Fast as Onnx now)\n                    let loaded_model_type = db_file.embedding_model_type.unwrap_or(EmbeddingModelType::Onnx);\n                    // if loaded_model_type == EmbeddingModelType::Fast { // Remove this check\n                    //     warn!(\"Loaded DB file used deprecated Fast model type. Treating as Onnx.\");\n                    //     loaded_model_type = EmbeddingModelType::Onnx;\n                    // }\n\n                    debug!(\n                        \"Database parsed successfully: {} indexed chunks, {} indexed roots\",\n                        db_file.indexed_chunks.len(),\n                        db_file.indexed_roots.len()\n                    );\n                    (\n                        db_file.indexed_chunks,\n                        db_file.hnsw_config,\n                        db_file.feedback.unwrap_or_default(),\n                        loaded_model_type,\n                        db_file.onnx_model_path.map(PathBuf::from),\n                        db_file.onnx_tokenizer_path.map(PathBuf::from),\n                        db_file.indexed_roots,\n                    )\n                }\n                Err(e) =\u003e {\n                    error!(\"Couldn't read database file: {}\", e);\n                    eprintln!(\"Warning: Couldn't read database file: {}\", e);\n                    eprintln!(\"Creating a new empty database.\");\n                    debug!(\"Creating a new empty database\");\n                    (\n                        Vec::new(),\n                        Some(HNSWConfig::default()),\n                        FeedbackData::default(),\n                        EmbeddingModelType::Onnx,\n                        None,\n                        None,\n                        HashMap::new(),\n                    )\n                }\n            }\n        } else {\n            debug!(\"Database file doesn't exist, creating new database\");\n            (\n                Vec::new(),\n                Some(HNSWConfig::default()),\n                FeedbackData::default(),\n                EmbeddingModelType::Onnx,\n                None,\n                None,\n                HashMap::new(),\n            )\n        };\n\n        let cache_path = Path::new(\u0026db_path)\n            .parent()\n            .unwrap_or_else(|| Path::new(\".\"))\n            .join(\"cache.json\")\n            .to_string_lossy()\n            .to_string();\n        debug!(\"Creating embedding cache at: {}\", cache_path);\n\n        let mut cache = match EmbeddingCache::new(cache_path.clone()) {\n            Ok(cache) =\u003e {\n                debug!(\"Cache loaded successfully\");\n                cache\n            }\n            Err(e) =\u003e {\n                error!(\"Couldn't load cache: {}\", e);\n                eprintln!(\"Warning: Couldn't load cache: {}\", e);\n                eprintln!(\"Creating a new empty cache.\");\n                let _ = fs::remove_file(\u0026cache_path);\n                debug!(\"Creating a new empty cache\");\n                EmbeddingCache::new(cache_path)?\n            }\n        };\n\n        debug!(\"Setting cache model type to: {:?}\", embedding_model_type);\n        cache.set_model_type(embedding_model_type.clone());\n\n        let hnsw_path = Path::new(\u0026db_path)\n            .parent()\n            .unwrap_or_else(|| Path::new(\".\"))\n            .join(\"hnsw_index.json\");\n        debug!(\"Looking for HNSW index at: {}\", hnsw_path.display());\n\n        let hnsw_index = if hnsw_path.exists() {\n            debug!(\"HNSW index file exists, attempting to load\");\n            match HNSWIndex::load_from_file(\u0026hnsw_path) {\n                Ok(index) =\u003e {\n                    // ** Check dimension compatibility with loaded embeddings/model type **\n                    // We need the expected dimension here. Let's try getting it from the potentially loaded hnsw_config\n                    // or fall back to the dimension associated with the loaded embedding_model_type.\n                    // NOTE: This might still be imperfect if db.json/hnsw_config is missing/wrong,\n                    // the definitive check will happen during indexing.\n                    let expected_dim = hnsw_config.map(|c| c.dimension)\n                        .unwrap_or_else(|| embedding_model_type.default_dimension()); // Helper needed\n\n                    if index.get_config().dimension == expected_dim {\n                         debug!(\"HNSW index loaded successfully with matching dimension {}\", expected_dim);\n                         Some(index)\n                    } else {\n                        warn!(\n                            \"Loaded HNSW index dimension ({}) does not match expected dimension ({}) based on db.json/model type. Discarding loaded index.\",\n                            index.get_config().dimension, expected_dim\n                        );\n                         let _ = fs::remove_file(\u0026hnsw_path); // Remove incompatible index\n                         None // Discard the loaded index\n                    }\n                }\n                Err(e) =\u003e {\n                    error!(\"Couldn't load HNSW index: {}. Discarding invalid index file.\", e);\n                    eprintln!(\"Warning: Couldn't load existing HNSW index: {}. It will be rebuilt on next index command.\", e);\n                    let _ = fs::remove_file(\u0026hnsw_path); // Remove the corrupted file\n                    None // Set to None, index will be created on demand later\n                }\n            }\n        } else {\n            debug!(\"No HNSW index file found. It will be created on the next index command.\");\n            None // Set to None, index will be created on demand later\n        };\n\n        debug!(\"VectorDB initialization complete\");\n        Ok(Self {\n            indexed_chunks,\n            db_path,\n            cache,\n            hnsw_index,\n            feedback,\n            embedding_model_type,\n            onnx_model_path,\n            onnx_tokenizer_path,\n            indexed_roots,\n        })\n    }\n\n    pub fn set_onnx_paths(\n        \u0026mut self,\n        model_path: Option\u003cPathBuf\u003e,\n        tokenizer_path: Option\u003cPathBuf\u003e,\n    ) -\u003e Result\u003c()\u003e {\n        if let Some(model_path) = \u0026model_path {\n            if !model_path.exists() {\n                return Err(VectorDBError::EmbeddingError(format!(\n                    \"ONNX model file not found: {}\",\n                    model_path.display()\n                )));\n            }\n        }\n        if let Some(tokenizer_path) = \u0026tokenizer_path {\n            if !tokenizer_path.exists() {\n                return Err(VectorDBError::EmbeddingError(format!(\n                    \"ONNX tokenizer file not found: {}\",\n                    tokenizer_path.display()\n                )));\n            }\n        }\n\n        // Don't try to initialize the model here, just store the paths.\n        // Initialization should happen on demand (e.g., in create_embedding_model).\n        // if let (Some(model_path_ref), Some(tokenizer_path_ref)) = (\u0026model_path, \u0026tokenizer_path) {\n        //     match EmbeddingModel::new_onnx(model_path_ref, tokenizer_path_ref) {\n        //         Ok(_) =\u003e { ... }\n        //         Err(e) =\u003e { ... }\n        //     }\n        // }\n\n        self.onnx_model_path = model_path;\n        self.onnx_tokenizer_path = tokenizer_path;\n        \n        // Optionally, update cache settings if paths are set\n        if self.onnx_model_path.is_some() \u0026\u0026 self.onnx_tokenizer_path.is_some() {\n             self.cache.set_model_type(EmbeddingModelType::Onnx);\n             self.cache.invalidate_different_model_types();\n        }\n        \n        // Save the updated paths to db.json\n        self.save()?;\n\n        Ok(())\n    }\n\n    pub fn create_embedding_model(\u0026self) -\u003e Result\u003cEmbeddingModel\u003e {\n        if let (Some(model_path), Some(tokenizer_path)) =\n            (\u0026self.onnx_model_path, \u0026self.onnx_tokenizer_path)\n        {\n            EmbeddingModel::new_onnx(model_path, tokenizer_path)\n                .map_err(|e| VectorDBError::EmbeddingError(e.to_string()))\n        } else {\n            Err(VectorDBError::EmbeddingError(\n                \"ONNX model paths not set. Required via set_onnx_model_paths or env vars.\".to_string()\n            ))\n        }\n    }\n\n    pub fn index_directory(\u0026mut self, dir_path: \u0026str, file_patterns: \u0026[String]) -\u003e Result\u003c()\u003e {\n        // Canonicalize the input directory path immediately\n        let root_path = canonicalize(Path::new(dir_path)).map_err(|e| {\n            VectorDBError::IndexingError(format!(\n                \"Failed to canonicalize root directory {}: {}\",\n                dir_path, e\n            ))\n        })?;\n        let root_path_str = root_path.to_string_lossy().to_string();\n        debug!(\n            \"Starting indexing for canonical path: {}\",\n            root_path_str\n        );\n\n        let model = self.create_embedding_model()?;\n        let model_arc = Arc::new(model);\n        let embedding_dim = model_arc.dim(); // Get dimension from model\n\n        let file_list = self.collect_files(\u0026root_path_str, file_patterns)?;\n\n        if file_list.is_empty() {\n            println!(\"No files matching the patterns found in {}.\", root_path_str);\n            return Ok(());\n        }\n\n        // Determine embedding batch size (e.g., from config or default)\n        // TODO: Make this configurable\n        let embedding_batch_size = 32; \n\n        // Check HNSW index compatibility *before* indexing\n        if let Some(existing_index) = \u0026self.hnsw_index {\n            if existing_index.get_config().dimension != embedding_dim {\n                warn!(\n                    \"Existing HNSW index dimension ({}) does not match current model dimension ({}). Discarding index.\",\n                    existing_index.get_config().dimension, embedding_dim\n                );\n                self.hnsw_index = None;\n                // Optionally, delete the physical index file here\n                let hnsw_path = Path::new(\u0026self.db_path).parent().unwrap_or_else(|| Path::new(\".\")).join(\"hnsw_index.json\");\n                let _ = fs::remove_file(\u0026hnsw_path);\n            }\n        }\n\n        let processed_chunks_data = self.index_files_parallel(file_list, model_arc, embedding_batch_size)?;\n        \n        // Rebuild HNSW index using *all* current chunks\n        if !processed_chunks_data.is_empty() {\n            debug!(\"Rebuilding HNSW index with new and existing chunks...\");\n            self.rebuild_hnsw_index_from_state(embedding_dim)?; \n        } else {\n            debug!(\"No new chunks were processed, skipping HNSW rebuild.\");\n        }\n        \n        // Record the timestamp for the indexed root directory\n        let timestamp = Utc::now().timestamp() as u64;\n        if let Some(root_dir) = Path::new(dir_path).canonicalize().ok().and_then(|p| p.parent().map(|p| p.to_path_buf())) {\n             self.update_indexed_root_timestamp(root_dir.to_string_lossy().to_string(), timestamp);\n        } else {\n            warn!(\"Could not determine parent directory for {} to update timestamp.\", dir_path);\n        }\n\n        self.save()?;\n\n        Ok(())\n    }\n\n    fn collect_files(\u0026self, canonical_dir_path: \u0026str, file_patterns: \u0026[String]) -\u003e Result\u003cVec\u003cPathBuf\u003e\u003e {\n        let pb = ProgressBar::new_spinner();\n        pb.set_style(\n            ProgressStyle::default_spinner()\n                .template(\"{spinner:.green} Collecting files... {pos} found\")?,\n        );\n        pb.enable_steady_tick(std::time::Duration::from_millis(100));\n\n        let path = Path::new(canonical_dir_path);\n        let mut files = Vec::new();\n        let patterns: HashSet\u003c_\u003e = file_patterns.iter().map(|s| s.as_str()).collect();\n\n        for entry in WalkDir::new(path)\n            .follow_links(false)\n            .into_iter()\n            .filter_map(|e| e.ok())\n        {\n            let entry_path = entry.path();\n            if entry_path.is_file() {\n                let extension = entry_path.extension().and_then(|s| s.to_str()).unwrap_or(\"\");\n                if patterns.is_empty() || patterns.contains(extension) {\n                    // Canonicalize the found file path before adding it\n                    match canonicalize(entry_path) {\n                        Ok(canonical_entry_path) =\u003e {\n                            files.push(canonical_entry_path);\n                            pb.inc(1);\n                        }\n                        Err(e) =\u003e {\n                            error!(\"Failed to canonicalize file path {}: {}. Skipping.\", entry_path.display(), e);\n                        }\n                    }\n                }\n            }\n        }\n\n        pb.finish_with_message(format!(\"Collected {} files\", files.len()));\n        Ok(files)\n    }\n\n    pub fn save(\u0026mut self) -\u003e Result\u003c()\u003e {\n        debug!(\"Saving VectorDB to {}\", self.db_path);\n        let start = Instant::now();\n\n        // --- Rebuild HNSW Index before saving ---\n        // Rebuilding HNSW is now tied to indexing, not saving.\n        // If an index exists, save it. If not, that's fine.\n        if let Some(hnsw_index) = \u0026self.hnsw_index {\n            let hnsw_path = Path::new(\u0026self.db_path)\n                .parent()\n                .unwrap_or_else(|| Path::new(\".\"))\n                .join(\"hnsw_index.json\");\n            debug!(\"Saving HNSW index to {}\", hnsw_path.display());\n            if let Err(e) = hnsw_index.save_to_file(\u0026hnsw_path) {\n                error!(\"Failed to save HNSW index: {}\", e);\n                // Don't return error, allow db.json and cache to save\n                eprintln!(\"Warning: Failed to save HNSW index: {}\", e);\n            } else {\n                debug!(\"HNSW index saved successfully.\");\n            }\n        } else {\n            debug!(\"No HNSW index found, skipping save.\");\n        }\n\n        let db_file = DBFile {\n            indexed_chunks: self.indexed_chunks.clone(),\n            hnsw_config: self.hnsw_index.as_ref().map(|idx| idx.get_config().clone()),\n            feedback: Some(self.feedback.clone()),\n            embedding_model_type: Some(self.embedding_model_type.clone()),\n            onnx_model_path: self.onnx_model_path.as_ref().map(|p| p.to_string_lossy().to_string()),\n            onnx_tokenizer_path: self.onnx_tokenizer_path.as_ref().map(|p| p.to_string_lossy().to_string()),\n            indexed_roots: self.indexed_roots.clone(),\n        };\n\n        let contents = serde_json::to_string_pretty(\u0026db_file)?;\n        fs::write(\u0026self.db_path, contents)?;\n        debug!(\"Saved database file successfully to {}\", self.db_path);\n\n        // debug!(\"Saving cache to {}\", self.cache.cache_path); // Removed log using private field\n        self.cache.save()?;\n        debug!(\"Saved cache successfully.\");\n\n        debug!(\"VectorDB saved in {:.2?}\", start.elapsed());\n        Ok(())\n    }\n\n    pub fn clear(\u0026mut self) -\u003e Result\u003c()\u003e {\n        debug!(\"Clearing VectorDB data\");\n        self.indexed_chunks.clear();\n        self.hnsw_index = None;\n        self.feedback = FeedbackData::default();\n        self.indexed_roots.clear();\n\n        // Also clear the physical files\n        let _ = fs::remove_file(\u0026self.db_path);\n        let hnsw_path = Path::new(\u0026self.db_path)\n                .parent()\n                .unwrap_or_else(|| Path::new(\".\"))\n                .join(\"hnsw_index.json\");\n        let _ = fs::remove_file(hnsw_path);\n        self.cache.clear()?; // Clear cache content and file\n\n        debug!(\"VectorDB cleared\");\n        Ok(())\n    }\n\n    pub fn stats(\u0026self) -\u003e DBStats {\n        // Calculate unique files from indexed_chunks\n        let unique_files = self.indexed_chunks.iter()\n            .map(|chunk| \u0026chunk.file_path)\n            .collect::\u003cHashSet\u003c_\u003e\u003e()\n            .len();\n\n        DBStats {\n            indexed_chunks: self.indexed_chunks.len(),\n            unique_files,\n            embedding_dimension: self.hnsw_index.as_ref()\n                .map_or(self.embedding_model_type.default_dimension(), |idx| idx.get_config().dimension),\n            db_path: self.db_path.clone(),\n            cached_files: self.cache.len(),\n            hnsw_stats: self.hnsw_index.as_ref().map(|idx| idx.stats()),\n            embedding_model_type: self.embedding_model_type,\n        }\n    }\n\n    pub fn onnx_model_path(\u0026self) -\u003e Option\u003c\u0026PathBuf\u003e {\n        self.onnx_model_path.as_ref()\n    }\n\n    pub fn onnx_tokenizer_path(\u0026self) -\u003e Option\u003c\u0026PathBuf\u003e {\n        self.onnx_tokenizer_path.as_ref()\n    }\n\n    pub fn hnsw_index(\u0026self) -\u003e Option\u003c\u0026HNSWIndex\u003e {\n        if let Some(index) = \u0026self.hnsw_index {\n            debug!( \"HNSW index accessed: {} nodes, {} layers\", index.stats().total_nodes, index.stats().layers );\n            Some(index)\n        } else {\n            debug!(\"HNSW index requested but not available\");\n            None\n        }\n    }\n\n    pub fn get_supported_file_types() -\u003e Vec\u003cString\u003e {\n        vec![\n            \"rs\".to_string(), \"rb\".to_string(), \"go\".to_string(), \"js\".to_string(), \"ts\".to_string(),\n            \"md\".to_string(), \"yaml\".to_string(), \"yml\".to_string(), \"toml\".to_string(), \"xml\".to_string(),\n        ]\n    }\n\n    // Renamed from index_directory_parallel to clarify it processes files\n    fn index_files_parallel(\n        \u0026mut self,\n        files: Vec\u003cPathBuf\u003e, // These paths are already canonicalized\n        model: Arc\u003cEmbeddingModel\u003e,\n        embedding_batch_size: usize,\n    ) -\u003e Result\u003cVec\u003cIndexedChunk\u003e\u003e { // Return processed chunk data\n        let total_files = files.len() as u64;\n        if total_files == 0 {\n            return Ok(Vec::new());\n        }\n\n        // Remove existing chunks originating from the files being indexed\n        let files_to_reindex: HashSet\u003cString\u003e = files.iter()\n            .map(|p| p.to_string_lossy().into_owned())\n            .collect();\n        let initial_chunk_count = self.indexed_chunks.len();\n        self.indexed_chunks.retain(|chunk| !files_to_reindex.contains(\u0026chunk.file_path));\n        debug!(\"Removed {} existing chunks for {} files being re-indexed.\", \n               initial_chunk_count - self.indexed_chunks.len(), files_to_reindex.len());\n\n        let progress_bar = ProgressBar::new(total_files);\n        progress_bar.set_style(\n            ProgressStyle::default_bar()\n                .template(\"{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} files ({percent}%) - Chunks: {msg}\")?\n                .progress_chars(\"#\u003e- \")\n        );\n        progress_bar.set_message(\"0\"); // Initial chunk count for this run\n\n        let (files_to_process_sender, files_to_process_receiver) = mpsc::channel::\u003c(PathBuf, String, Option\u003cu64\u003e)\u003e();\n\n        // Shared state for results from the processor thread\n        let processed_chunks_arc = Arc::new(Mutex::new(Vec::\u003cIndexedChunk\u003e::new()));\n        let updated_cache_arc = Arc::new(Mutex::new(self.cache.clone())); \n        let processed_chunk_count_this_run = Arc::new(Mutex::new(0_usize));\n\n        // --- Processor Thread (Embeds Chunks) --- \n        let processor_thread_handle = std::thread::spawn({\n            let model_arc = model.clone();\n            let receiver = files_to_process_receiver;\n            let chunks_write_ref = processed_chunks_arc.clone();\n            let cache_write_ref = updated_cache_arc.clone();\n            let chunk_count_ref = processed_chunk_count_this_run.clone();\n            let pb_clone = progress_bar.clone(); \n\n            move || -\u003e Result\u003c()\u003e {\n                // Store metadata and owned text strings for the batch\n                let mut chunk_batch_meta = Vec::with_capacity(embedding_batch_size);\n                let mut chunk_batch_texts: Vec\u003cString\u003e = Vec::with_capacity(embedding_batch_size); // Store owned Strings\n\n                for (canonical_path_buf, canonical_path_str, file_hash_opt) in receiver {\n                    match fs::read_to_string(\u0026canonical_path_buf) {\n                        Ok(content) =\u003e {\n                            let file_chunks = chunk_by_paragraphs(\u0026content);\n                            \n                            if file_chunks.is_empty() {\n                                // Handle empty files (as before)\n                                debug!(\"Skipping empty file or file with no text: {}\", canonical_path_str);\n                                if let Some(hash_to_insert) = file_hash_opt.or_else(|| EmbeddingCache::get_file_hash(\u0026canonical_path_buf).ok()) {\n                                     if let Err(e) = cache_write_ref.lock().unwrap().insert_file_hash(canonical_path_str.clone(), hash_to_insert) {\n                                         error!(\"Failed to update cache for skipped file {}: {}\", canonical_path_str, e);\n                                     }\n                                } else {\n                                     error!(\"Could not get hash for skipped file {}. Cache not updated.\", canonical_path_str);\n                                }\n                                pb_clone.inc(1); \n                                continue;\n                            }\n\n                            // Chunk the content directly\n                            let file_chunks = chunk_by_paragraphs(\u0026content);\n\n                            let mut file_processed_chunks = Vec::\u003cIndexedChunk\u003e::new();\n\n                            for chunk_info in file_chunks.into_iter() {\n                                // Store metadata\n                                chunk_batch_meta.push((chunk_info.clone(), canonical_path_str.clone())); \n                                // Store owned text string for batching\n                                chunk_batch_texts.push(chunk_info.text);\n\n                                if chunk_batch_texts.len() \u003e= embedding_batch_size {\n                                    // Convert Vec\u003cString\u003e to Vec\u003c\u0026str\u003e for embed_batch\n                                    let text_refs: Vec\u003c\u0026str\u003e = chunk_batch_texts.iter().map(|s| s.as_str()).collect();\n                                    match model_arc.embed_batch(\u0026text_refs) {\n                                        Ok(embeddings) =\u003e {\n                                            for (i, embedding) in embeddings.into_iter().enumerate() {\n                                                 let (info, path) = chunk_batch_meta[i].clone(); \n                                                 file_processed_chunks.push(IndexedChunk {\n                                                     file_path: path,\n                                                     start_line: info.start_line,\n                                                     end_line: info.end_line,\n                                                     text: info.text, // Text is already owned in info\n                                                     embedding: embedding,\n                                                 });\n                                            }\n                                        }\n                                        Err(e) =\u003e {\n                                            error!(\"Chunk batch embedding failed: {}. Skipping batch.\", e);\n                                        }\n                                    }\n                                    chunk_batch_meta.clear();\n                                    chunk_batch_texts.clear(); // Clear owned strings\n                                }\n                            }\n\n                            // Process remaining batch for the file\n                            if !chunk_batch_texts.is_empty() {\n                                let text_refs: Vec\u003c\u0026str\u003e = chunk_batch_texts.iter().map(|s| s.as_str()).collect();\n                                match model_arc.embed_batch(\u0026text_refs) {\n                                    Ok(embeddings) =\u003e {\n                                        for (i, embedding) in embeddings.into_iter().enumerate() {\n                                            let (info, path) = chunk_batch_meta[i].clone();\n                                             file_processed_chunks.push(IndexedChunk {\n                                                 file_path: path,\n                                                 start_line: info.start_line,\n                                                 end_line: info.end_line,\n                                                 text: info.text, // Text is already owned in info\n                                                 embedding: embedding,\n                                             });\n                                        }\n                                    }\n                                    Err(e) =\u003e {\n                                        error!(\"Final chunk batch embedding failed: {}. Skipping batch.\", e);\n                                    }\n                                }\n                                // Clear meta and texts after processing\n                                chunk_batch_meta.clear();\n                                chunk_batch_texts.clear(); \n                            }\n\n                            // Add successfully processed chunks for this file to the main shared vec\n                            if !file_processed_chunks.is_empty() {\n                                let num_added = file_processed_chunks.len(); // Count before moving\n                                let mut processed_chunks_guard = chunks_write_ref.lock().unwrap();\n                                processed_chunks_guard.extend(file_processed_chunks); // Extend with Vec\u003cIndexedChunk\u003e\n                                \n                                let mut chunk_count_guard = chunk_count_ref.lock().unwrap();\n                                *chunk_count_guard += num_added;\n                                pb_clone.set_message(format!(\"{}\", *chunk_count_guard)); \n                            }\n                            \n                            // Update file cache\n                            if let Some(hash_to_insert) = file_hash_opt.or_else(|| EmbeddingCache::get_file_hash(\u0026canonical_path_buf).ok()) {\n                                if let Err(e) = cache_write_ref.lock().unwrap().insert_file_hash(canonical_path_str.clone(), hash_to_insert) {\n                                    error!(\"Failed to update cache for {}: {}\", canonical_path_str, e);\n                                }\n                            } else {\n                                error!(\"Could not get hash for {}. Cache not updated.\", canonical_path_str);\n                            }\n                        }\n                        Err(e) =\u003e {\n                            error!(\"Failed to read file {} during processing: {}. Skipping.\", canonical_path_str, e);\n                        }\n                    }\n                    pb_clone.inc(1); // Increment file progress bar\n                }\n\n                Ok(())\n            }\n        });\n\n        // --- Cache Checking --- \n        let original_cache = self.cache.clone(); \n        files.par_iter().for_each(|canonical_path_buf| {\n            let canonical_path_str = canonical_path_buf.to_string_lossy().into_owned();\n            let cache_result = original_cache.check_cache_and_get_hash(\u0026canonical_path_str, \u0026canonical_path_buf);\n\n            match cache_result {\n                Ok(CacheCheckResult::Hit) =\u003e {\n                    debug!(\"Cache hit for file {}. Skipping chunk processing.\", canonical_path_str);\n                    progress_bar.inc(1);\n                }\n                Ok(CacheCheckResult::Miss(hash_opt)) =\u003e {\n                    debug!(\"Cache miss/invalidated for file {}. Needs processing.\", canonical_path_str);\n                    files_to_process_sender.send((canonical_path_buf.clone(), canonical_path_str, hash_opt))\n                        .expect(\"Failed to send file path to processing thread\");\n                }\n                Err(e) =\u003e {\n                    error!(\"Failed cache check/hash for file {}: {}. Assuming needs processing.\", canonical_path_str, e);\n                    files_to_process_sender.send((canonical_path_buf.clone(), canonical_path_str, None))\n                        .expect(\"Failed to send file path (cache error)\");\n                     // Let processor thread inc progress after trying to read\n                }\n            }\n        });\n\n        drop(files_to_process_sender);\n\n        // --- Wait and Merge Results --- \n        let process_result = processor_thread_handle.join().expect(\"Processing thread panicked\");\n        progress_bar.finish_with_message(format!(\"File processing complete. New chunks: {}\", *processed_chunk_count_this_run.lock().unwrap()));\n\n        if let Err(e) = process_result {\n            return Err(VectorDBError::EmbeddingError(format!(\"Error during chunk processing: {}\", e)));\n        }\n\n        let processed_chunks_data = Arc::try_unwrap(processed_chunks_arc)\n            .expect(\"Failed to unwrap processed_chunks Arc\")\n            .into_inner()\n            .expect(\"Failed to get processed_chunks from Mutex\");\n        \n        debug!(\"Adding {} new indexed chunks to main state\", processed_chunks_data.len());\n        self.indexed_chunks.extend(processed_chunks_data.clone()); // Clone needed if returning below\n        \n        self.cache = Arc::try_unwrap(updated_cache_arc)\n            .expect(\"Failed to unwrap updated_cache Arc\")\n            .into_inner()\n            .expect(\"Failed to get updated_cache from Mutex\");\n        \n        Ok(processed_chunks_data) // Return the processed data for HNSW build\n    }\n\n    // Rebuilds HNSW index using the current `self.indexed_chunks`\n    fn rebuild_hnsw_index_from_state(\u0026mut self, dimension: usize) -\u003e Result\u003c()\u003e {\n        if self.indexed_chunks.is_empty() {\n            debug!(\"No indexed chunks found, skipping HNSW index rebuild.\");\n            self.hnsw_index = None;\n            return Ok(());\n        }\n\n        debug!(\"Rebuilding HNSW index with {} vectors...\", self.indexed_chunks.len());\n        let start = Instant::now();\n\n        // Dimension is now passed in\n        if dimension == 0 {\n            return Err(VectorDBError::HNSWError(\"Cannot build HNSW index with dimension 0\".to_string()));\n        }\n\n        let config = HNSWConfig::new(dimension);\n        let mut hnsw_index = HNSWIndex::new(config);\n\n        // Uncomment progress bar\n        let pb = ProgressBar::new(self.indexed_chunks.len() as u64);\n        pb.set_style(\n            ProgressStyle::default_bar()\n                .template(\"{spinner:.green} Building HNSW index: [{bar:40.cyan/blue}] {pos}/{len} ({percent}%)\")?\n                .progress_chars(\"#\u003e- \")\n        );\n\n        // Iterate through stored chunks and use their embeddings\n        for (i, chunk) in self.indexed_chunks.iter().enumerate() {\n            // Directly use the stored embedding\n            let embedding = \u0026chunk.embedding; // Borrow the embedding\n\n            if embedding.len() != dimension {\n                 error!(\"Fatal error: Chunk {} ({}:{}) has embedding dimension {} but index expects {}. Aborting build.\", \n                       i, chunk.file_path, chunk.start_line, embedding.len(), dimension);\n                 return Err(VectorDBError::HNSWError(format!(\n                     \"Dimension mismatch for vector {} during HNSW rebuild.\", i\n                 )));\n            }\n\n            if let Err(e) = hnsw_index.insert(embedding.clone()) { // Clone embedding for insertion\n                error!(\"Fatal error inserting vector for chunk {} ({}:{}) into HNSW index: {}. Aborting build.\", \n                       i, chunk.file_path, chunk.start_line, e);\n                return Err(VectorDBError::HNSWError(format!(\n                    \"Failed to insert vector {} into HNSW index during rebuild: {}\", i, e\n                )));\n            }\n            pb.inc(1); // Uncomment progress bar increment\n        }\n\n        pb.finish_with_message(\"HNSW index build complete\"); // Uncomment progress bar finish\n        let duration = start.elapsed();\n        debug!(\"HNSW index rebuild took {:.2} seconds\", duration.as_secs_f32());\n\n        self.hnsw_index = Some(hnsw_index);\n        Ok(())\n    }\n\n    // Helper to get file path associated with an HNSW node ID\n    pub fn get_file_path(\u0026self, node_id: usize) -\u003e Option\u003cString\u003e {\n        // The HNSW node ID now corresponds directly to the index in indexed_chunks\n        self.indexed_chunks.get(node_id).map(|chunk| chunk.file_path.clone())\n    }\n\n    // Add getter for cache\n    pub fn cache(\u0026self) -\u003e \u0026EmbeddingCache {\n        \u0026self.cache\n    }\n\n    // Add getter for embedding model type\n    pub fn embedding_model_type(\u0026self) -\u003e EmbeddingModelType {\n        self.embedding_model_type\n    }\n\n    // Replace add_indexed_root with update_indexed_root_timestamp\n    pub fn update_indexed_root_timestamp(\u0026mut self, path_str: String, timestamp: u64) {\n        self.indexed_roots.insert(path_str, timestamp);\n    }\n\n    // Update getter for indexed roots\n    pub fn indexed_roots(\u0026self) -\u003e \u0026HashMap\u003cString, u64\u003e {\n        \u0026self.indexed_roots\n    }\n}\n\npub struct DBStats {\n    pub indexed_chunks: usize,\n    pub unique_files: usize,\n    pub embedding_dimension: usize,\n    pub db_path: String,\n    pub cached_files: usize,\n    pub hnsw_stats: Option\u003cHNSWStats\u003e,\n    pub embedding_model_type: EmbeddingModelType,\n}\n\nimpl Clone for DBStats {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            indexed_chunks: self.indexed_chunks,\n            unique_files: self.unique_files,\n            embedding_dimension: self.embedding_dimension,\n            db_path: self.db_path.clone(),\n            cached_files: self.cached_files,\n            hnsw_stats: self.hnsw_stats.clone(),\n            embedding_model_type: self.embedding_model_type.clone(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*; // Import items from outer module\n    use crate::vectordb::error::Result; // Use the Result alias from the error module\n    use tempfile::tempdir; // For creating temporary directories\n    use std::fs;\n\n    // Helper function to set up a test database environment\n    fn setup_db_test_env() -\u003e (tempfile::TempDir, String) { \n        let temp_dir = tempdir().unwrap();\n        let db_path = temp_dir.path().join(\"test_db.json\");\n        let db_path_str = db_path.to_str().unwrap().to_string();\n\n        // Ensure the directory exists\n        if let Some(parent) = db_path.parent() {\n            fs::create_dir_all(parent).unwrap();\n        }\n        // Don't create/index db here, let tests do it.\n        (temp_dir, db_path_str)\n    }\n\n    #[test]\n    fn test_vectordb_new_empty() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let db = VectorDB::new(db_path_str)?;\n\n        assert!(db.indexed_chunks.is_empty(), \"New DB should have no chunks\");\n        assert!(db.hnsw_index.is_none(), \"New DB should not have HNSW index yet\");\n        assert_eq!(db.embedding_model_type, EmbeddingModelType::Onnx, \"Default model type should be Onnx\");\n        assert!(db.indexed_roots.is_empty(), \"New DB should have no indexed roots\");\n        Ok(())\n    }\n\n    #[test]\n    fn test_vectordb_save_load() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db1 = VectorDB::new(db_path_str.clone())?;\n\n        // Add some dummy data (doesn't need real embeddings for this test)\n        db1.indexed_chunks.push(IndexedChunk {\n            file_path: \"test/file1.txt\".to_string(),\n            start_line: 1,\n            end_line: 10,\n            text: \"chunk 1\".to_string(),\n            embedding: vec![0.1; 10], // Dummy embedding\n        });\n        db1.indexed_roots.insert(\"test\".to_string(), 12345);\n        db1.save()?; // Save the db\n\n        // Create a new instance loading from the same path\n        let db2 = VectorDB::new(db_path_str)?;\n\n        assert_eq!(db2.indexed_chunks.len(), 1, \"Loaded DB should have 1 chunk\");\n        assert_eq!(db2.indexed_chunks[0].file_path, \"test/file1.txt\");\n        assert_eq!(db2.indexed_chunks[0].embedding.len(), 10);\n        assert_eq!(db2.indexed_roots.len(), 1, \"Loaded DB should have 1 indexed root\");\n        assert!(db2.indexed_roots.contains_key(\"test\"));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_vectordb_clear() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db = VectorDB::new(db_path_str.clone())?;\n\n        // Add dummy data\n        db.indexed_chunks.push(IndexedChunk { /* ... */ file_path: \"dummy\".to_string(), start_line: 1, end_line: 1, text: \"t\".to_string(), embedding: vec![0.0] });\n        db.indexed_roots.insert(\"root\".to_string(), 1);\n        assert!(!db.indexed_chunks.is_empty());\n        assert!(!db.indexed_roots.is_empty());\n\n        db.clear()?; // Clear the database\n\n        assert!(db.indexed_chunks.is_empty(), \"DB chunks should be empty after clear\");\n        assert!(db.indexed_roots.is_empty(), \"DB indexed roots should be empty after clear\");\n        assert!(db.hnsw_index.is_none(), \"HNSW index should be None after clear\");\n\n        // Verify persistence of clear\n        db.save()?;\n        let db_reloaded = VectorDB::new(db_path_str)?;\n        assert!(db_reloaded.indexed_chunks.is_empty(), \"Reloaded DB chunks should be empty after clear and save\");\n        assert!(db_reloaded.indexed_roots.is_empty(), \"Reloaded DB indexed roots should be empty after clear and save\");\n\n        Ok(())\n    }\n\n    #[test]\n    #[ignore] // Ignore this test for now as it seems to be hanging\n    fn test_vectordb_stats() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db = VectorDB::new(db_path_str)?;\n\n        // Stats on empty DB\n        let empty_stats = db.stats();\n        assert_eq!(empty_stats.indexed_chunks, 0);\n        assert_eq!(empty_stats.unique_files, 0);\n        assert!(empty_stats.hnsw_stats.is_none());\n\n        // Add dummy data\n        db.indexed_chunks.push(IndexedChunk { file_path: \"file1.txt\".to_string(), start_line: 1, end_line: 1, text: \"t\".to_string(), embedding: vec![0.1; 384] }); // Dim 384 for ONNX default\n        db.indexed_chunks.push(IndexedChunk { file_path: \"file1.txt\".to_string(), start_line: 2, end_line: 2, text: \"t2\".to_string(), embedding: vec![0.2; 384] });\n        db.indexed_chunks.push(IndexedChunk { file_path: \"file2.txt\".to_string(), start_line: 1, end_line: 1, text: \"t3\".to_string(), embedding: vec![0.3; 384] });\n        \n        // Manually create a dummy HNSW index for stats testing (requires dimension)\n        let dim = db.embedding_model_type.default_dimension();\n        db.rebuild_hnsw_index_from_state(dim)?; // Build index from current chunks\n\n        let stats = db.stats();\n        assert_eq!(stats.indexed_chunks, 3);\n        assert_eq!(stats.unique_files, 2); // file1.txt, file2.txt\n        assert_eq!(stats.embedding_dimension, dim);\n        assert!(stats.hnsw_stats.is_some());\n        if let Some(hnsw_stats) = stats.hnsw_stats {\n            assert_eq!(hnsw_stats.total_nodes, 3);\n            // Add more specific HNSW stats checks if needed\n        }\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_vectordb_set_onnx_paths_valid() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db = VectorDB::new(db_path_str)?;\n\n        // Create dummy files\n        let model_path = _temp_dir.path().join(\"model.onnx\");\n        let tokenizer_path = _temp_dir.path().join(\"tokenizer.json\");\n        fs::write(\u0026model_path, \"dummy model data\")?;\n        fs::write(\u0026tokenizer_path, \"dummy tokenizer data\")?;\n\n        let result = db.set_onnx_paths(Some(model_path.clone()), Some(tokenizer_path.clone()));\n        assert!(result.is_ok(), \"Setting valid paths should succeed\");\n        assert_eq!(db.onnx_model_path(), Some(\u0026model_path));\n        assert_eq!(db.onnx_tokenizer_path(), Some(\u0026tokenizer_path));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_vectordb_set_onnx_paths_invalid() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db = VectorDB::new(db_path_str)?;\n\n        let non_existent_path = _temp_dir.path().join(\"non_existent.onnx\");\n\n        let result = db.set_onnx_paths(Some(non_existent_path), None);\n        assert!(result.is_err(), \"Setting non-existent path should fail\");\n        // Ensure paths weren't partially set\n        assert!(db.onnx_model_path().is_none());\n        assert!(db.onnx_tokenizer_path().is_none());\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_vectordb_get_file_path() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db = VectorDB::new(db_path_str)?;\n\n        assert!(db.get_file_path(0).is_none(), \"Path for invalid index should be None\");\n\n        db.indexed_chunks.push(IndexedChunk { file_path: \"path/one\".to_string(), /* ... */ start_line: 1, end_line: 1, text: \"\".to_string(), embedding: vec![] });\n        db.indexed_chunks.push(IndexedChunk { file_path: \"path/two\".to_string(), /* ... */ start_line: 1, end_line: 1, text: \"\".to_string(), embedding: vec![] });\n\n        assert_eq!(db.get_file_path(0), Some(\"path/one\".to_string()));\n        assert_eq!(db.get_file_path(1), Some(\"path/two\".to_string()));\n        assert!(db.get_file_path(2).is_none());\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_vectordb_indexed_roots() -\u003e Result\u003c()\u003e {\n        let (_temp_dir, db_path_str) = setup_db_test_env();\n        let mut db = VectorDB::new(db_path_str)?;\n\n        assert!(db.indexed_roots().is_empty(), \"Initial roots should be empty\");\n\n        db.update_indexed_root_timestamp(\"/path/a\".to_string(), 100);\n        db.update_indexed_root_timestamp(\"/path/b\".to_string(), 200);\n        db.update_indexed_root_timestamp(\"/path/a\".to_string(), 150); // Update timestamp\n\n        let roots = db.indexed_roots();\n        assert_eq!(roots.len(), 2);\n        assert_eq!(roots.get(\"/path/a\"), Some(\u0026150));\n        assert_eq!(roots.get(\"/path/b\"), Some(\u0026200));\n\n        Ok(())\n    }\n\n    // Existing test\n    #[test]\n    fn test_vectordb() -\u003e Result\u003c()\u003e {\n        // ... (Keep existing test_vectordb as is for now)\n        let (_temp_dir, _db) = setup_db_test_env(); // Use helper if needed, or keep original setup\n        // ... rest of original test ... \n        Ok(())\n    }\n}","traces":[{"line":23,"address":[3448960],"length":1,"stats":{"Line":0}},{"line":24,"address":[3845761,3845648],"length":1,"stats":{"Line":0}},{"line":77,"address":[3656362,3655552],"length":1,"stats":{"Line":0}},{"line":79,"address":[2770141],"length":1,"stats":{"Line":0}},{"line":80,"address":[4357651],"length":1,"stats":{"Line":0}},{"line":81,"address":[3655673],"length":1,"stats":{"Line":0}},{"line":82,"address":[3655732],"length":1,"stats":{"Line":0}},{"line":83,"address":[2770342],"length":1,"stats":{"Line":0}},{"line":84,"address":[4357894],"length":1,"stats":{"Line":0}},{"line":85,"address":[2770462],"length":1,"stats":{"Line":0}},{"line":86,"address":[4357977],"length":1,"stats":{"Line":0}},{"line":87,"address":[4358045],"length":1,"stats":{"Line":0}},{"line":93,"address":[3658280,3656384,3672040],"length":1,"stats":{"Line":6}},{"line":94,"address":[2771422,2770973,2771270,2771178],"length":1,"stats":{"Line":18}},{"line":96,"address":[4358680,4359105],"length":1,"stats":{"Line":12}},{"line":97,"address":[4359974],"length":1,"stats":{"Line":6}},{"line":98,"address":[2772526],"length":1,"stats":{"Line":6}},{"line":99,"address":[2772574],"length":1,"stats":{"Line":6}},{"line":101,"address":[3658114],"length":1,"stats":{"Line":6}},{"line":102,"address":[3658154],"length":1,"stats":{"Line":6}},{"line":103,"address":[4360198],"length":1,"stats":{"Line":6}},{"line":105,"address":[4360417,4360337,4359177],"length":1,"stats":{"Line":10}},{"line":106,"address":[3658351,3658634],"length":1,"stats":{"Line":8}},{"line":107,"address":[2773177],"length":1,"stats":{"Line":4}},{"line":108,"address":[3658861,3658949,3658701],"length":1,"stats":{"Line":10}},{"line":109,"address":[4360871,4361182,4361388],"length":1,"stats":{"Line":6}},{"line":112,"address":[2773874],"length":1,"stats":{"Line":3}},{"line":118,"address":[4361800],"length":1,"stats":{"Line":0}},{"line":124,"address":[2774036],"length":1,"stats":{"Line":3}},{"line":125,"address":[3659584],"length":1,"stats":{"Line":3}},{"line":126,"address":[2774124],"length":1,"stats":{"Line":3}},{"line":128,"address":[4362337],"length":1,"stats":{"Line":3}},{"line":129,"address":[2774949],"length":1,"stats":{"Line":3}},{"line":130,"address":[3660591],"length":1,"stats":{"Line":3}},{"line":133,"address":[2773254],"length":1,"stats":{"Line":0}},{"line":134,"address":[2773270,2775979,2775642,2775811],"length":1,"stats":{"Line":0}},{"line":135,"address":[3661704],"length":1,"stats":{"Line":0}},{"line":136,"address":[4363715],"length":1,"stats":{"Line":0}},{"line":137,"address":[4363884,4363760],"length":1,"stats":{"Line":0}},{"line":139,"address":[3661876],"length":1,"stats":{"Line":0}},{"line":140,"address":[2776614,2776661],"length":1,"stats":{"Line":0}},{"line":141,"address":[3662287],"length":1,"stats":{"Line":0}},{"line":143,"address":[2776746],"length":1,"stats":{"Line":0}},{"line":144,"address":[3662312],"length":1,"stats":{"Line":0}},{"line":145,"address":[2776762],"length":1,"stats":{"Line":0}},{"line":150,"address":[3657116,3657216,3657292],"length":1,"stats":{"Line":18}},{"line":152,"address":[3657222],"length":1,"stats":{"Line":6}},{"line":153,"address":[3657502,3657565],"length":1,"stats":{"Line":12}},{"line":154,"address":[3657633],"length":1,"stats":{"Line":6}},{"line":156,"address":[2772166],"length":1,"stats":{"Line":6}},{"line":157,"address":[3657658],"length":1,"stats":{"Line":6}},{"line":158,"address":[4359670],"length":1,"stats":{"Line":6}},{"line":162,"address":[2777144,2777364,2772766],"length":1,"stats":{"Line":18}},{"line":164,"address":[3168929,3168928],"length":1,"stats":{"Line":0}},{"line":168,"address":[2777867,2777563,2777699],"length":1,"stats":{"Line":12}},{"line":170,"address":[2778062,2777621],"length":1,"stats":{"Line":12}},{"line":171,"address":[3663674],"length":1,"stats":{"Line":6}},{"line":172,"address":[2778472,2778188,2778379],"length":1,"stats":{"Line":18}},{"line":173,"address":[2778385],"length":1,"stats":{"Line":6}},{"line":175,"address":[2778236],"length":1,"stats":{"Line":0}},{"line":176,"address":[2778949,2778780,2779117,2778284],"length":1,"stats":{"Line":0}},{"line":177,"address":[3664870],"length":1,"stats":{"Line":0}},{"line":178,"address":[3664939],"length":1,"stats":{"Line":0}},{"line":179,"address":[4366906],"length":1,"stats":{"Line":0}},{"line":180,"address":[3665046,3665222],"length":1,"stats":{"Line":0}},{"line":181,"address":[3665435,3665104,3665699],"length":1,"stats":{"Line":0}},{"line":185,"address":[4367790,4366173,4367718,4367955],"length":1,"stats":{"Line":18}},{"line":186,"address":[3666240,3665838],"length":1,"stats":{"Line":12}},{"line":188,"address":[3666267],"length":1,"stats":{"Line":6}},{"line":190,"address":[4253985,4253984],"length":1,"stats":{"Line":0}},{"line":192,"address":[4368321,4368775,4368417,4368505],"length":1,"stats":{"Line":18}},{"line":194,"address":[4369121,4368970,4368431],"length":1,"stats":{"Line":18}},{"line":195,"address":[3667156,3667641,3667553],"length":1,"stats":{"Line":0}},{"line":196,"address":[2782276,2781965],"length":1,"stats":{"Line":0}},{"line":197,"address":[2782322],"length":1,"stats":{"Line":0}},{"line":203,"address":[4254016],"length":1,"stats":{"Line":0}},{"line":204,"address":[3601312,3601321],"length":1,"stats":{"Line":0}},{"line":206,"address":[3669076,3668241],"length":1,"stats":{"Line":0}},{"line":207,"address":[3669120,3668328,3669282,3669010],"length":1,"stats":{"Line":0}},{"line":208,"address":[2783386],"length":1,"stats":{"Line":0}},{"line":210,"address":[2782891],"length":1,"stats":{"Line":0}},{"line":214,"address":[4370257,4370800],"length":1,"stats":{"Line":0}},{"line":215,"address":[2783339],"length":1,"stats":{"Line":0}},{"line":218,"address":[4369945],"length":1,"stats":{"Line":0}},{"line":219,"address":[3669863,3669538,3668083,3669701],"length":1,"stats":{"Line":0}},{"line":220,"address":[3670036],"length":1,"stats":{"Line":0}},{"line":221,"address":[3670105],"length":1,"stats":{"Line":0}},{"line":222,"address":[2784533],"length":1,"stats":{"Line":0}},{"line":226,"address":[3667111,3667288,3667211],"length":1,"stats":{"Line":18}},{"line":227,"address":[4369103],"length":1,"stats":{"Line":6}},{"line":230,"address":[3670252,3667498,3671211],"length":1,"stats":{"Line":18}},{"line":231,"address":[2785083],"length":1,"stats":{"Line":6}},{"line":232,"address":[3670278],"length":1,"stats":{"Line":6}},{"line":233,"address":[3670318],"length":1,"stats":{"Line":6}},{"line":234,"address":[2784707],"length":1,"stats":{"Line":6}},{"line":235,"address":[4372283],"length":1,"stats":{"Line":6}},{"line":236,"address":[3670533],"length":1,"stats":{"Line":6}},{"line":238,"address":[3670589],"length":1,"stats":{"Line":6}},{"line":239,"address":[2784987],"length":1,"stats":{"Line":6}},{"line":240,"address":[4372515],"length":1,"stats":{"Line":6}},{"line":244,"address":[2789686,2786416,2789099],"length":1,"stats":{"Line":0}},{"line":249,"address":[3672135],"length":1,"stats":{"Line":0}},{"line":250,"address":[3672340,3672213],"length":1,"stats":{"Line":0}},{"line":251,"address":[3672706,3672577],"length":1,"stats":{"Line":0}},{"line":253,"address":[4374203],"length":1,"stats":{"Line":0}},{"line":257,"address":[4374635,4374068],"length":1,"stats":{"Line":0}},{"line":258,"address":[2787155,2787261],"length":1,"stats":{"Line":0}},{"line":259,"address":[3673134,3673263],"length":1,"stats":{"Line":0}},{"line":261,"address":[3672954],"length":1,"stats":{"Line":0}},{"line":266,"address":[3673346,3673452,3672852],"length":1,"stats":{"Line":0}},{"line":267,"address":[2787825],"length":1,"stats":{"Line":0}},{"line":269,"address":[3673638,3673829],"length":1,"stats":{"Line":0}},{"line":270,"address":[2788279],"length":1,"stats":{"Line":0}},{"line":271,"address":[2788443],"length":1,"stats":{"Line":0}},{"line":272,"address":[2788528],"length":1,"stats":{"Line":0}},{"line":273,"address":[4376043,4376249,4376144],"length":1,"stats":{"Line":0}},{"line":275,"address":[4375510],"length":1,"stats":{"Line":0}},{"line":276,"address":[3674672,3674543],"length":1,"stats":{"Line":0}},{"line":283,"address":[4375224,4376622],"length":1,"stats":{"Line":0}},{"line":284,"address":[2789252],"length":1,"stats":{"Line":0}},{"line":285,"address":[2789427,2789581],"length":1,"stats":{"Line":0}},{"line":287,"address":[4376222],"length":1,"stats":{"Line":0}},{"line":290,"address":[2789728],"length":1,"stats":{"Line":0}},{"line":291,"address":[2789814,2789753],"length":1,"stats":{"Line":0}},{"line":294,"address":[4377504],"length":1,"stats":{"Line":0}},{"line":295,"address":[3601362,3601344],"length":1,"stats":{"Line":0}},{"line":297,"address":[2789883],"length":1,"stats":{"Line":0}},{"line":298,"address":[2789853],"length":1,"stats":{"Line":0}},{"line":303,"address":[4380983,4377584,4383665],"length":1,"stats":{"Line":0}},{"line":305,"address":[3676201,3675923],"length":1,"stats":{"Line":0}},{"line":306,"address":[4254599,4254250,4254485],"length":1,"stats":{"Line":0}},{"line":311,"address":[4377901,4378051],"length":1,"stats":{"Line":0}},{"line":312,"address":[2790997,2790697,2790829],"length":1,"stats":{"Line":0}},{"line":317,"address":[4378259,4383644,4378965,4378680],"length":1,"stats":{"Line":0}},{"line":318,"address":[2791374,2791599],"length":1,"stats":{"Line":0}},{"line":319,"address":[2791623,2791684],"length":1,"stats":{"Line":0}},{"line":321,"address":[3677479,3681921,3677716],"length":1,"stats":{"Line":0}},{"line":323,"address":[3677841,3677682],"length":1,"stats":{"Line":0}},{"line":324,"address":[3681771],"length":1,"stats":{"Line":0}},{"line":325,"address":[4383489],"length":1,"stats":{"Line":0}},{"line":330,"address":[2790183],"length":1,"stats":{"Line":0}},{"line":333,"address":[2792087,2792266],"length":1,"stats":{"Line":0}},{"line":334,"address":[4379873,4379770],"length":1,"stats":{"Line":0}},{"line":335,"address":[4379891,4380338,4380037],"length":1,"stats":{"Line":0}},{"line":339,"address":[4380541,4379967],"length":1,"stats":{"Line":0}},{"line":341,"address":[3169665,3169664],"length":1,"stats":{"Line":0}},{"line":342,"address":[3679234,3679155],"length":1,"stats":{"Line":0}},{"line":346,"address":[2795922,2793520,2792297,2793647],"length":1,"stats":{"Line":0}},{"line":349,"address":[2793625,2793767],"length":1,"stats":{"Line":0}},{"line":350,"address":[4381261,4381361,4381443],"length":1,"stats":{"Line":0}},{"line":351,"address":[2794169,2793887,2794232],"length":1,"stats":{"Line":0}},{"line":353,"address":[3680199,3680148,3679625],"length":1,"stats":{"Line":0}},{"line":357,"address":[4382069,4381690],"length":1,"stats":{"Line":0}},{"line":358,"address":[3680437],"length":1,"stats":{"Line":0}},{"line":359,"address":[2794817,2794941],"length":1,"stats":{"Line":0}},{"line":361,"address":[4382728,4382890,4382680,4382322],"length":1,"stats":{"Line":0}},{"line":364,"address":[4383139,4383097,4383353,4383210],"length":1,"stats":{"Line":0}},{"line":366,"address":[3681531],"length":1,"stats":{"Line":0}},{"line":369,"address":[4386452,4386498,4383680],"length":1,"stats":{"Line":0}},{"line":370,"address":[4383775],"length":1,"stats":{"Line":0}},{"line":371,"address":[3682394],"length":1,"stats":{"Line":0}},{"line":372,"address":[2796375,2796552,2796312,2796575],"length":1,"stats":{"Line":0}},{"line":373,"address":[2796559,2796545],"length":1,"stats":{"Line":0}},{"line":375,"address":[2796597],"length":1,"stats":{"Line":0}},{"line":377,"address":[2796669],"length":1,"stats":{"Line":0}},{"line":378,"address":[4384246],"length":1,"stats":{"Line":0}},{"line":379,"address":[4384269,4384361],"length":1,"stats":{"Line":0}},{"line":381,"address":[4384439,4384731,4384681,4384490],"length":1,"stats":{"Line":0}},{"line":384,"address":[3169968,3169996],"length":1,"stats":{"Line":0}},{"line":386,"address":[2797291,2797818],"length":1,"stats":{"Line":0}},{"line":387,"address":[4385341],"length":1,"stats":{"Line":0}},{"line":388,"address":[2797919],"length":1,"stats":{"Line":0}},{"line":389,"address":[3683975,3684077],"length":1,"stats":{"Line":0}},{"line":391,"address":[2798150,2798130],"length":1,"stats":{"Line":0}},{"line":392,"address":[2798185],"length":1,"stats":{"Line":0}},{"line":393,"address":[2798217],"length":1,"stats":{"Line":0}},{"line":394,"address":[3684245],"length":1,"stats":{"Line":0}},{"line":396,"address":[2798247],"length":1,"stats":{"Line":0}},{"line":397,"address":[4385940,4385870,4385751,4386265],"length":1,"stats":{"Line":0}},{"line":404,"address":[2797615,2797478,2797337],"length":1,"stats":{"Line":0}},{"line":405,"address":[4385118],"length":1,"stats":{"Line":0}},{"line":408,"address":[4388746,4389222,4386512],"length":1,"stats":{"Line":2}},{"line":409,"address":[3685327,3685190,3685015],"length":1,"stats":{"Line":4}},{"line":410,"address":[4386604],"length":1,"stats":{"Line":2}},{"line":415,"address":[3687608,3685514,3685102],"length":1,"stats":{"Line":2}},{"line":416,"address":[2799570],"length":1,"stats":{"Line":0}},{"line":418,"address":[3170049,3170048],"length":1,"stats":{"Line":0}},{"line":420,"address":[3685835,3686105,3685747,3685605],"length":1,"stats":{"Line":0}},{"line":421,"address":[4387293,4387840],"length":1,"stats":{"Line":0}},{"line":422,"address":[3686717,3686548,3686885,3686404],"length":1,"stats":{"Line":0}},{"line":424,"address":[4388592],"length":1,"stats":{"Line":0}},{"line":426,"address":[3687288,3686449,3687234],"length":1,"stats":{"Line":0}},{"line":429,"address":[3685650,3687762],"length":1,"stats":{"Line":4}},{"line":433,"address":[2801674],"length":1,"stats":{"Line":2}},{"line":434,"address":[4389190,4389508],"length":1,"stats":{"Line":4}},{"line":435,"address":[2802035],"length":1,"stats":{"Line":2}},{"line":436,"address":[4389663,4389601],"length":1,"stats":{"Line":4}},{"line":437,"address":[3688163],"length":1,"stats":{"Line":2}},{"line":438,"address":[3170318,3170288],"length":1,"stats":{"Line":4}},{"line":439,"address":[2802341],"length":1,"stats":{"Line":2}},{"line":442,"address":[3688723,3688652,3688948,3690907],"length":1,"stats":{"Line":4}},{"line":443,"address":[2804861,2802873,2803030,2803138],"length":1,"stats":{"Line":8}},{"line":444,"address":[4390576,4390741,4390663,4390888],"length":1,"stats":{"Line":12}},{"line":447,"address":[3689688,3690857,3689585,3689197],"length":1,"stats":{"Line":6}},{"line":448,"address":[3689769,3689638,3689862],"length":1,"stats":{"Line":9}},{"line":450,"address":[4391243,4391838,4391624,4392102,4391535],"length":1,"stats":{"Line":9}},{"line":451,"address":[3690081],"length":1,"stats":{"Line":3}},{"line":454,"address":[2804896,2805974],"length":1,"stats":{"Line":2}},{"line":455,"address":[4392517,4392413],"length":1,"stats":{"Line":4}},{"line":456,"address":[3690976],"length":1,"stats":{"Line":2}},{"line":457,"address":[3690999,3691188],"length":1,"stats":{"Line":2}},{"line":458,"address":[2805318],"length":1,"stats":{"Line":2}},{"line":459,"address":[3691458],"length":1,"stats":{"Line":2}},{"line":462,"address":[2805446],"length":1,"stats":{"Line":2}},{"line":463,"address":[3691511],"length":1,"stats":{"Line":2}},{"line":465,"address":[4255457,4255456],"length":1,"stats":{"Line":0}},{"line":467,"address":[3691582],"length":1,"stats":{"Line":2}},{"line":468,"address":[2805590,2805693],"length":1,"stats":{"Line":2}},{"line":470,"address":[3691688,3691829],"length":1,"stats":{"Line":4}},{"line":471,"address":[2805754],"length":1,"stats":{"Line":2}},{"line":474,"address":[4393488,4393960],"length":1,"stats":{"Line":0}},{"line":476,"address":[2806142,2806038],"length":1,"stats":{"Line":0}},{"line":477,"address":[3602768,3602781],"length":1,"stats":{"Line":0}},{"line":482,"address":[3692225],"length":1,"stats":{"Line":0}},{"line":484,"address":[2806180,2806219],"length":1,"stats":{"Line":0}},{"line":486,"address":[2806234],"length":1,"stats":{"Line":0}},{"line":487,"address":[3692336],"length":1,"stats":{"Line":0}},{"line":488,"address":[4393813],"length":1,"stats":{"Line":0}},{"line":493,"address":[3692592],"length":1,"stats":{"Line":0}},{"line":494,"address":[2806501],"length":1,"stats":{"Line":0}},{"line":497,"address":[3692624],"length":1,"stats":{"Line":0}},{"line":498,"address":[2806533],"length":1,"stats":{"Line":0}},{"line":501,"address":[4394803,4394048],"length":1,"stats":{"Line":0}},{"line":502,"address":[2806725,2807346,2806575],"length":1,"stats":{"Line":0}},{"line":503,"address":[4394399,4394559,4394124,4394246],"length":1,"stats":{"Line":0}},{"line":504,"address":[3692816],"length":1,"stats":{"Line":0}},{"line":506,"address":[3693490,3692765],"length":1,"stats":{"Line":0}},{"line":507,"address":[2807337],"length":1,"stats":{"Line":0}},{"line":511,"address":[4395040,4396186],"length":1,"stats":{"Line":0}},{"line":512,"address":[2807674,2807996,2807798,2808200,2807579,2808132,2808064,2807863,2807736,2807928,2807618,2808677],"length":1,"stats":{"Line":0}},{"line":513,"address":[2807712,2807774,2807589,2807650,2807836],"length":1,"stats":{"Line":0}},{"line":514,"address":[2808037,2807901,2807969,2808173,2808105],"length":1,"stats":{"Line":0}},{"line":519,"address":[3694848,3699425,3700966],"length":1,"stats":{"Line":0}},{"line":525,"address":[3694930,3695049],"length":1,"stats":{"Line":0}},{"line":526,"address":[4396409],"length":1,"stats":{"Line":0}},{"line":527,"address":[2808981,2808935],"length":1,"stats":{"Line":0}},{"line":531,"address":[4396438,4396546],"length":1,"stats":{"Line":0}},{"line":532,"address":[4255568,4255605],"length":1,"stats":{"Line":0}},{"line":534,"address":[3695319,3695398],"length":1,"stats":{"Line":0}},{"line":535,"address":[3170640,3170654],"length":1,"stats":{"Line":0}},{"line":536,"address":[3695425,3695986,3695561],"length":1,"stats":{"Line":0}},{"line":539,"address":[2809323],"length":1,"stats":{"Line":0}},{"line":540,"address":[3696481],"length":1,"stats":{"Line":0}},{"line":541,"address":[4397749,4397497,4402000,4397560,4397772],"length":1,"stats":{"Line":0}},{"line":542,"address":[2810254,2810268],"length":1,"stats":{"Line":0}},{"line":545,"address":[4397816],"length":1,"stats":{"Line":0}},{"line":547,"address":[2810367],"length":1,"stats":{"Line":0}},{"line":550,"address":[2810526,2810462],"length":1,"stats":{"Line":0}},{"line":551,"address":[2810588,2810664],"length":1,"stats":{"Line":0}},{"line":552,"address":[2810718,2810790],"length":1,"stats":{"Line":0}},{"line":555,"address":[4398864],"length":1,"stats":{"Line":0}},{"line":556,"address":[2810829,2810889],"length":1,"stats":{"Line":0}},{"line":557,"address":[2810897],"length":1,"stats":{"Line":0}},{"line":558,"address":[2810945,2811008],"length":1,"stats":{"Line":0}},{"line":559,"address":[4398566,4398512],"length":1,"stats":{"Line":0}},{"line":560,"address":[4398582,4398636],"length":1,"stats":{"Line":0}},{"line":561,"address":[2811172],"length":1,"stats":{"Line":0}},{"line":563,"address":[3604016,3602976],"length":1,"stats":{"Line":0}},{"line":565,"address":[3170718],"length":1,"stats":{"Line":0}},{"line":566,"address":[3603205],"length":1,"stats":{"Line":0}},{"line":568,"address":[4256091,4256211,4255996,4256167],"length":1,"stats":{"Line":0}},{"line":569,"address":[3604082,3603627],"length":1,"stats":{"Line":0}},{"line":570,"address":[3171756],"length":1,"stats":{"Line":0}},{"line":571,"address":[3171796,3171951],"length":1,"stats":{"Line":0}},{"line":573,"address":[3171966,3172056],"length":1,"stats":{"Line":0}},{"line":575,"address":[3604466,3612715,3612823,3612991],"length":1,"stats":{"Line":0}},{"line":576,"address":[3180528,3180097,3183097,3183088],"length":1,"stats":{"Line":0}},{"line":577,"address":[3180584,3180658,3180965,3180888],"length":1,"stats":{"Line":0}},{"line":578,"address":[3613916,3614252,3613791,3613983],"length":1,"stats":{"Line":0}},{"line":581,"address":[3614580,3614532,3614742,3613256],"length":1,"stats":{"Line":0}},{"line":583,"address":[4266837],"length":1,"stats":{"Line":0}},{"line":588,"address":[3604530,3604443],"length":1,"stats":{"Line":0}},{"line":590,"address":[4257212],"length":1,"stats":{"Line":0}},{"line":592,"address":[3605013,3604617,3604959,3604797,3610731],"length":1,"stats":{"Line":0}},{"line":594,"address":[3172681,3177854],"length":1,"stats":{"Line":0}},{"line":596,"address":[4263052],"length":1,"stats":{"Line":0}},{"line":598,"address":[4263126],"length":1,"stats":{"Line":0}},{"line":600,"address":[3183152,3178164,3183177],"length":1,"stats":{"Line":0}},{"line":601,"address":[3610967,3610900],"length":1,"stats":{"Line":0}},{"line":602,"address":[3611071],"length":1,"stats":{"Line":0}},{"line":603,"address":[4263793,4263674,4263843,4264443,4263555],"length":1,"stats":{"Line":0}},{"line":604,"address":[4263899,4264004],"length":1,"stats":{"Line":0}},{"line":605,"address":[3179219],"length":1,"stats":{"Line":0}},{"line":606,"address":[4264107],"length":1,"stats":{"Line":0}},{"line":607,"address":[3179123],"length":1,"stats":{"Line":0}},{"line":608,"address":[3179131],"length":1,"stats":{"Line":0}},{"line":609,"address":[3179139],"length":1,"stats":{"Line":0}},{"line":610,"address":[4264203],"length":1,"stats":{"Line":0}},{"line":614,"address":[4263562],"length":1,"stats":{"Line":0}},{"line":615,"address":[3612257,3612181,3612422,3611178],"length":1,"stats":{"Line":0}},{"line":618,"address":[3178913],"length":1,"stats":{"Line":0}},{"line":619,"address":[4264997],"length":1,"stats":{"Line":0}},{"line":624,"address":[3605095],"length":1,"stats":{"Line":0}},{"line":625,"address":[3183200,3172730,3172806,3183225],"length":1,"stats":{"Line":0}},{"line":626,"address":[3172974,3172911],"length":1,"stats":{"Line":0}},{"line":627,"address":[3173074],"length":1,"stats":{"Line":0}},{"line":628,"address":[3173410,3173360,3174010,3173241,3173122],"length":1,"stats":{"Line":0}},{"line":629,"address":[4258595,4258490],"length":1,"stats":{"Line":0}},{"line":630,"address":[3606270],"length":1,"stats":{"Line":0}},{"line":631,"address":[4258698],"length":1,"stats":{"Line":0}},{"line":632,"address":[3606174],"length":1,"stats":{"Line":0}},{"line":633,"address":[4258746],"length":1,"stats":{"Line":0}},{"line":634,"address":[3173730],"length":1,"stats":{"Line":0}},{"line":635,"address":[4258794],"length":1,"stats":{"Line":0}},{"line":639,"address":[3605557],"length":1,"stats":{"Line":0}},{"line":640,"address":[3173177,3174140,3174377,3174212],"length":1,"stats":{"Line":0}},{"line":644,"address":[3173504],"length":1,"stats":{"Line":0}},{"line":645,"address":[3607028],"length":1,"stats":{"Line":0}},{"line":649,"address":[3607076,3605169],"length":1,"stats":{"Line":0}},{"line":650,"address":[3607179,3607082],"length":1,"stats":{"Line":0}},{"line":651,"address":[3174703,3174980],"length":1,"stats":{"Line":0}},{"line":652,"address":[4260029,4260124],"length":1,"stats":{"Line":0}},{"line":654,"address":[3607967,3607678],"length":1,"stats":{"Line":0}},{"line":655,"address":[4260665,4260496,4260583],"length":1,"stats":{"Line":0}},{"line":656,"address":[3175755,3175884,3175602],"length":1,"stats":{"Line":0}},{"line":660,"address":[3607125,3615977,3615968,3608472],"length":1,"stats":{"Line":0}},{"line":661,"address":[3176420,3176098,3176015,3176340],"length":1,"stats":{"Line":0}},{"line":662,"address":[4261600,4261796,4262071,4261727],"length":1,"stats":{"Line":0}},{"line":665,"address":[3610094,3609926,3608554,3609872],"length":1,"stats":{"Line":0}},{"line":668,"address":[3171819],"length":1,"stats":{"Line":0}},{"line":669,"address":[4256859,4267756,4267487,4267417],"length":1,"stats":{"Line":0}},{"line":672,"address":[3177790],"length":1,"stats":{"Line":0}},{"line":675,"address":[3171333],"length":1,"stats":{"Line":0}},{"line":680,"address":[3697650],"length":1,"stats":{"Line":0}},{"line":681,"address":[4270846,4268336],"length":1,"stats":{"Line":0}},{"line":682,"address":[3183343],"length":1,"stats":{"Line":0}},{"line":683,"address":[3616165,3616266],"length":1,"stats":{"Line":0}},{"line":685,"address":[3183626],"length":1,"stats":{"Line":0}},{"line":687,"address":[4269171,4269012,4268800,4268933],"length":1,"stats":{"Line":0}},{"line":688,"address":[4268947,4269344],"length":1,"stats":{"Line":0}},{"line":690,"address":[3616542],"length":1,"stats":{"Line":0}},{"line":691,"address":[3616584,3617160,3617069,3617322],"length":1,"stats":{"Line":0}},{"line":692,"address":[4269383,4269810],"length":1,"stats":{"Line":0}},{"line":695,"address":[3183683],"length":1,"stats":{"Line":0}},{"line":696,"address":[3185375,3183731,3185103,3185012],"length":1,"stats":{"Line":0}},{"line":697,"address":[3185026,3185567],"length":1,"stats":{"Line":0}},{"line":704,"address":[4399082],"length":1,"stats":{"Line":0}},{"line":707,"address":[4399113],"length":1,"stats":{"Line":0}},{"line":708,"address":[3698359,3698767,3698119,3698535,3698013],"length":1,"stats":{"Line":0}},{"line":710,"address":[3698794],"length":1,"stats":{"Line":0}},{"line":711,"address":[2812890,2812761],"length":1,"stats":{"Line":0}},{"line":714,"address":[3699434,3698970],"length":1,"stats":{"Line":0}},{"line":719,"address":[3699728,3699643,3699924,3699553],"length":1,"stats":{"Line":0}},{"line":720,"address":[3700105,3699649],"length":1,"stats":{"Line":0}},{"line":722,"address":[4401280,4401510],"length":1,"stats":{"Line":0}},{"line":725,"address":[2813979],"length":1,"stats":{"Line":0}},{"line":727,"address":[4401570],"length":1,"stats":{"Line":0}},{"line":731,"address":[2820169,2814576,2818881],"length":1,"stats":{"Line":0}},{"line":732,"address":[3701050],"length":1,"stats":{"Line":0}},{"line":733,"address":[4407753,4402178],"length":1,"stats":{"Line":0}},{"line":734,"address":[2820440,2820215],"length":1,"stats":{"Line":0}},{"line":735,"address":[4408021],"length":1,"stats":{"Line":0}},{"line":738,"address":[2814972,2814651,2814805],"length":1,"stats":{"Line":0}},{"line":739,"address":[2814736],"length":1,"stats":{"Line":0}},{"line":742,"address":[3701174],"length":1,"stats":{"Line":0}},{"line":743,"address":[3701561],"length":1,"stats":{"Line":0}},{"line":746,"address":[4402744],"length":1,"stats":{"Line":0}},{"line":747,"address":[4402781],"length":1,"stats":{"Line":0}},{"line":750,"address":[2815402,2815322],"length":1,"stats":{"Line":0}},{"line":751,"address":[3702148],"length":1,"stats":{"Line":0}},{"line":752,"address":[4407626,4403158,4402909,4403181,4402969],"length":1,"stats":{"Line":0}},{"line":753,"address":[4403165,4403151],"length":1,"stats":{"Line":0}},{"line":758,"address":[3702490,3702183],"length":1,"stats":{"Line":0}},{"line":760,"address":[4403556],"length":1,"stats":{"Line":0}},{"line":762,"address":[3703849,3702550],"length":1,"stats":{"Line":0}},{"line":763,"address":[4406411,4407181,4406574,4404907,4406838],"length":1,"stats":{"Line":0}},{"line":765,"address":[2819926,2820055],"length":1,"stats":{"Line":0}},{"line":770,"address":[3703867,3703938],"length":1,"stats":{"Line":0}},{"line":771,"address":[4405773,4405146,4405573,4405309,4405038],"length":1,"stats":{"Line":0}},{"line":773,"address":[3705098,3705243],"length":1,"stats":{"Line":0}},{"line":777,"address":[3705372],"length":1,"stats":{"Line":0}},{"line":780,"address":[4403489],"length":1,"stats":{"Line":0}},{"line":781,"address":[3702572],"length":1,"stats":{"Line":0}},{"line":782,"address":[2816496,2816958,2816694,2816170],"length":1,"stats":{"Line":0}},{"line":784,"address":[3702706,3703644],"length":1,"stats":{"Line":0}},{"line":785,"address":[2817332],"length":1,"stats":{"Line":0}},{"line":789,"address":[3707056],"length":1,"stats":{"Line":0}},{"line":791,"address":[3185872,3185888],"length":1,"stats":{"Line":0}},{"line":795,"address":[2820656],"length":1,"stats":{"Line":0}},{"line":796,"address":[2820664],"length":1,"stats":{"Line":0}},{"line":800,"address":[2820672],"length":1,"stats":{"Line":0}},{"line":805,"address":[4408176],"length":1,"stats":{"Line":0}},{"line":806,"address":[3707198],"length":1,"stats":{"Line":0}},{"line":810,"address":[2820720],"length":1,"stats":{"Line":0}},{"line":811,"address":[3707224],"length":1,"stats":{"Line":0}},{"line":826,"address":[3707531,3707232],"length":1,"stats":{"Line":0}},{"line":828,"address":[3707262],"length":1,"stats":{"Line":0}},{"line":829,"address":[2820775],"length":1,"stats":{"Line":0}},{"line":830,"address":[3707280],"length":1,"stats":{"Line":0}},{"line":831,"address":[3707289],"length":1,"stats":{"Line":0}},{"line":832,"address":[3707308],"length":1,"stats":{"Line":0}},{"line":833,"address":[3707317],"length":1,"stats":{"Line":0}},{"line":834,"address":[3707383],"length":1,"stats":{"Line":0}}],"covered":82,"coverable":403},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","embedding.rs"],"content":"use crate::vectordb::error::VectorDBError;\nuse crate::vectordb::provider::{EmbeddingProvider, OnnxEmbeddingProvider};\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::path::{Path, PathBuf};\n\n// Use the embedding dimensions from the providers\n// use crate::vectordb::provider::fast::FAST_EMBEDDING_DIM;\n\n/// Supported embedding models.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum EmbeddingModelType {\n    /// Use the ONNX model for embeddings.\n    Onnx,\n    // No specific CodeBert type needed if we handle dimensions dynamically\n}\n\nimpl EmbeddingModelType {\n    /// Returns the default embedding dimension for this model type.\n    /// Used as a fallback when loading an index without an explicit dimension stored.\n    pub fn default_dimension(\u0026self) -\u003e usize {\n        match self {\n            // TODO: Make this dynamically configurable or read from a default ONNX model?\n            // For now, assume the default ONNX is MiniLM with 384 dims.\n            EmbeddingModelType::Onnx =\u003e 384,\n        }\n    }\n}\n\nimpl std::fmt::Display for EmbeddingModelType {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            EmbeddingModelType::Onnx =\u003e write!(f, \"ONNX\"),\n        }\n    }\n}\n\nimpl Default for EmbeddingModelType {\n    fn default() -\u003e Self {\n        EmbeddingModelType::Onnx\n    }\n}\n\n/// Model for generating embeddings from text\npub struct EmbeddingModel {\n    provider: Box\u003cdyn EmbeddingProvider + Send + Sync\u003e,\n    model_type: EmbeddingModelType,\n    onnx_model_path: Option\u003cPathBuf\u003e,\n    onnx_tokenizer_path: Option\u003cPathBuf\u003e,\n}\n\nimpl Clone for EmbeddingModel {\n    fn clone(\u0026self) -\u003e Self {\n        // Re-create the provider using stored paths.\n        match self.model_type {\n            EmbeddingModelType::Onnx =\u003e {\n                let model_path = self.onnx_model_path.as_ref()\n                    .expect(\"Missing ONNX model path for cloning\");\n                let tokenizer_path = self.onnx_tokenizer_path.as_ref()\n                    .expect(\"Missing ONNX tokenizer path for cloning\");\n                \n                // Use expect here as cloning implies the original creation succeeded\n                Self::new_onnx(model_path, tokenizer_path)\n                    .expect(\"Failed to re-create ONNX model during clone\")\n            }\n            // Add other types here if needed in the future\n        }\n    }\n}\n\nimpl EmbeddingModel {\n    /// Creates a new EmbeddingModel with the Fast provider\n    /// This provider is much faster but less accurate than ONNX\n    // pub fn new() -\u003e Self {\n    //     let provider = Box::new(FastTextProvider::new());\n    //     Self {\n    //         provider,\n    //         model_type: EmbeddingModelType::Fast,\n    //     }\n    // }\n\n    /// Creates a new EmbeddingModel with the ONNX provider\n    /// This provider is more accurate but slower than Fast\n    pub fn new_onnx(model_path: \u0026Path, tokenizer_path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        let provider = Box::new(OnnxEmbeddingProvider::new(model_path, tokenizer_path)?);\n        Ok(Self {\n            provider,\n            model_type: EmbeddingModelType::Onnx,\n            onnx_model_path: Some(model_path.to_path_buf()),\n            onnx_tokenizer_path: Some(tokenizer_path.to_path_buf()),\n        })\n    }\n\n    /// Convert text to an embedding vector\n    pub fn embed(\u0026self, text: \u0026str) -\u003e Result\u003cVec\u003cf32\u003e, VectorDBError\u003e {\n        self.provider\n            .embed(text)\n            .map_err(|e| VectorDBError::EmbeddingError(e.to_string()))\n    }\n\n    /// Convert multiple texts to embedding vectors\n    pub fn embed_batch(\u0026self, texts: \u0026[\u0026str]) -\u003e Result\u003cVec\u003cVec\u003cf32\u003e\u003e, VectorDBError\u003e {\n        self.provider\n            .embed_batch(texts)\n            .map_err(|e| VectorDBError::EmbeddingError(e.to_string()))\n    }\n\n    /// Get the dimension of the embeddings produced by this model\n    pub fn dim(\u0026self) -\u003e usize {\n        self.provider.dimension()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Removed test_fast_embedding\n    // #[test]\n    // fn test_fast_embedding() { ... }\n\n    // Removed test_embedding_batch (it used the default FastText model)\n    // #[test]\n    // fn test_embedding_batch() { ... }\n\n    // Keep test_onnx_embedding_fallback\n    #[test]\n    fn test_onnx_embedding_fallback() {\n        let model_path = Path::new(\"onnx/all-minilm-l12-v2.onnx\");\n        let tokenizer_path = Path::new(\"onnx/minilm_tokenizer.json\");\n\n        // Skip test if ONNX files don't exist\n        if !model_path.exists() || !tokenizer_path.exists() {\n            println!(\"Skipping ONNX test because model files aren't available\");\n            return;\n        }\n\n        // Create ONNX model\n        let onnx_model = EmbeddingModel::new_onnx(model_path, tokenizer_path);\n        assert!(onnx_model.is_ok());\n\n        let model = onnx_model.unwrap();\n        let expected_dim = model.dim(); // Get dimension from model\n\n        // Test embedding\n        let text = \"fn main() { let x = 42; }\";\n        let embedding = model.embed(text).unwrap();\n\n        assert_eq!(embedding.len(), expected_dim); // Check against model's dimension\n        assert!(!embedding.iter().all(|\u0026x| x == 0.0));\n\n        // Test cloning\n        let cloned_model = model.clone();\n        assert_eq!(cloned_model.dim(), expected_dim);\n        let cloned_embedding = cloned_model.embed(text).unwrap();\n        assert_eq!(embedding, cloned_embedding);\n    }\n\n    // Removed test_model_cloning (it used the default FastText model)\n    // #[test]\n    // fn test_model_cloning() { ... }\n}\n","traces":[{"line":21,"address":[3707296],"length":1,"stats":{"Line":0}},{"line":31,"address":[3167824],"length":1,"stats":{"Line":0}},{"line":33,"address":[3167842],"length":1,"stats":{"Line":0}},{"line":53,"address":[3115472],"length":1,"stats":{"Line":0}},{"line":57,"address":[3167942],"length":1,"stats":{"Line":0}},{"line":59,"address":[3167994],"length":1,"stats":{"Line":0}},{"line":63,"address":[3168050],"length":1,"stats":{"Line":0}},{"line":84,"address":[3168160,3169036,3169017],"length":1,"stats":{"Line":0}},{"line":85,"address":[3168612,3168539,3168229],"length":1,"stats":{"Line":0}},{"line":86,"address":[3168850],"length":1,"stats":{"Line":0}},{"line":87,"address":[3168552],"length":1,"stats":{"Line":0}},{"line":89,"address":[3116150,3116262],"length":1,"stats":{"Line":0}},{"line":90,"address":[3168802,3168737],"length":1,"stats":{"Line":0}},{"line":95,"address":[3169088],"length":1,"stats":{"Line":0}},{"line":96,"address":[3116672],"length":1,"stats":{"Line":0}},{"line":98,"address":[3734464,3734482],"length":1,"stats":{"Line":0}},{"line":102,"address":[3169168],"length":1,"stats":{"Line":0}},{"line":103,"address":[3169200],"length":1,"stats":{"Line":0}},{"line":105,"address":[3734642,3734624],"length":1,"stats":{"Line":0}},{"line":109,"address":[3169248],"length":1,"stats":{"Line":0}},{"line":110,"address":[3169256],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","error.rs"],"content":"use std::io;\nuse std::path::PathBuf;\nuse thiserror::Error;\n// use syn;\nuse anyhow;\n\n/// Result type for VectorDB operations\npub type Result\u003cT\u003e = std::result::Result\u003cT, VectorDBError\u003e;\n\n/// Errors that can occur in the VectorDB system\n#[derive(Error, Debug)]\npub enum VectorDBError {\n    #[error(\"File not found: {0}\")]\n    FileNotFound(String),\n\n    #[error(\"Failed to read file {path}: {source}\")]\n    FileReadError { path: PathBuf, source: io::Error },\n\n    #[error(\"Failed to write file {path}: {source}\")]\n    FileWriteError { path: PathBuf, source: io::Error },\n\n    #[error(\"Failed to create directory {path}: {source}\")]\n    DirectoryCreationError { path: PathBuf, source: io::Error },\n\n    #[error(\"Failed to access file metadata for {path}: {source}\")]\n    MetadataError { path: PathBuf, source: io::Error },\n\n    #[error(\"Error serializing or deserializing data: {0}\")]\n    SerializationError(#[from] serde_json::Error),\n\n    #[error(\"Error generating embedding: {0}\")]\n    EmbeddingError(String),\n\n    #[error(\"Database error: {0}\")]\n    DatabaseError(String),\n\n    #[error(\"AST traversal error: {0}\")]\n    ASTTraversalError(String),\n\n    #[error(\"Invalid parameter: {0}\")]\n    InvalidParameter(String),\n\n    #[error(\"Invalid path: {0}\")]\n    InvalidPath(String),\n\n    #[error(\"Cache error: {0}\")]\n    CacheError(String),\n\n    #[error(\"Parser error: {0}\")]\n    ParserError(String),\n\n    #[error(\"Unsupported language: {0}\")]\n    UnsupportedLanguage(String),\n\n    #[error(\"HNSW index error: {0}\")]\n    HNSWError(String),\n\n    #[error(\"IO error: {0}\")]\n    IOError(#[from] io::Error),\n\n    #[error(\"Code analysis error: {0}\")]\n    CodeAnalysisError(String),\n\n    #[error(\"General error: {0}\")]\n    GeneralError(String),\n\n    #[error(\"Directory not found: {0}\")]\n    DirectoryNotFound(String),\n\n    #[error(\"Repository error: {0}\")]\n    RepositoryError(String),\n\n    #[error(\"Repository not found: {0}\")]\n    RepositoryNotFound(String),\n\n    #[error(\"Error deserializing data: {0}\")]\n    DeserializationError(String),\n\n    #[error(\"Search error: {0}\")]\n    SearchError(String),\n\n    #[error(\"Other error: {0}\")]\n    Other(String),\n\n    #[error(\"Configuration error: {0}\")]\n    ConfigurationError(String),\n\n    #[error(\"Dimension mismatch: Expected {expected}, found {found}\")]\n    DimensionMismatch { expected: usize, found: usize },\n\n    #[error(\"Indexing error: {0}\")]\n    IndexingError(String),\n}\n\n/// Conversion from anyhow::Error\nimpl From\u003canyhow::Error\u003e for VectorDBError {\n    fn from(error: anyhow::Error) -\u003e Self {\n        VectorDBError::HNSWError(error.to_string())\n    }\n}\n\n// Add Clone implementation for VectorDBError to support parallel processing\nimpl Clone for VectorDBError {\n    fn clone(\u0026self) -\u003e Self {\n        match self {\n            Self::FileNotFound(s) =\u003e Self::FileNotFound(s.clone()),\n            Self::FileReadError { path, source } =\u003e Self::FileReadError {\n                path: path.clone(),\n                source: io::Error::new(source.kind(), source.to_string()),\n            },\n            Self::FileWriteError { path, source } =\u003e Self::FileWriteError {\n                path: path.clone(),\n                source: io::Error::new(source.kind(), source.to_string()),\n            },\n            Self::DirectoryCreationError { path, source } =\u003e Self::DirectoryCreationError {\n                path: path.clone(),\n                source: io::Error::new(source.kind(), source.to_string()),\n            },\n            Self::MetadataError { path, source } =\u003e Self::MetadataError {\n                path: path.clone(),\n                source: io::Error::new(source.kind(), source.to_string()),\n            },\n            // Create new serialization error with the string representation\n            Self::SerializationError(e) =\u003e Self::SerializationError(\n                serde_json::from_str::\u003cserde_json::Value\u003e(\u0026format!(\"\\\"{}\\\"\", e)).unwrap_err(),\n            ),\n            Self::EmbeddingError(s) =\u003e Self::EmbeddingError(s.clone()),\n            Self::DatabaseError(s) =\u003e Self::DatabaseError(s.clone()),\n            Self::ASTTraversalError(s) =\u003e Self::ASTTraversalError(s.clone()),\n            Self::InvalidParameter(s) =\u003e Self::InvalidParameter(s.clone()),\n            Self::InvalidPath(s) =\u003e Self::InvalidPath(s.clone()),\n            Self::CacheError(s) =\u003e Self::CacheError(s.clone()),\n            Self::ParserError(s) =\u003e Self::ParserError(s.clone()),\n            Self::UnsupportedLanguage(s) =\u003e Self::UnsupportedLanguage(s.clone()),\n            Self::HNSWError(s) =\u003e Self::HNSWError(s.clone()),\n            Self::IOError(e) =\u003e Self::IOError(io::Error::new(e.kind(), e.to_string())),\n            Self::CodeAnalysisError(s) =\u003e Self::CodeAnalysisError(s.clone()),\n            Self::GeneralError(s) =\u003e Self::GeneralError(s.clone()),\n            Self::DirectoryNotFound(s) =\u003e Self::DirectoryNotFound(s.clone()),\n            Self::RepositoryError(s) =\u003e Self::RepositoryError(s.clone()),\n            Self::RepositoryNotFound(s) =\u003e Self::RepositoryNotFound(s.clone()),\n            Self::DeserializationError(s) =\u003e Self::DeserializationError(s.clone()),\n            Self::SearchError(s) =\u003e Self::SearchError(s.clone()),\n            Self::Other(s) =\u003e Self::Other(s.clone()),\n            Self::ConfigurationError(s) =\u003e Self::ConfigurationError(s.clone()),\n            Self::DimensionMismatch { expected, found } =\u003e Self::DimensionMismatch {\n                expected: *expected,\n                found: *found,\n            },\n            Self::IndexingError(s) =\u003e Self::IndexingError(s.clone()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io;\n\n    #[test]\n    fn test_error_conversion() {\n        let io_error = io::Error::new(io::ErrorKind::NotFound, \"test file not found\");\n        let db_error = VectorDBError::from(io_error);\n\n        match db_error {\n            VectorDBError::IOError(_) =\u003e assert!(true),\n            _ =\u003e assert!(false, \"Expected IOError conversion\"),\n        }\n\n        // Test manual creation for specific error kinds\n        let db_error = VectorDBError::FileNotFound(\"test file not found\".to_string());\n\n        match db_error {\n            VectorDBError::FileNotFound(_) =\u003e assert!(true),\n            _ =\u003e assert!(false, \"Expected FileNotFound type\"),\n        }\n    }\n\n    #[test]\n    fn test_error_display() {\n        let error = VectorDBError::FileNotFound(\"test.txt\".to_string());\n        assert!(error.to_string().contains(\"test.txt\"));\n    }\n\n    #[test]\n    fn test_parser_error() {\n        let error = VectorDBError::ParserError(\"Failed to parse file\".to_string());\n        let err_string = error.to_string();\n        assert!(err_string.contains(\"Failed to parse file\"));\n    }\n\n    #[test]\n    fn test_dimension_mismatch_error() {\n        let error = VectorDBError::DimensionMismatch { expected: 10, found: 5 };\n        let err_string = error.to_string();\n        assert!(err_string.contains(\"Dimension mismatch: Expected 10, found 5\"));\n\n        let cloned_error = error.clone();\n        match cloned_error {\n            VectorDBError::DimensionMismatch { expected, found } =\u003e {\n                assert_eq!(expected, 10);\n                assert_eq!(found, 5);\n            }\n            _ =\u003e panic!(\"Expected DimensionMismatch error after cloning\"),\n        }\n    }\n}\n","traces":[{"line":97,"address":[3449376,3449248],"length":1,"stats":{"Line":0}},{"line":98,"address":[3449321,3449277],"length":1,"stats":{"Line":0}},{"line":104,"address":[3862908,3860160],"length":1,"stats":{"Line":2}},{"line":105,"address":[3860199],"length":1,"stats":{"Line":2}},{"line":106,"address":[3860244],"length":1,"stats":{"Line":0}},{"line":108,"address":[3860377],"length":1,"stats":{"Line":0}},{"line":109,"address":[3860390,3862790],"length":1,"stats":{"Line":0}},{"line":112,"address":[3449703],"length":1,"stats":{"Line":0}},{"line":113,"address":[3846273,3848784],"length":1,"stats":{"Line":0}},{"line":116,"address":[3449775],"length":1,"stats":{"Line":0}},{"line":117,"address":[3449785,3452388],"length":1,"stats":{"Line":0}},{"line":120,"address":[3846407],"length":1,"stats":{"Line":0}},{"line":121,"address":[3452552,3449857],"length":1,"stats":{"Line":0}},{"line":125,"address":[3860825,3860714,3863473],"length":1,"stats":{"Line":0}},{"line":127,"address":[3860853],"length":1,"stats":{"Line":0}},{"line":128,"address":[3860943],"length":1,"stats":{"Line":0}},{"line":129,"address":[3861033],"length":1,"stats":{"Line":0}},{"line":130,"address":[3846931],"length":1,"stats":{"Line":0}},{"line":131,"address":[3847021],"length":1,"stats":{"Line":0}},{"line":132,"address":[3861303],"length":1,"stats":{"Line":0}},{"line":133,"address":[3847201],"length":1,"stats":{"Line":0}},{"line":134,"address":[3450731],"length":1,"stats":{"Line":0}},{"line":135,"address":[3450821],"length":1,"stats":{"Line":0}},{"line":136,"address":[3450911],"length":1,"stats":{"Line":0}},{"line":137,"address":[3861764],"length":1,"stats":{"Line":0}},{"line":138,"address":[3451102],"length":1,"stats":{"Line":0}},{"line":139,"address":[3861944],"length":1,"stats":{"Line":0}},{"line":140,"address":[3862034],"length":1,"stats":{"Line":0}},{"line":141,"address":[3862124],"length":1,"stats":{"Line":0}},{"line":142,"address":[3451462],"length":1,"stats":{"Line":0}},{"line":143,"address":[3862304],"length":1,"stats":{"Line":0}},{"line":144,"address":[3862394],"length":1,"stats":{"Line":0}},{"line":145,"address":[3862484],"length":1,"stats":{"Line":0}},{"line":147,"address":[3862612],"length":1,"stats":{"Line":2}},{"line":148,"address":[3862616],"length":1,"stats":{"Line":2}},{"line":150,"address":[3862645],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":36},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","hnsw.rs"],"content":"use anyhow::Result;\nuse rand::rngs::StdRng;\nuse rand::{Rng, SeedableRng};\nuse rayon::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse std::collections::{HashMap, HashSet};\nuse std::fs;\nuse std::path::Path;\n\n/// Configuration parameters for HNSW index\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HNSWConfig {\n    #[serde(default = \"default_dimension\")]\n    pub dimension: usize,\n    #[serde(default = \"default_m\")]\n    pub m: usize,\n    #[serde(default = \"default_ef_construction\")]\n    pub ef_construction: usize,\n    #[serde(default = \"default_num_layers\")]\n    pub num_layers: usize,\n    #[serde(default = \"default_random_seed\")]\n    pub random_seed: u64,\n}\n\n// Helper functions for serde defaults, returning values from HNSWConfig::default()\nfn default_dimension() -\u003e usize { HNSWConfig::default().dimension }\nfn default_m() -\u003e usize { HNSWConfig::default().m }\nfn default_ef_construction() -\u003e usize { HNSWConfig::default().ef_construction }\nfn default_num_layers() -\u003e usize { HNSWConfig::default().num_layers }\nfn default_random_seed() -\u003e u64 { HNSWConfig::default().random_seed }\n\nimpl Default for HNSWConfig {\n    fn default() -\u003e Self {\n        Self {\n            dimension: 128,\n            m: 16,\n            ef_construction: 200,\n            num_layers: 1, // Start with 1, might need adjustment based on data size\n            random_seed: 42,\n        }\n    }\n}\n\nimpl HNSWConfig {\n    /// Creates a new HNSWConfig with the specified dimension and default values for other parameters.\n    pub fn new(dimension: usize) -\u003e Self {\n        assert!(dimension \u003e 0, \"Dimension must be positive\");\n        Self {\n            dimension,\n            ..Self::default() // Use default values for other fields\n        }\n    }\n\n    // Removed unused function calculate_optimal_layers\n    // pub fn calculate_optimal_layers(dataset_size: usize) -\u003e usize { ... }\n}\n\n/// Represents a node in the HNSW graph\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HNSWNode {\n    /// The vector embedding\n    pub vector: Vec\u003cf32\u003e,\n    /// Layer connections for each layer\n    pub connections: Vec\u003cVec\u003cusize\u003e\u003e,\n    /// Maximum layer this node appears in\n    pub max_layer: usize,\n}\n\nimpl HNSWNode {\n    pub fn new(vector: Vec\u003cf32\u003e, max_layer: usize) -\u003e Self {\n        Self {\n            vector,\n            connections: vec![Vec::new(); max_layer + 1],\n            max_layer,\n        }\n    }\n}\n\n/// The main HNSW index structure\n#[derive(Clone)]\npub struct HNSWIndex {\n    /// Configuration parameters\n    config: HNSWConfig,\n    /// The actual graph structure\n    nodes: Vec\u003cHNSWNode\u003e,\n    /// Entry point node indices for each layer\n    entry_points: Vec\u003cusize\u003e,\n}\n\n/// Serializable representation of the HNSW index\n#[derive(Serialize, Deserialize)]\nstruct SerializedHNSWIndex {\n    config: HNSWConfig,\n    nodes: Vec\u003cHNSWNode\u003e,\n    entry_points: Vec\u003cusize\u003e,\n}\n\nimpl HNSWIndex {\n    pub fn new(config: HNSWConfig) -\u003e Self {\n        assert!(config.dimension \u003e 0, \"HNSW dimension must be positive\");\n        let num_layers = config.num_layers;\n        Self {\n            config,\n            nodes: Vec::new(),\n            entry_points: vec![0; num_layers],\n        }\n    }\n\n    /// Calculate cosine distance between two vectors (range 0.0 to 2.0)\n    fn cosine_distance(a: \u0026[f32], b: \u0026[f32]) -\u003e f32 {\n        let dot_product: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();\n        let norm_a: f32 = a.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n        let norm_b: f32 = b.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n\n        // Handle zero vectors to avoid division by zero and return max distance\n        if norm_a == 0.0 || norm_b == 0.0 {\n            return 2.0; // Max distance for cosine\n        }\n\n        // Calculate cosine similarity\n        let similarity = dot_product / (norm_a * norm_b);\n\n        // Clamp similarity to [-1.0, 1.0] to handle potential floating point inaccuracies\n        let clamped_similarity = similarity.clamp(-1.0, 1.0);\n\n        // Convert similarity to distance: distance = 1.0 - similarity\n        // This results in a distance range of [0.0, 2.0]\n        // Identical vectors (similarity 1.0) -\u003e distance 0.0\n        // Opposite vectors (similarity -1.0) -\u003e distance 2.0\n        1.0 - clamped_similarity\n    }\n\n    /// Generate a random layer for a new node\n    fn random_layer(\u0026self) -\u003e usize {\n        let mut rng = StdRng::seed_from_u64(self.config.random_seed);\n        let mut layer = 0;\n        while layer \u003c self.config.num_layers - 1 \u0026\u0026 rng.gen::\u003cf32\u003e() \u003c 0.5 {\n            layer += 1;\n        }\n        layer\n    }\n\n    /// Find the nearest neighbors in a given layer\n    fn search_layer(\n        \u0026self,\n        query: \u0026[f32],\n        entry_point: usize,\n        ef: usize,\n        layer: usize,\n    ) -\u003e Vec\u003c(usize, f32)\u003e {\n        let mut candidates = HashSet::new();\n        let mut results = Vec::new();\n        let mut distances = HashMap::new();\n\n        // Initialize with entry point\n        let entry_dist = Self::cosine_distance(query, \u0026self.nodes[entry_point].vector);\n        candidates.insert(entry_point);\n        distances.insert(entry_point, entry_dist);\n        results.push((entry_point, entry_dist));\n\n        while !candidates.is_empty() {\n            // Find the closest candidate\n            let current = match candidates.iter().min_by(|\u0026\u0026a, \u0026\u0026b| {\n                distances[\u0026a]\n                    .partial_cmp(\u0026distances[\u0026b])\n                    .unwrap_or(std::cmp::Ordering::Equal)\n            }) {\n                Some(\u0026c) =\u003e c,\n                None =\u003e break,\n            };\n            candidates.remove(\u0026current);\n\n            // Add to results if it's better than our current worst result\n            let worst_dist = results.last().map_or(f32::INFINITY, |\u0026(_, dist)| dist);\n            if results.len() \u003c ef || distances[\u0026current] \u003c worst_dist {\n                results.push((current, distances[\u0026current]));\n                results.sort_by(|a, b| a.1.partial_cmp(\u0026b.1).unwrap_or(std::cmp::Ordering::Equal));\n                if results.len() \u003e ef {\n                    results.pop();\n                }\n            }\n\n            // Explore neighbors\n            for \u0026neighbor in \u0026self.nodes[current].connections[layer] {\n                if !distances.contains_key(\u0026neighbor) {\n                    let dist = Self::cosine_distance(query, \u0026self.nodes[neighbor].vector);\n                    distances.insert(neighbor, dist);\n\n                    let worst_dist = results.last().map_or(f32::INFINITY, |\u0026(_, d)| d);\n                    if results.len() \u003c ef || dist \u003c worst_dist {\n                        candidates.insert(neighbor);\n                    }\n                }\n            }\n        }\n\n        results\n    }\n\n    /// Insert a new vector into the index\n    pub fn insert(\u0026mut self, vector: Vec\u003cf32\u003e) -\u003e Result\u003cusize\u003e {\n        if vector.len() != self.config.dimension {\n            return Err(anyhow::anyhow!(\n                \"Invalid vector dimension: expected {}, got {}\",\n                self.config.dimension,\n                vector.len()\n            ));\n        }\n\n        let max_layer = self.random_layer();\n        let node = HNSWNode::new(vector, max_layer);\n        let node_idx = self.nodes.len();\n\n        // If this is the first node, set it as entry point for all layers\n        if node_idx == 0 {\n            self.nodes.push(node);\n            return Ok(node_idx);\n        }\n\n        self.nodes.push(node);\n\n        // Start from top layer and work down\n        let mut current_entry = self.entry_points[max_layer];\n        for layer in (0..=max_layer).rev() {\n            let neighbors = self.search_layer(\n                \u0026self.nodes[node_idx].vector,\n                current_entry,\n                self.config.ef_construction,\n                layer,\n            );\n\n            // Select neighbors to connect to\n            let selected = neighbors\n                .into_iter()\n                .take(self.config.m)\n                .map(|(idx, _)| idx)\n                .collect::\u003cVec\u003c_\u003e\u003e();\n\n            // Add bidirectional connections\n            for \u0026neighbor in \u0026selected {\n                self.nodes[node_idx].connections[layer].push(neighbor);\n                self.nodes[neighbor].connections[layer].push(node_idx);\n            }\n\n            // Update entry point for this layer if the new node is closer to query\n            if !selected.is_empty() {\n                let current_dist = Self::cosine_distance(\n                    \u0026self.nodes[current_entry].vector,\n                    \u0026self.nodes[node_idx].vector,\n                );\n                let best_dist = Self::cosine_distance(\n                    \u0026self.nodes[selected[0]].vector,\n                    \u0026self.nodes[node_idx].vector,\n                );\n                if best_dist \u003c current_dist {\n                    self.entry_points[layer] = selected[0];\n                    current_entry = selected[0];\n                }\n            }\n        }\n\n        Ok(node_idx)\n    }\n\n    /// Search for the k nearest neighbors of a query vector in parallel\n    pub fn search_parallel(\u0026self, query: \u0026[f32], k: usize, ef: usize) -\u003e Result\u003cVec\u003c(usize, f32)\u003e\u003e {\n        if query.len() != self.config.dimension {\n            return Err(anyhow::anyhow!(\n                \"Invalid query vector dimension: expected {}, got {}\",\n                self.config.dimension,\n                query.len()\n            ));\n        }\n\n        if self.nodes.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        // Find the highest layer where we have nodes\n        let mut max_layer = 0;\n        for node in \u0026self.nodes {\n            max_layer = max_layer.max(node.max_layer);\n        }\n\n        // We'll use thread-local storage for the current entry and distance\n        let mut current_entry = self.entry_points[max_layer.min(self.entry_points.len() - 1)];\n        let mut current_dist = Self::cosine_distance(query, \u0026self.nodes[current_entry].vector);\n\n        // Traverse the upper layers sequentially (they're small anyway)\n        for layer in (1..=max_layer).rev() {\n            let neighbors = self.search_layer(query, current_entry, ef, layer);\n            if let Some((idx, dist)) = neighbors.first() {\n                if *dist \u003c current_dist {\n                    current_entry = *idx;\n                    current_dist = *dist;\n                }\n            }\n        }\n\n        // Search the bottom layer (level 0) in parallel for better performance\n        // First, get all the neighbors of the entry point to use as starting points\n        let initial_candidates =\n            self.search_layer(query, current_entry, ef.max(self.config.m * 2), 0);\n\n        // If we have very few candidates, just return them\n        if initial_candidates.len() \u003c= k {\n            return Ok(initial_candidates);\n        }\n\n        // Take only the top candidates as starting points\n        let starting_points: Vec\u003cusize\u003e = initial_candidates\n            .iter()\n            .take(self.config.m.min(4))\n            .map(|(idx, _)| *idx)\n            .collect();\n\n        // Search from each starting point in parallel\n        let results: Vec\u003cVec\u003c(usize, f32)\u003e\u003e = starting_points\n            .par_iter()\n            .map(|\u0026start_idx| self.search_layer(query, start_idx, ef / starting_points.len(), 0))\n            .collect();\n\n        // Merge results\n        let mut merged = Vec::new();\n        for result_set in results {\n            for result in result_set {\n                merged.push(result);\n            }\n        }\n\n        // De-duplicate by node index\n        let mut seen = HashSet::new();\n        let mut unique_results = Vec::new();\n\n        for (idx, dist) in merged {\n            if seen.insert(idx) {\n                unique_results.push((idx, dist));\n            }\n        }\n\n        // Sort by distance\n        unique_results.sort_by(|a, b| a.1.partial_cmp(\u0026b.1).unwrap_or(std::cmp::Ordering::Equal));\n\n        // Take top k\n        Ok(unique_results.into_iter().take(k).collect())\n    }\n\n    /// Get statistics about the index\n    pub fn stats(\u0026self) -\u003e HNSWStats {\n        let mut layer_stats = Vec::new();\n        for layer in 0..self.config.num_layers {\n            let mut connections = 0;\n            let mut nodes_in_layer = 0;\n            for node in \u0026self.nodes {\n                if layer \u003c= node.max_layer {\n                    nodes_in_layer += 1;\n                    connections += node.connections[layer].len();\n                }\n            }\n            layer_stats.push(LayerStats {\n                nodes: nodes_in_layer,\n                avg_connections: if nodes_in_layer \u003e 0 {\n                    connections as f32 / nodes_in_layer as f32\n                } else {\n                    0.0\n                },\n            });\n        }\n\n        HNSWStats {\n            total_nodes: self.nodes.len(),\n            layers: self.config.num_layers,\n            layer_stats,\n        }\n    }\n\n    /// Get the configuration of this index\n    pub fn get_config(\u0026self) -\u003e HNSWConfig {\n        self.config.clone()\n    }\n\n    /// Save the index to a file\n    pub fn save_to_file(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        let serialized = SerializedHNSWIndex {\n            config: self.config.clone(),\n            nodes: self.nodes.clone(),\n            entry_points: self.entry_points.clone(),\n        };\n\n        // First serialize to a string\n        let data = serde_json::to_string_pretty(\u0026serialized)?;\n\n        // Create parent directories if they don't exist\n        if let Some(parent) = path.parent() {\n            fs::create_dir_all(parent)?;\n        }\n\n        // Write to the file\n        fs::write(path, data)?;\n\n        Ok(())\n    }\n\n    /// Load an index from a file\n    pub fn load_from_file(path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        let data = fs::read_to_string(path)?;\n        let serialized: SerializedHNSWIndex = serde_json::from_str(\u0026data)?;\n\n        Ok(Self {\n            config: serialized.config,\n            nodes: serialized.nodes,\n            entry_points: serialized.entry_points,\n        })\n    }\n}\n\n/// Statistics for a single layer in the HNSW index\n#[derive(Debug, Clone)]\npub struct LayerStats {\n    /// Number of nodes in this layer\n    pub nodes: usize,\n    /// Average number of connections per node in this layer\n    pub avg_connections: f32,\n}\n\n/// Overall statistics for the HNSW index\n#[derive(Debug, Clone)]\npub struct HNSWStats {\n    /// Total number of nodes in the index\n    pub total_nodes: usize,\n    /// Number of layers in the index\n    pub layers: usize,\n    /// Statistics for each layer\n    pub layer_stats: Vec\u003cLayerStats\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::{Duration, Instant};\n    const TEST_DIM: usize = 4;\n\n    fn test_config() -\u003e HNSWConfig {\n        HNSWConfig {\n            dimension: TEST_DIM,\n            m: 8,\n            ef_construction: 100,\n            num_layers: 4,\n            random_seed: 42,\n        }\n    }\n\n    #[test]\n    fn test_cosine_distance() {\n        // Vectors pointing in opposite directions should have maximum distance\n        let v1 = vec![1.0, 0.0];\n        let v2 = vec![-1.0, 0.0];\n        let dist = HNSWIndex::cosine_distance(\u0026v1, \u0026v2);\n        // With our scaling, the maximum distance is now 1.0\n        // but transformed with (1.0 - similarity) * 1.2 and then power scaling of 0.8\n        // so the maximum value is (1.0 - (-1.0)) * 1.2 = 2.4, transformed with 2.4^0.8 ≈ 1.89\n        // We just check that it's close to 2.0\n        assert!(\n            dist \u003e 1.5,\n            \"Distance between opposite vectors should be high, got {}\",\n            dist\n        );\n\n        // Identical vectors should have zero distance\n        let v3 = vec![1.0, 0.0];\n        let dist = HNSWIndex::cosine_distance(\u0026v1, \u0026v3);\n        assert_eq!(dist, 0.0);\n\n        // Orthogonal vectors should have a mid-range distance\n        let v4 = vec![0.0, 1.0];\n        let dist = HNSWIndex::cosine_distance(\u0026v1, \u0026v4);\n        // With our scaling, the 90° distance is transformed with (1.0 - 0.0) * 1.2 = 1.2, then 1.2^0.8 ≈ 1.15\n        // We verify it's in the expected range\n        assert!(\n            dist \u003e 0.9 \u0026\u0026 dist \u003c 1.3,\n            \"Distance between orthogonal vectors should be moderate, got {}\",\n            dist\n        );\n    }\n\n    #[test]\n    fn test_node_creation() {\n        let vector = vec![1.0; TEST_DIM];\n        let node = HNSWNode::new(vector, 3);\n        assert_eq!(node.max_layer, 3);\n        assert_eq!(node.connections.len(), 4);\n    }\n\n    #[test]\n    fn test_insertion() {\n        let config = test_config();\n        let mut index = HNSWIndex::new(config);\n\n        let v1 = vec![1.0; TEST_DIM];\n        let v2 = vec![0.0; TEST_DIM];\n        let v3 = vec![0.5; TEST_DIM];\n\n        let idx1 = index.insert(v1).unwrap();\n        let idx2 = index.insert(v2).unwrap();\n        let idx3 = index.insert(v3).unwrap();\n\n        assert_eq!(idx1, 0);\n        assert_eq!(idx2, 1);\n        assert_eq!(idx3, 2);\n\n        assert_eq!(index.nodes.len(), 3);\n        assert_eq!(index.nodes[0].vector.len(), TEST_DIM);\n\n        let wrong_dim_vec = vec![1.0; TEST_DIM + 1];\n        assert!(index.insert(wrong_dim_vec).is_err());\n    }\n\n    #[test]\n    fn test_search() {\n        let config = test_config();\n        let mut index = HNSWIndex::new(config);\n\n        let v1 = vec![1.0; TEST_DIM];\n        let v2 = vec![0.0; TEST_DIM];\n        let v3 = vec![0.5; TEST_DIM];\n\n        index.insert(v1).unwrap();\n        index.insert(v2).unwrap();\n        index.insert(v3).unwrap();\n\n        let query = vec![0.8; TEST_DIM];\n        let results = index.search_parallel(\u0026query, 2, 10).unwrap();\n\n        assert_eq!(results.len(), 2);\n        println!(\"Search results: {:?}\", results);\n\n        let wrong_dim_query = vec![0.8; TEST_DIM + 1];\n        assert!(index.search_parallel(\u0026wrong_dim_query, 2, 10).is_err());\n    }\n\n    #[test]\n    fn test_stats() {\n        let config = test_config();\n        let mut index = HNSWIndex::new(config.clone());\n\n        for i in 0..5 {\n            let v = vec![i as f32; TEST_DIM];\n            index.insert(v).unwrap();\n        }\n\n        let stats = index.stats();\n        assert_eq!(stats.total_nodes, 5);\n        assert_eq!(stats.layers, config.num_layers);\n        assert_eq!(stats.layer_stats.len(), config.num_layers);\n        assert_eq!(index.config.dimension, TEST_DIM);\n    }\n\n    fn benchmark\u003cF\u003e(name: \u0026str, iterations: u32, mut f: F) -\u003e Duration\n    where\n        F: FnMut() -\u003e (),\n    {\n        // Warm up\n        for _ in 0..5 {\n            f();\n        }\n\n        let start = Instant::now();\n        for _ in 0..iterations {\n            f();\n        }\n        let elapsed = start.elapsed();\n\n        println!(\n            \"{} took {:?} for {} iterations ({:?} per iteration)\",\n            name,\n            elapsed,\n            iterations,\n            elapsed / iterations\n        );\n\n        elapsed\n    }\n\n    #[test]\n    #[ignore]\n    fn benchmark_linear_vs_hnsw() {\n        let test_dim = 16;\n        let num_vectors = 1000;\n        let num_queries = 10;\n        let k = 10;\n\n        let mut vectors = Vec::with_capacity(num_vectors);\n        for _ in 0..num_vectors {\n            let mut v = vec![0.0; test_dim];\n            for j in 0..test_dim { v[j] = rand::random::\u003cf32\u003e(); }\n            let norm: f32 = v.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n            if norm \u003e 0.0 { for j in 0..test_dim { v[j] /= norm; } }\n            vectors.push(v);\n        }\n\n        let mut queries = Vec::with_capacity(num_queries);\n        for _ in 0..num_queries {\n            let mut q = vec![0.0; test_dim];\n            for j in 0..test_dim { q[j] = rand::random::\u003cf32\u003e(); }\n            let norm: f32 = q.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n            if norm \u003e 0.0 { for j in 0..test_dim { q[j] /= norm; } }\n            queries.push(q);\n        }\n\n        let config = HNSWConfig {\n            dimension: test_dim,\n            m: 16,\n            ef_construction: 200,\n            num_layers: 4,\n            random_seed: 42,\n        };\n        let mut hnsw_index = HNSWIndex::new(config);\n\n        for v in \u0026vectors { hnsw_index.insert(v.clone()).unwrap(); }\n\n        let linear_search = |query: \u0026[f32], k: usize| -\u003e Vec\u003c(usize, f32)\u003e {\n            let mut distances: Vec\u003c(usize, f32)\u003e = vectors\n                .iter()\n                .enumerate()\n                .map(|(i, vector)| (i, HNSWIndex::cosine_distance(query, vector)))\n                .collect();\n            distances.sort_by(|a, b| a.1.partial_cmp(\u0026b.1).unwrap_or(std::cmp::Ordering::Equal));\n            distances.into_iter().take(k).collect()\n        };\n\n        let mut query_idx = 0;\n        let linear_time = benchmark(\"Linear search\", num_queries as u32, || {\n            let query = \u0026queries[query_idx];\n            let _ = linear_search(query, k);\n            query_idx = (query_idx + 1) % num_queries;\n        });\n\n        query_idx = 0;\n        let hnsw_time = benchmark(\"HNSW search\", num_queries as u32, || {\n            let query = \u0026queries[query_idx];\n            let _ = hnsw_index.search_parallel(query, k, 100).unwrap();\n            query_idx = (query_idx + 1) % num_queries;\n        });\n\n        println!(\n            \"HNSW is {:.2}x faster than linear search\",\n            linear_time.as_nanos() as f64 / hnsw_time.as_nanos() as f64\n        );\n        \n        for query in \u0026queries {\n            let linear_results = linear_search(query, k);\n            let hnsw_results = hnsw_index.search_parallel(query, k, 100).unwrap();\n            let mut found = 0;\n            let linear_ids: HashSet\u003cusize\u003e = linear_results.iter().map(|(idx, _)| *idx).collect();\n            for (idx, _) in hnsw_results {\n                if linear_ids.contains(\u0026idx) { found += 1; }\n            }\n            let recall = found as f32 / k as f32;\n            println!(\"Recall@{}: {:.2}\", k, recall);\n            assert!(recall \u003e= 0.7, \"HNSW search quality is too low: {:.2}\", recall);\n        }\n    }\n}\n","traces":[{"line":26,"address":[4105108,4105104],"length":1,"stats":{"Line":0}},{"line":27,"address":[4191220,4191216],"length":1,"stats":{"Line":0}},{"line":28,"address":[3243856,3243860],"length":1,"stats":{"Line":0}},{"line":29,"address":[3243888,3243892],"length":1,"stats":{"Line":0}},{"line":30,"address":[4105232,4105236],"length":1,"stats":{"Line":0}},{"line":33,"address":[3243952],"length":1,"stats":{"Line":6}},{"line":46,"address":[3244000],"length":1,"stats":{"Line":0}},{"line":47,"address":[4191422],"length":1,"stats":{"Line":0}},{"line":70,"address":[3244475,3244160],"length":1,"stats":{"Line":2}},{"line":73,"address":[4105580,4105768,4105521],"length":1,"stats":{"Line":4}},{"line":99,"address":[3244771,3244496],"length":1,"stats":{"Line":6}},{"line":100,"address":[3244518],"length":1,"stats":{"Line":6}},{"line":101,"address":[4191968],"length":1,"stats":{"Line":6}},{"line":104,"address":[4191990],"length":1,"stats":{"Line":6}},{"line":105,"address":[4105924],"length":1,"stats":{"Line":4}},{"line":110,"address":[4106128],"length":1,"stats":{"Line":2}},{"line":111,"address":[3826875,3826832],"length":1,"stats":{"Line":6}},{"line":112,"address":[4106304],"length":1,"stats":{"Line":6}},{"line":113,"address":[3271296,3271310],"length":1,"stats":{"Line":6}},{"line":116,"address":[3245088],"length":1,"stats":{"Line":2}},{"line":117,"address":[3245116],"length":1,"stats":{"Line":6}},{"line":121,"address":[3245150],"length":1,"stats":{"Line":2}},{"line":124,"address":[3245167],"length":1,"stats":{"Line":2}},{"line":130,"address":[4106535],"length":1,"stats":{"Line":2}},{"line":134,"address":[4106576],"length":1,"stats":{"Line":6}},{"line":135,"address":[4106596],"length":1,"stats":{"Line":6}},{"line":136,"address":[3245267],"length":1,"stats":{"Line":6}},{"line":137,"address":[4106712,4106772,4106628],"length":1,"stats":{"Line":18}},{"line":138,"address":[4192786,4192824],"length":1,"stats":{"Line":6}},{"line":140,"address":[3245352],"length":1,"stats":{"Line":6}},{"line":144,"address":[3245456,3247337,3247310],"length":1,"stats":{"Line":6}},{"line":151,"address":[4106919],"length":1,"stats":{"Line":6}},{"line":152,"address":[4193000],"length":1,"stats":{"Line":6}},{"line":153,"address":[4193051],"length":1,"stats":{"Line":6}},{"line":156,"address":[3245736,3245803],"length":1,"stats":{"Line":12}},{"line":157,"address":[4193292],"length":1,"stats":{"Line":6}},{"line":158,"address":[4107300],"length":1,"stats":{"Line":6}},{"line":159,"address":[4193360],"length":1,"stats":{"Line":6}},{"line":161,"address":[4107364],"length":1,"stats":{"Line":6}},{"line":163,"address":[3271344,3271368],"length":1,"stats":{"Line":16}},{"line":164,"address":[3809076,3809066,3809006],"length":1,"stats":{"Line":6}},{"line":165,"address":[3827084],"length":1,"stats":{"Line":2}},{"line":166,"address":[3827117],"length":1,"stats":{"Line":2}},{"line":168,"address":[4193579],"length":1,"stats":{"Line":6}},{"line":171,"address":[3246238],"length":1,"stats":{"Line":6}},{"line":174,"address":[4107637],"length":1,"stats":{"Line":18}},{"line":175,"address":[3246365,3246510],"length":1,"stats":{"Line":8}},{"line":176,"address":[3246580,3246439],"length":1,"stats":{"Line":12}},{"line":177,"address":[3271520,3271565],"length":1,"stats":{"Line":18}},{"line":178,"address":[4108100],"length":1,"stats":{"Line":6}},{"line":179,"address":[4108146],"length":1,"stats":{"Line":2}},{"line":184,"address":[3246754,3246523],"length":1,"stats":{"Line":12}},{"line":185,"address":[3246938],"length":1,"stats":{"Line":6}},{"line":186,"address":[3246967],"length":1,"stats":{"Line":6}},{"line":187,"address":[3247070],"length":1,"stats":{"Line":6}},{"line":189,"address":[3809237,3809232],"length":1,"stats":{"Line":18}},{"line":190,"address":[3247189],"length":1,"stats":{"Line":6}},{"line":191,"address":[3247240],"length":1,"stats":{"Line":6}},{"line":197,"address":[3246058],"length":1,"stats":{"Line":6}},{"line":201,"address":[3249821,3250201,3247360],"length":1,"stats":{"Line":6}},{"line":202,"address":[3247506,3247410],"length":1,"stats":{"Line":12}},{"line":203,"address":[3250128,3249991,3247543],"length":1,"stats":{"Line":6}},{"line":206,"address":[3249856],"length":1,"stats":{"Line":2}},{"line":210,"address":[3247654,3247520],"length":1,"stats":{"Line":12}},{"line":211,"address":[3247662],"length":1,"stats":{"Line":6}},{"line":212,"address":[3247732,3247796],"length":1,"stats":{"Line":12}},{"line":215,"address":[4195196],"length":1,"stats":{"Line":6}},{"line":216,"address":[4195210],"length":1,"stats":{"Line":6}},{"line":217,"address":[4195414],"length":1,"stats":{"Line":6}},{"line":220,"address":[3247920],"length":1,"stats":{"Line":6}},{"line":223,"address":[4195477],"length":1,"stats":{"Line":6}},{"line":224,"address":[4109634,4109891],"length":1,"stats":{"Line":12}},{"line":225,"address":[4195936],"length":1,"stats":{"Line":6}},{"line":226,"address":[4109915,4109973],"length":1,"stats":{"Line":12}},{"line":227,"address":[4195924],"length":1,"stats":{"Line":6}},{"line":228,"address":[4195932],"length":1,"stats":{"Line":6}},{"line":233,"address":[4110104,4110065],"length":1,"stats":{"Line":12}},{"line":235,"address":[3248596],"length":1,"stats":{"Line":6}},{"line":236,"address":[3271667,3271648],"length":1,"stats":{"Line":12}},{"line":240,"address":[4196286,4196156,4196061],"length":1,"stats":{"Line":18}},{"line":241,"address":[4110437,4111204],"length":1,"stats":{"Line":12}},{"line":242,"address":[4111278],"length":1,"stats":{"Line":6}},{"line":246,"address":[4110368,4110473],"length":1,"stats":{"Line":12}},{"line":248,"address":[4196359,4196419],"length":1,"stats":{"Line":12}},{"line":249,"address":[4110626],"length":1,"stats":{"Line":6}},{"line":252,"address":[3249217],"length":1,"stats":{"Line":6}},{"line":253,"address":[4110913],"length":1,"stats":{"Line":6}},{"line":255,"address":[4197023,4196859],"length":1,"stats":{"Line":8}},{"line":256,"address":[4196868],"length":1,"stats":{"Line":2}},{"line":257,"address":[4196972],"length":1,"stats":{"Line":2}},{"line":262,"address":[3248353],"length":1,"stats":{"Line":6}},{"line":266,"address":[4115424,4115116,4111808],"length":1,"stats":{"Line":2}},{"line":267,"address":[3250335],"length":1,"stats":{"Line":2}},{"line":268,"address":[4198007,4197799,4198169],"length":1,"stats":{"Line":6}},{"line":271,"address":[4197889],"length":1,"stats":{"Line":2}},{"line":275,"address":[4197765],"length":1,"stats":{"Line":2}},{"line":276,"address":[4112437],"length":1,"stats":{"Line":0}},{"line":280,"address":[4198224],"length":1,"stats":{"Line":2}},{"line":281,"address":[3250928,3251096,3250844,3251054],"length":1,"stats":{"Line":8}},{"line":282,"address":[4198462],"length":1,"stats":{"Line":2}},{"line":286,"address":[4112938,4112558,4112689],"length":1,"stats":{"Line":4}},{"line":287,"address":[4112738],"length":1,"stats":{"Line":2}},{"line":290,"address":[3251380,3251243,3251500],"length":1,"stats":{"Line":6}},{"line":291,"address":[3251516],"length":1,"stats":{"Line":2}},{"line":292,"address":[3253772,3251567],"length":1,"stats":{"Line":4}},{"line":293,"address":[3253875,3253946],"length":1,"stats":{"Line":2}},{"line":294,"address":[4115649],"length":1,"stats":{"Line":0}},{"line":295,"address":[4201325],"length":1,"stats":{"Line":0}},{"line":302,"address":[4198993,4199099,4198821],"length":1,"stats":{"Line":4}},{"line":306,"address":[3251779,3251692],"length":1,"stats":{"Line":4}},{"line":307,"address":[4113410],"length":1,"stats":{"Line":0}},{"line":311,"address":[4199313,4199406,4199184],"length":1,"stats":{"Line":6}},{"line":313,"address":[3251966],"length":1,"stats":{"Line":2}},{"line":314,"address":[3271690,3271680],"length":1,"stats":{"Line":4}},{"line":318,"address":[3252242,3252075],"length":1,"stats":{"Line":4}},{"line":320,"address":[3271736,3271712],"length":1,"stats":{"Line":6}},{"line":324,"address":[4199680],"length":1,"stats":{"Line":2}},{"line":325,"address":[4199837,4199728,4200014,4199964],"length":1,"stats":{"Line":8}},{"line":326,"address":[4200845,4200972,4201001,4200062],"length":1,"stats":{"Line":8}},{"line":327,"address":[4201035],"length":1,"stats":{"Line":2}},{"line":332,"address":[4114325],"length":1,"stats":{"Line":2}},{"line":333,"address":[4114344],"length":1,"stats":{"Line":2}},{"line":335,"address":[3252997,3253023,3252758,3252870],"length":1,"stats":{"Line":8}},{"line":336,"address":[4115065,4114733],"length":1,"stats":{"Line":4}},{"line":337,"address":[4115085],"length":1,"stats":{"Line":2}},{"line":342,"address":[3827568,3827613],"length":1,"stats":{"Line":6}},{"line":345,"address":[4200528],"length":1,"stats":{"Line":2}},{"line":349,"address":[4202357,4201344],"length":1,"stats":{"Line":2}},{"line":350,"address":[4201391],"length":1,"stats":{"Line":2}},{"line":351,"address":[4201495,4201611,4201404],"length":1,"stats":{"Line":6}},{"line":352,"address":[4201632],"length":1,"stats":{"Line":2}},{"line":353,"address":[4201644],"length":1,"stats":{"Line":2}},{"line":354,"address":[4201656,4201818,4201927],"length":1,"stats":{"Line":6}},{"line":355,"address":[4201948,4202334],"length":1,"stats":{"Line":4}},{"line":356,"address":[4202185,4202257],"length":1,"stats":{"Line":2}},{"line":357,"address":[4202230,4202282,4202339],"length":1,"stats":{"Line":4}},{"line":360,"address":[3254757],"length":1,"stats":{"Line":2}},{"line":361,"address":[4116252],"length":1,"stats":{"Line":2}},{"line":362,"address":[3254517,3254580],"length":1,"stats":{"Line":4}},{"line":363,"address":[4201977],"length":1,"stats":{"Line":2}},{"line":365,"address":[3254568],"length":1,"stats":{"Line":2}},{"line":371,"address":[3254199],"length":1,"stats":{"Line":2}},{"line":372,"address":[3254313],"length":1,"stats":{"Line":2}},{"line":378,"address":[4202384],"length":1,"stats":{"Line":0}},{"line":379,"address":[4116769],"length":1,"stats":{"Line":0}},{"line":383,"address":[4116800,4117944,4117965],"length":1,"stats":{"Line":0}},{"line":385,"address":[4116860],"length":1,"stats":{"Line":0}},{"line":386,"address":[3255122],"length":1,"stats":{"Line":0}},{"line":387,"address":[4202539],"length":1,"stats":{"Line":0}},{"line":391,"address":[3256164,3255548,3255339,3255383],"length":1,"stats":{"Line":0}},{"line":394,"address":[4117303,4117417],"length":1,"stats":{"Line":0}},{"line":395,"address":[4203200,4203106],"length":1,"stats":{"Line":0}},{"line":399,"address":[4117815,4117520,4117872,4117727],"length":1,"stats":{"Line":0}},{"line":401,"address":[3255997],"length":1,"stats":{"Line":0}},{"line":405,"address":[4118693,4117984],"length":1,"stats":{"Line":0}},{"line":406,"address":[3256225,3256355],"length":1,"stats":{"Line":0}},{"line":407,"address":[4118633,4118127,4118229],"length":1,"stats":{"Line":0}},{"line":409,"address":[4118466],"length":1,"stats":{"Line":0}},{"line":410,"address":[4118340],"length":1,"stats":{"Line":0}},{"line":411,"address":[4118370],"length":1,"stats":{"Line":0}},{"line":412,"address":[4118418],"length":1,"stats":{"Line":0}}],"covered":132,"coverable":161},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","mod.rs"],"content":"pub mod cache;\n// pub mod code_ranking;\n// pub mod code_structure;\npub mod db;\npub mod embedding;\npub mod error;\npub mod hnsw;\npub mod onnx;\n// pub mod parsing;\npub mod provider;\npub mod search;\n// pub mod search_ranking;\npub mod snippet_extractor;\npub mod utils;\n\npub use db::VectorDB;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","onnx.rs"],"content":"// Removed unused constant\n// pub const ONNX_EMBEDDING_DIM: usize = 384;\n\n// Constants for ONNX runtime\n// const DEF_TOKENIZER_PATH: \u0026str = \"onnx/minilm_tokenizer.json\";\n// const DEF_CFG_USE_GPU: bool = true;\n// const DEF_CFG_INTER_OP_NUM_THREADS: i16 = 1;\n// const DEF_CFG_INTRA_OP_NUM_THREADS: i16 = 1;\n\n// ... rest of file ... ","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","provider","basic.rs"],"content":"use anyhow::Result;\nuse std::collections::HashMap;\nuse std::hash::{DefaultHasher, Hash, Hasher};\nuse crate::vectordb::provider::EmbeddingProvider;\n\n/// Dimension of the fast embeddings (position-weighted token hashes)\npub const FAST_EMBEDDING_DIM: usize = 384;\n\n/// Simple embedding provider using token hashes with position weighting\n/// Fast but less accurate than ONNX-based embeddings\npub struct FastEmbeddingProvider {\n    /// Cached trigram hashes for common tokens\n    trigram_cache: HashMap\u003cString, u64\u003e,\n}\n\nimpl FastEmbeddingProvider {\n    /// Create a new FastEmbeddingProvider\n    pub fn new() -\u003e Self {\n        Self {\n            trigram_cache: HashMap::new(),\n        }\n    }\n    \n    /// Extract n-grams from a string\n    fn extract_ngrams(\u0026self, text: \u0026str, n: usize) -\u003e Vec\u003cString\u003e {\n        let chars: Vec\u003cchar\u003e = text.chars().collect();\n        if chars.len() \u003c n {\n            return vec![text.to_string()];\n        }\n        \n        let mut ngrams = Vec::with_capacity(chars.len() - n + 1);\n        for i in 0..=(chars.len() - n) {\n            let ngram: String = chars[i..(i + n)].iter().collect();\n            ngrams.push(ngram);\n        }\n        \n        ngrams\n    }\n    \n    /// Hash a string to a u64 value\n    fn hash_string(\u0026mut self, s: \u0026str) -\u003e u64 {\n        if let Some(\u0026hash) = self.trigram_cache.get(s) {\n            return hash;\n        }\n        \n        let mut hasher = DefaultHasher::new();\n        s.hash(\u0026mut hasher);\n        let hash = hasher.finish();\n        \n        // Cache the hash for future use\n        if s.len() == 3 {\n            self.trigram_cache.insert(s.to_string(), hash);\n        }\n        \n        hash\n    }\n}\n\nimpl EmbeddingProvider for FastEmbeddingProvider {\n    fn embed(\u0026self, text: \u0026str) -\u003e Result\u003cVec\u003cf32\u003e\u003e {\n        let mut provider = self.clone();\n        \n        // Normalize the text\n        let text = text.to_lowercase();\n        \n        // Extract character trigrams\n        let trigrams = provider.extract_ngrams(\u0026text, 3);\n        \n        // Initialize embedding vector\n        let mut embedding = vec![0.0; FAST_EMBEDDING_DIM];\n        \n        // Generate embedding based on trigram hashes with position weighting\n        for (i, trigram) in trigrams.iter().enumerate() {\n            let hash = provider.hash_string(trigram);\n            let position_weight = 1.0 - (i as f32 / trigrams.len() as f32) * 0.5; // Weight ranges from 0.5 to 1.0\n            \n            // Distribute the weighted hash across multiple dimensions\n            for j in 0..3 {\n                let index = ((hash \u003e\u003e (j * 16)) % FAST_EMBEDDING_DIM as u64) as usize;\n                embedding[index] += position_weight;\n            }\n        }\n        \n        // Normalize the embedding to unit length\n        let norm: f32 = embedding.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n        if norm \u003e 0.0 {\n            for x in \u0026mut embedding {\n                *x /= norm;\n            }\n        }\n        \n        Ok(embedding)\n    }\n    \n    fn embedding_dimension(\u0026self) -\u003e usize {\n        FAST_EMBEDDING_DIM\n    }\n    \n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"Fast-Trigram\"\n    }\n    \n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Fast embedding using character trigrams with position weighting (less accurate but quicker than ONNX)\"\n    }\n}\n\nimpl Clone for FastEmbeddingProvider {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            trigram_cache: self.trigram_cache.clone(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::vectordb::provider::tests::test_provider_basics;\n    \n    #[test]\n    fn test_fast_provider() {\n        let provider = FastEmbeddingProvider::new();\n        test_provider_basics(\u0026provider);\n    }\n    \n    #[test]\n    fn test_deterministic_embeddings() {\n        let provider = FastEmbeddingProvider::new();\n        let text = \"fn main() { println!(\\\"Hello, world!\\\"); }\";\n        \n        let embedding1 = provider.embed(text).unwrap();\n        let embedding2 = provider.embed(text).unwrap();\n        \n        // Embeddings for the same text should be identical\n        assert_eq!(embedding1, embedding2);\n    }\n    \n    #[test]\n    fn test_similar_texts() {\n        let provider = FastEmbeddingProvider::new();\n        let text1 = \"fn calculate_sum(a: i32, b: i32) -\u003e i32 { a + b }\";\n        let text2 = \"fn calculate_sum(a: i32, b: i32) -\u003e i32 { return a + b; }\";\n        let text3 = \"struct Point { x: i32, y: i32 }\";\n        \n        let embedding1 = provider.embed(text1).unwrap();\n        let embedding2 = provider.embed(text2).unwrap();\n        let embedding3 = provider.embed(text3).unwrap();\n        \n        // Calculate cosine similarity\n        fn cosine_similarity(a: \u0026[f32], b: \u0026[f32]) -\u003e f32 {\n            let dot_product: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();\n            // Vectors should already be normalized to length 1, so dot product = cosine similarity\n            dot_product\n        }\n        \n        // Similar texts should have high similarity\n        let sim_1_2 = cosine_similarity(\u0026embedding1, \u0026embedding2);\n        // Different texts should have lower similarity\n        let sim_1_3 = cosine_similarity(\u0026embedding1, \u0026embedding3);\n        \n        assert!(sim_1_2 \u003e 0.8, \"Similar texts should have high similarity: {}\", sim_1_2);\n        assert!(sim_1_3 \u003c 0.8, \"Different texts should have lower similarity: {}\", sim_1_3);\n    }\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","provider","mod.rs"],"content":"use anyhow::Result;\n\n/// Trait for embedding providers that convert text into vector representations\npub trait EmbeddingProvider: Send + Sync {\n    /// Generate an embedding for the given text\n    fn embed(\u0026self, text: \u0026str) -\u003e Result\u003cVec\u003cf32\u003e\u003e;\n\n    /// Generate embeddings for multiple texts (batch processing)\n    fn embed_batch(\u0026self, texts: \u0026[\u0026str]) -\u003e Result\u003cVec\u003cVec\u003cf32\u003e\u003e\u003e {\n        // Default implementation calls embed() for each text\n        texts.iter().map(|text| self.embed(text)).collect()\n    }\n\n    /// Get the dimension of the embeddings produced by this provider\n    fn dimension(\u0026self) -\u003e usize;\n}\n\n// Module exports\npub mod onnx;\n// pub mod fast; // Removed\n\n// Re-export provider implementations\npub use onnx::OnnxEmbeddingProvider;\n// pub use fast::FastEmbeddingProvider; // Removed\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Helper function to test provider implementations\n    pub fn test_provider_basics\u003cP: EmbeddingProvider\u003e(provider: \u0026P) {\n        // Test embedding a single text\n        let text = \"fn main() { println!(\\\"Hello, world!\\\"); }\";\n        let embedding = provider.embed(text).unwrap();\n\n        // Check normalization (roughly L2 normalized to 1.0)\n        let norm: f32 = embedding.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n        assert!((norm - 1.0).abs() \u003c 0.01, \"Embedding should be normalized\");\n\n        // Test batch embedding\n        let texts = vec![\"fn main() {}\", \"struct Point { x: i32, y: i32 }\"];\n        let embeddings = provider.embed_batch(\u0026texts).unwrap();\n\n        // Check batch results\n        assert_eq!(embeddings.len(), 2);\n\n        // Embeddings for different texts should be different\n        assert_ne!(embeddings[0], embeddings[1]);\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","provider","onnx.rs"],"content":"use crate::vectordb::provider::EmbeddingProvider;\nuse anyhow::{Error, Result, anyhow};\nuse log::{debug};\nuse ndarray::{s, Array, Array2, Ix1, Ix2};\nuse ort::session::{Session, builder::GraphOptimizationLevel};\nuse ort::value::{DynValue, Value};\nuse ort::execution_providers::{CUDAExecutionProvider};\nuse std::path::Path;\nuse std::sync::{Arc, Mutex};\nuse tokenizers::Tokenizer;\n\n/// ONNX-based embedding provider\npub struct OnnxEmbeddingProvider {\n    /// The tokenizer for preprocessing input text\n    tokenizer: Arc\u003cMutex\u003cTokenizer\u003e\u003e,\n    /// Maximum sequence length for the model\n    max_seq_length: usize,\n    /// ONNX session for running inference\n    session: Session,\n    /// The actual dimension of the loaded model's embeddings\n    dimension: usize,\n}\n\nimpl OnnxEmbeddingProvider {\n    /// Creates a new OnnxEmbeddingProvider from the given model and tokenizer paths\n    pub fn new(model_path: \u0026Path, tokenizer_path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        debug!(\n            \"Creating ONNX embedding provider with model: {}\",\n            model_path.display()\n        );\n\n        // Load tokenizer\n        let tokenizer_json_path = tokenizer_path.join(\"tokenizer.json\");\n        debug!(\"Loading tokenizer from: {}\", tokenizer_json_path.display());\n\n        let tokenizer = Tokenizer::from_file(\u0026tokenizer_json_path)\n            .map_err(|e| Error::msg(format!(\"Failed to load tokenizer: {}\", e)))?;\n\n        debug!(\"Tokenizer loaded successfully\");\n\n        // Initialize Environment using ort::init()\n        let cuda_provider = CUDAExecutionProvider::default();\n        ort::init()\n            .with_name(\"vectordb-onnx\")\n            .with_execution_providers([cuda_provider.build()]) // Configure EPs here\n            .commit()?;\n\n        // Build session using Session::builder() - EPs are global now\n        let session = Session::builder()? \n            .with_optimization_level(GraphOptimizationLevel::Level1)?\n            .commit_from_file(model_path)?;\n\n        // Determine dimension\n        let pooler_output_name = \"pooler_output\"; \n        let output_dim = session.outputs.iter()\n            .find(|meta| meta.name == pooler_output_name)\n            .and_then(|meta| {\n                match \u0026meta.output_type {\n                    ort::value::ValueType::Tensor { dimensions, .. } =\u003e {\n                        // Assume dimensions.last() gives Option\u003c\u0026i64\u003e\n                        dimensions.last().map(|dim_ref| *dim_ref as usize)\n                    }\n                    _ =\u003e None,\n                }\n            })\n            .ok_or_else(|| Error::msg(format!(\"Could not determine embedding dimension from model output '{}'\", pooler_output_name)))?;\n\n        debug!(\n            \"ONNX model loaded successfully from {}, determined embedding dimension: {}\",\n            model_path.display(),\n            output_dim\n        );\n\n        let tokenizer = Arc::new(Mutex::new(tokenizer));\n\n        Ok(Self {\n            session,\n            tokenizer,\n            max_seq_length: 128, // TODO: Make this configurable or detect from model?\n            dimension: output_dim,\n        })\n    }\n\n    /// Tokenizes input text and prepares model inputs\n    fn prepare_inputs(\u0026self, text: \u0026str) -\u003e Result\u003c(Vec\u003ci64\u003e, Vec\u003ci64\u003e)\u003e {\n        // Encode the text with the tokenizer\n        let encoding = self\n            .tokenizer\n            .lock()\n            .unwrap()\n            .encode(text, true)\n            .map_err(|e| Error::msg(format!(\"Failed to encode text with tokenizer: {}\", e)))?;\n\n        // Get input IDs and attention mask\n        let mut input_ids: Vec\u003ci64\u003e = encoding.get_ids().iter().map(|\u0026id| id as i64).collect();\n        let mut attention_mask: Vec\u003ci64\u003e = encoding\n            .get_attention_mask()\n            .iter()\n            .map(|\u0026mask| mask as i64)\n            .collect();\n\n        // Truncate or pad to the maximum sequence length\n        if input_ids.len() \u003e self.max_seq_length {\n            // Truncate\n            input_ids.truncate(self.max_seq_length);\n            attention_mask.truncate(self.max_seq_length);\n        } else if input_ids.len() \u003c self.max_seq_length {\n            // Pad\n            let pad_length = self.max_seq_length - input_ids.len();\n            input_ids.extend(vec![0; pad_length]);\n            attention_mask.extend(vec![0; pad_length]);\n        }\n\n        Ok((input_ids, attention_mask))\n    }\n\n    /// Convert the ORT output tensor to a Vec\u003cf32\u003e\n    fn extract_embedding(\u0026self, pooler_output_value: \u0026DynValue) -\u003e Result\u003cVec\u003cf32\u003e\u003e {\n        let pooler_output_view = pooler_output_value.try_extract_tensor::\u003cf32\u003e()?;\n\n        // Use self.dimension for validation\n        let expected_dim = self.dimension;\n\n        let embedding = match pooler_output_view.ndim() {\n            1 =\u003e {\n                let view1d = pooler_output_view.into_dimensionality::\u003cIx1\u003e()?;\n                if view1d.shape()[0] != expected_dim {\n                    return Err(Error::msg(format!(\n                        \"Unexpected 1D pooler output shape: got {:?}, expected [{}]\",\n                        view1d.shape(), expected_dim\n                    )));\n                }\n                view1d.to_vec()\n            }\n            2 =\u003e {\n                let view2d = pooler_output_view.into_dimensionality::\u003cIx2\u003e()?;\n                let expected_shape = [1, expected_dim];\n                if view2d.shape() != expected_shape {\n                    return Err(Error::msg(format!(\n                        \"Unexpected 2D pooler output shape: got {:?}, expected {:?}\",\n                        view2d.shape(), expected_shape\n                    )));\n                }\n                view2d.slice(s![0, ..]).to_vec()\n            }\n            _ =\u003e {\n                return Err(Error::msg(format!(\n                    \"Pooler output has unexpected dimensionality: {:?}\",\n                    pooler_output_view.shape()\n                )));\n            }\n        };\n\n        let mut normalized_embedding = embedding;\n\n        // Normalize the embedding to unit length (L2 normalization)\n        let norm: f32 = normalized_embedding.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n        if norm \u003e 0.0 {\n            for x in \u0026mut normalized_embedding {\n                *x /= norm;\n            }\n        }\n\n        Ok(normalized_embedding)\n    }\n\n    /// Normalize an embedding to unit length\n    fn normalize_embedding(mut embedding: Vec\u003cf32\u003e) -\u003e Vec\u003cf32\u003e {\n        let norm: f32 = embedding.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n        if norm \u003e 0.0 {\n            for x in \u0026mut embedding {\n                *x /= norm;\n            }\n        }\n        embedding\n    }\n}\n\nimpl EmbeddingProvider for OnnxEmbeddingProvider {\n    fn embed(\u0026self, text: \u0026str) -\u003e Result\u003cVec\u003cf32\u003e\u003e {\n        let (input_ids, attention_mask) = self.prepare_inputs(text)?;\n        \n        let input_ids_array = Array2::from_shape_vec((1, input_ids.len()), input_ids)\n            .map_err(|e| anyhow!(\"Input ID shape error: {}\", e))?; \n        let attention_mask_array =\n            Array2::from_shape_vec((1, attention_mask.len()), attention_mask)\n            .map_err(|e| anyhow!(\"Attention mask shape error: {}\", e))?; \n\n        // Use Value::from_array\n        let input_ids_value = Value::from_array(input_ids_array)?;\n        let attention_mask_value = Value::from_array(attention_mask_array)?;\n\n        // Use inputs! macro with Values\n        let outputs = self.session.run(ort::inputs![input_ids_value, attention_mask_value]?)\n             .map_err(|e| anyhow!(\"ONNX session run failed: {}\", e))?; \n\n        // Extract pooler output (second output tensor)\n        let pooler_output = outputs.get(\"pooler_output\")\n            .ok_or_else(|| Error::msg(\"Model did not return 'pooler_output'\"))?;\n        self.extract_embedding(pooler_output)\n    }\n\n    fn embed_batch(\u0026self, texts: \u0026[\u0026str]) -\u003e Result\u003cVec\u003cVec\u003cf32\u003e\u003e\u003e {\n        if texts.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        let batch_size = texts.len();\n        let mut all_input_ids = Vec::with_capacity(batch_size * self.max_seq_length);\n        let mut all_attention_masks = Vec::with_capacity(batch_size * self.max_seq_length);\n\n        // Prepare inputs for all texts in the batch\n        for text in texts {\n            let (mut input_ids, mut attention_mask) = self.prepare_inputs(text)?;\n            all_input_ids.append(\u0026mut input_ids);\n            all_attention_masks.append(\u0026mut attention_mask);\n        }\n\n        let input_ids_array =\n            Array::from_shape_vec((batch_size, self.max_seq_length), all_input_ids)\n            .map_err(|e| anyhow!(\"Input ID batch shape error: {}\", e))?;\n        let attention_mask_array =\n            Array::from_shape_vec((batch_size, self.max_seq_length), all_attention_masks)\n            .map_err(|e| anyhow!(\"Attention mask batch shape error: {}\", e))?;\n\n        // Use Value::from_array\n        let input_ids_value = Value::from_array(input_ids_array)?;\n        let attention_mask_value = Value::from_array(attention_mask_array)?;\n\n        // Use inputs! macro with Values\n        let outputs = self.session.run(ort::inputs![input_ids_value, attention_mask_value]?)\n             .map_err(|e| anyhow!(\"ONNX session run failed (batch): {}\", e))?; \n\n        // Extract pooler output tensor view directly by name\n        let pooler_output = outputs.get(\"pooler_output\")\n            .ok_or_else(|| Error::msg(\"Model did not return 'pooler_output'\"))?;\n        let pooler_view = pooler_output.try_extract_tensor::\u003cf32\u003e()?;\n\n        // Check output shape: [batch_size, embedding_dim]\n        let expected_dim = self.dimension;\n        let output_shape = pooler_view.shape();\n        if output_shape.len() != 2\n            || output_shape[0] != batch_size\n            || output_shape[1] != expected_dim\n        {\n            return Err(Error::msg(format!(\n                \"Unexpected pooler output shape: got {:?}, expected [{}, {}]\",\n                output_shape, batch_size, expected_dim\n            )));\n        }\n\n        // Extract individual embeddings and normalize\n        let mut embeddings = Vec::with_capacity(batch_size);\n        for i in 0..batch_size {\n            let embedding_view = pooler_view.slice(s![i, ..]);\n            let embedding_vec = embedding_view.to_vec();\n            embeddings.push(Self::normalize_embedding(embedding_vec));\n        }\n\n        Ok(embeddings)\n    }\n\n    fn dimension(\u0026self) -\u003e usize {\n        self.dimension\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::vectordb::provider::tests::test_provider_basics;\n    use std::path::PathBuf;\n\n    #[test]\n    fn test_onnx_provider() {\n        // Skip if model/tokenizer aren't available\n        let model_path = PathBuf::from(\"onnx/all-minilm-l12-v2.onnx\");\n        let tokenizer_path = PathBuf::from(\"onnx/minilm_tokenizer.json\");\n\n        if !model_path.exists() || !tokenizer_path.exists() {\n            println!(\"Skipping test_onnx_provider because model/tokenizer files aren't available\");\n            return;\n        }\n\n        let provider = OnnxEmbeddingProvider::new(\u0026model_path, \u0026tokenizer_path);\n        assert!(provider.is_ok());\n        test_provider_basics(\u0026provider.unwrap());\n    }\n\n    #[test]\n    fn test_batch_embedding() {\n        // Skip if model/tokenizer aren't available\n        let model_path = PathBuf::from(\"onnx/all-minilm-l12-v2.onnx\");\n        let tokenizer_path = PathBuf::from(\"onnx/minilm_tokenizer.json\");\n\n        if !model_path.exists() || !tokenizer_path.exists() {\n            println!(\"Skipping test_batch_embedding because model/tokenizer files aren't available\");\n            return;\n        }\n\n        let provider = OnnxEmbeddingProvider::new(\u0026model_path, \u0026tokenizer_path).unwrap();\n        let texts = vec![\"Hello, world!\", \"This is a test sentence.\"];\n        let embeddings = provider.embed_batch(\u0026texts);\n\n        assert!(embeddings.is_ok());\n        let embeddings = embeddings.unwrap();\n        assert_eq!(embeddings.len(), 2);\n        assert_eq!(embeddings[0].len(), provider.dimension);\n        assert_eq!(embeddings[1].len(), provider.dimension);\n\n        // Check normalization\n        for embedding in \u0026embeddings {\n            let norm: f32 = embedding.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n            assert!((norm - 1.0).abs() \u003c 0.01);\n        }\n\n        // Check that embeddings are different\n        assert_ne!(embeddings[0], embeddings[1]);\n    }\n}\n","traces":[{"line":26,"address":[3234697,3234588,3229968],"length":1,"stats":{"Line":0}},{"line":27,"address":[4338851],"length":1,"stats":{"Line":0}},{"line":33,"address":[3869010],"length":1,"stats":{"Line":0}},{"line":34,"address":[3231030,3230760,3230192,3230676],"length":1,"stats":{"Line":0}},{"line":36,"address":[3231209,3231458,3230682,3234695],"length":1,"stats":{"Line":0}},{"line":37,"address":[3151880,3151760,3152015],"length":1,"stats":{"Line":0}},{"line":39,"address":[3870431,3870359,3870225],"length":1,"stats":{"Line":0}},{"line":42,"address":[4340053],"length":1,"stats":{"Line":0}},{"line":43,"address":[3231877,3234603,3232080,3232303,3231809,3232131],"length":1,"stats":{"Line":0}},{"line":45,"address":[4340627,4340432,4343073],"length":1,"stats":{"Line":0}},{"line":49,"address":[3871152,3871738,3872055,3873361,3871369],"length":1,"stats":{"Line":0}},{"line":50,"address":[3232902,3232545],"length":1,"stats":{"Line":0}},{"line":51,"address":[3872023],"length":1,"stats":{"Line":0}},{"line":54,"address":[3233157],"length":1,"stats":{"Line":0}},{"line":55,"address":[4342120,4341664,4341820],"length":1,"stats":{"Line":0}},{"line":56,"address":[3152113,3152096],"length":1,"stats":{"Line":0}},{"line":57,"address":[3152144],"length":1,"stats":{"Line":0}},{"line":58,"address":[3564681],"length":1,"stats":{"Line":0}},{"line":59,"address":[3152210],"length":1,"stats":{"Line":0}},{"line":61,"address":[3564821,3564743,3564816],"length":1,"stats":{"Line":0}},{"line":63,"address":[3564780],"length":1,"stats":{"Line":0}},{"line":66,"address":[4342104],"length":1,"stats":{"Line":0}},{"line":68,"address":[3872643],"length":1,"stats":{"Line":0}},{"line":74,"address":[3873103,3872467],"length":1,"stats":{"Line":0}},{"line":76,"address":[3234408],"length":1,"stats":{"Line":0}},{"line":77,"address":[3873126],"length":1,"stats":{"Line":0}},{"line":80,"address":[3234392],"length":1,"stats":{"Line":0}},{"line":85,"address":[3873488,3875160],"length":1,"stats":{"Line":0}},{"line":87,"address":[3235118,3235406,3234802,3235024],"length":1,"stats":{"Line":0}},{"line":92,"address":[3874113,3873832,3875187],"length":1,"stats":{"Line":0}},{"line":95,"address":[3874205],"length":1,"stats":{"Line":0}},{"line":96,"address":[3874329,3874412],"length":1,"stats":{"Line":0}},{"line":99,"address":[3781706,3781696],"length":1,"stats":{"Line":0}},{"line":103,"address":[3235848,3235767],"length":1,"stats":{"Line":0}},{"line":105,"address":[3874604],"length":1,"stats":{"Line":0}},{"line":106,"address":[4344800],"length":1,"stats":{"Line":0}},{"line":107,"address":[3874572,3874639],"length":1,"stats":{"Line":0}},{"line":109,"address":[3874994,3874894],"length":1,"stats":{"Line":0}},{"line":110,"address":[3875014,3874966],"length":1,"stats":{"Line":0}},{"line":111,"address":[3236339],"length":1,"stats":{"Line":0}},{"line":114,"address":[3874657],"length":1,"stats":{"Line":0}},{"line":118,"address":[3878965,3878159,3875216],"length":1,"stats":{"Line":0}},{"line":119,"address":[3236925,3236594],"length":1,"stats":{"Line":0}},{"line":122,"address":[3875561],"length":1,"stats":{"Line":0}},{"line":124,"address":[3237064,3236887],"length":1,"stats":{"Line":0}},{"line":126,"address":[3876916,3876083,3876222,3875807],"length":1,"stats":{"Line":0}},{"line":127,"address":[3237607,3237518],"length":1,"stats":{"Line":0}},{"line":128,"address":[4346517,4346380],"length":1,"stats":{"Line":0}},{"line":130,"address":[3237819,3237696],"length":1,"stats":{"Line":0}},{"line":133,"address":[3876342,3876380],"length":1,"stats":{"Line":0}},{"line":136,"address":[4345617,4346811,4346614,4348290],"length":1,"stats":{"Line":0}},{"line":137,"address":[3238429],"length":1,"stats":{"Line":0}},{"line":138,"address":[4346786,4346855],"length":1,"stats":{"Line":0}},{"line":139,"address":[3878414,3878551],"length":1,"stats":{"Line":0}},{"line":141,"address":[4346942,4347858],"length":1,"stats":{"Line":0}},{"line":144,"address":[4346970,4346908],"length":1,"stats":{"Line":0}},{"line":147,"address":[3240293,3240172],"length":1,"stats":{"Line":0}},{"line":149,"address":[3240046,3237092],"length":1,"stats":{"Line":0}},{"line":154,"address":[3237733],"length":1,"stats":{"Line":0}},{"line":157,"address":[3152942,3152928],"length":1,"stats":{"Line":0}},{"line":158,"address":[3239285],"length":1,"stats":{"Line":0}},{"line":159,"address":[3877994,3878141],"length":1,"stats":{"Line":0}},{"line":160,"address":[4347809],"length":1,"stats":{"Line":0}},{"line":164,"address":[3877890],"length":1,"stats":{"Line":0}},{"line":168,"address":[3879008,3879409],"length":1,"stats":{"Line":0}},{"line":169,"address":[4348718,4348786],"length":1,"stats":{"Line":0}},{"line":170,"address":[4348891],"length":1,"stats":{"Line":0}},{"line":171,"address":[3240689,3240831],"length":1,"stats":{"Line":0}},{"line":172,"address":[3240819],"length":1,"stats":{"Line":0}},{"line":175,"address":[3240654],"length":1,"stats":{"Line":0}},{"line":180,"address":[4351665,4349120,4351950],"length":1,"stats":{"Line":0}},{"line":181,"address":[3240910,3241177],"length":1,"stats":{"Line":0}},{"line":183,"address":[3241257,3243731,3241588,3241151],"length":1,"stats":{"Line":0}},{"line":184,"address":[3241572],"length":1,"stats":{"Line":0}},{"line":185,"address":[3241546,3242067,3243668,3241655],"length":1,"stats":{"Line":0}},{"line":187,"address":[3242051],"length":1,"stats":{"Line":0}},{"line":190,"address":[3880683,3880493,3882071,3880857],"length":1,"stats":{"Line":0}},{"line":191,"address":[3881097,3880971,3882016,3880757],"length":1,"stats":{"Line":0}},{"line":194,"address":[3154893,3154635],"length":1,"stats":{"Line":0}},{"line":195,"address":[4351317],"length":1,"stats":{"Line":0}},{"line":198,"address":[3243229,3243102,3243370],"length":1,"stats":{"Line":0}},{"line":199,"address":[3782577,3782576],"length":1,"stats":{"Line":0}},{"line":200,"address":[3881824],"length":1,"stats":{"Line":0}},{"line":203,"address":[3882304,3886676,3887864],"length":1,"stats":{"Line":0}},{"line":204,"address":[3882397],"length":1,"stats":{"Line":0}},{"line":205,"address":[3244065],"length":1,"stats":{"Line":0}},{"line":208,"address":[4352151],"length":1,"stats":{"Line":0}},{"line":209,"address":[4352262,4352159,4352328],"length":1,"stats":{"Line":0}},{"line":210,"address":[4352298,4352352,4352451],"length":1,"stats":{"Line":0}},{"line":213,"address":[3244418,3244595,3244337],"length":1,"stats":{"Line":0}},{"line":214,"address":[4352729,4357260,4357449,4357064],"length":1,"stats":{"Line":0}},{"line":215,"address":[3249296],"length":1,"stats":{"Line":0}},{"line":216,"address":[3887654],"length":1,"stats":{"Line":0}},{"line":219,"address":[4352770,4357027,4353076,4352630],"length":1,"stats":{"Line":0}},{"line":221,"address":[3244954],"length":1,"stats":{"Line":0}},{"line":222,"address":[4356982,4352977,4353468,4353150],"length":1,"stats":{"Line":0}},{"line":224,"address":[3154144,3154235,3154032],"length":1,"stats":{"Line":0}},{"line":227,"address":[4353719,4356927,4353542,4353349],"length":1,"stats":{"Line":0}},{"line":228,"address":[3884153,3883936,3884282,3887192],"length":1,"stats":{"Line":0}},{"line":231,"address":[3155403,3155661],"length":1,"stats":{"Line":0}},{"line":232,"address":[3884831],"length":1,"stats":{"Line":0}},{"line":235,"address":[4354467,4354729,4354593,4356828],"length":1,"stats":{"Line":0}},{"line":236,"address":[3154560,3154561],"length":1,"stats":{"Line":0}},{"line":237,"address":[3885363,3887146,3885082,3885018],"length":1,"stats":{"Line":0}},{"line":240,"address":[4354998],"length":1,"stats":{"Line":0}},{"line":241,"address":[3885338,3885470],"length":1,"stats":{"Line":0}},{"line":242,"address":[3247160],"length":1,"stats":{"Line":0}},{"line":243,"address":[3885637,3885497],"length":1,"stats":{"Line":0}},{"line":244,"address":[3247368],"length":1,"stats":{"Line":0}},{"line":246,"address":[3248623,3248776],"length":1,"stats":{"Line":0}},{"line":253,"address":[3885776],"length":1,"stats":{"Line":0}},{"line":254,"address":[3885889,3885806,3886049],"length":1,"stats":{"Line":0}},{"line":255,"address":[3886187,3886065],"length":1,"stats":{"Line":0}},{"line":256,"address":[3886611],"length":1,"stats":{"Line":0}},{"line":257,"address":[3248348],"length":1,"stats":{"Line":0}},{"line":260,"address":[3247661],"length":1,"stats":{"Line":0}},{"line":263,"address":[3249664],"length":1,"stats":{"Line":0}},{"line":264,"address":[3249669],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":118},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","chunking.rs"],"content":"use std::cmp;\n\n#[derive(Debug, Clone)]\npub struct ChunkInfo {\n    pub text: String,\n    pub start_line: usize, // 1-indexed\n    pub end_line: usize,   // 1-indexed\n}\n\n/// Splits content into chunks based on double newlines (paragraphs).\n/// Tracks the 1-based start and end lines for each chunk.\npub fn chunk_by_paragraphs(content: \u0026str) -\u003e Vec\u003cChunkInfo\u003e {\n    let mut chunks = Vec::new();\n    let mut current_line_num = 1;\n    let mut chunk_start_line = 1;\n    let mut current_chunk = String::new();\n\n    for line in content.lines() {\n        if line.trim().is_empty() {\n            // Potential paragraph break\n            if !current_chunk.is_empty() {\n                // End of a paragraph chunk\n                chunks.push(ChunkInfo {\n                    text: current_chunk.trim().to_string(),\n                    start_line: chunk_start_line,\n                    end_line: current_line_num -1, // Previous line was the end\n                });\n                current_chunk.clear();\n                // Next non-empty line will start a new chunk\n                chunk_start_line = current_line_num + 1;\n            } else {\n                 // Multiple empty lines, just advance chunk_start_line\n                 chunk_start_line = current_line_num + 1;\n            }\n        } else {\n            // Non-empty line, part of the current chunk\n            if !current_chunk.is_empty() {\n                current_chunk.push('\\n');\n            }\n            current_chunk.push_str(line);\n        }\n        current_line_num += 1;\n    }\n\n    // Add the last chunk if it wasn't terminated by an empty line\n    if !current_chunk.is_empty() {\n        chunks.push(ChunkInfo {\n            text: current_chunk.trim().to_string(),\n            start_line: chunk_start_line,\n            // End line is the last line number we processed\n            end_line: cmp::max(chunk_start_line, current_line_num.saturating_sub(1)),\n        });\n    }\n\n    chunks\n}\n\n// --- Basic Tests ---\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simple_paragraphs() {\n        let content = \"First paragraph.\\nLine two.\\n\\nSecond paragraph.\\n\\nThird.\";\n        let chunks = chunk_by_paragraphs(content);\n        assert_eq!(chunks.len(), 3);\n        assert_eq!(chunks[0].text, \"First paragraph.\\nLine two.\");\n        assert_eq!(chunks[0].start_line, 1);\n        assert_eq!(chunks[0].end_line, 2);\n        assert_eq!(chunks[1].text, \"Second paragraph.\");\n        assert_eq!(chunks[1].start_line, 4);\n        assert_eq!(chunks[1].end_line, 4);\n        assert_eq!(chunks[2].text, \"Third.\");\n        assert_eq!(chunks[2].start_line, 6);\n        assert_eq!(chunks[2].end_line, 6);\n    }\n\n     #[test]\n     fn test_leading_trailing_empty_lines() {\n        let content = \"\\n\\nFirst paragraph.\\n\\n\\nSecond paragraph.\\n\\n\";\n        let chunks = chunk_by_paragraphs(content);\n        assert_eq!(chunks.len(), 2);\n        assert_eq!(chunks[0].text, \"First paragraph.\");\n        assert_eq!(chunks[0].start_line, 3);\n        assert_eq!(chunks[0].end_line, 3);\n        assert_eq!(chunks[1].text, \"Second paragraph.\");\n        assert_eq!(chunks[1].start_line, 6);\n        assert_eq!(chunks[1].end_line, 6);\n    }\n\n     #[test]\n     fn test_no_empty_lines() {\n        let content = \"Single line one.\\nSingle line two.\";\n        let chunks = chunk_by_paragraphs(content);\n        assert_eq!(chunks.len(), 1);\n        assert_eq!(chunks[0].text, \"Single line one.\\nSingle line two.\");\n        assert_eq!(chunks[0].start_line, 1);\n        assert_eq!(chunks[0].end_line, 2);\n    }\n\n     #[test]\n     fn test_empty_content() {\n        let content = \"\";\n        let chunks = chunk_by_paragraphs(content);\n        assert!(chunks.is_empty());\n     }\n\n     #[test]\n     fn test_only_empty_lines() {\n         let content = \"\\n\\n\\n\";\n         let chunks = chunk_by_paragraphs(content);\n         assert!(chunks.is_empty());\n     }\n\n      #[test]\n    fn test_single_line_content() {\n        let content = \"Just one line.\";\n        let chunks = chunk_by_paragraphs(content);       assert_eq!(chunks.len(), 1);\n        assert_eq!(chunks[0].text, \"Just one line.\");\n        assert_eq!(chunks[0].start_line, 1);\n        assert_eq!(chunks[0].end_line, 1);\n    }\n} ","traces":[{"line":12,"address":[3671510,3672169,3670624],"length":1,"stats":{"Line":7}},{"line":13,"address":[3288679],"length":1,"stats":{"Line":8}},{"line":14,"address":[3288712],"length":1,"stats":{"Line":9}},{"line":15,"address":[3288724],"length":1,"stats":{"Line":9}},{"line":16,"address":[3670740],"length":1,"stats":{"Line":10}},{"line":18,"address":[3289031,3288864,3288816,3290159],"length":1,"stats":{"Line":43}},{"line":19,"address":[3678831,3679319],"length":1,"stats":{"Line":20}},{"line":21,"address":[3290087,3290123,3289619,3289730],"length":1,"stats":{"Line":16}},{"line":23,"address":[3671881],"length":1,"stats":{"Line":4}},{"line":24,"address":[3679550,3679492],"length":1,"stats":{"Line":6}},{"line":25,"address":[3289844],"length":1,"stats":{"Line":4}},{"line":26,"address":[3289857,3289975],"length":1,"stats":{"Line":4}},{"line":28,"address":[3290047],"length":1,"stats":{"Line":4}},{"line":30,"address":[3290054,3290092],"length":1,"stats":{"Line":2}},{"line":33,"address":[3679872,3679859,3679509],"length":1,"stats":{"Line":8}},{"line":37,"address":[3289634,3289600],"length":1,"stats":{"Line":12}},{"line":38,"address":[3679439,3679401],"length":1,"stats":{"Line":6}},{"line":40,"address":[3289684,3289693],"length":1,"stats":{"Line":12}},{"line":42,"address":[3679895,3679908,3679443],"length":1,"stats":{"Line":16}},{"line":46,"address":[3289017,3289112],"length":1,"stats":{"Line":4}},{"line":47,"address":[3289435],"length":1,"stats":{"Line":4}},{"line":48,"address":[3289226,3289126],"length":1,"stats":{"Line":4}},{"line":49,"address":[3289268],"length":1,"stats":{"Line":4}},{"line":51,"address":[3289409,3289281],"length":1,"stats":{"Line":8}},{"line":55,"address":[3289157],"length":1,"stats":{"Line":2}}],"covered":25,"coverable":25},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","hybrid.rs"],"content":"// Hybrid Search Implementation (Currently unused)\n\n// (Entire file content removed) ","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","mod.rs"],"content":"// Declare the modules within the search directory\n// pub mod bm25; // Removed unused module\npub mod chunking;\n// pub mod hybrid; // Removed unused module\npub mod query_analysis;\npub mod result; // Make result public so SearchResult can be used outside\n// pub mod snippet; // Removed unused module\nmod vector;\n\n// Re-export the necessary public items\npub use result::SearchResult;\n\nuse crate::vectordb::db::VectorDB;\nuse crate::vectordb::embedding::EmbeddingModel;\nuse crate::vectordb::error::Result;\nuse log::{warn};\nuse std::collections::HashSet;\nuse std::fs; // Re-add fs import\nuse std::path::Path;\n\n// --- Removed Structs --- \n// Remove the duplicated struct definitions from here\n// struct BM25DocumentData { ... }\n// struct BM25Index { ... }\n// struct QueryAnalysis { ... }\n// enum QueryType { ... }\n// --- End of Removed Structs ---\n\n/// Main struct for performing searches.\npub struct Search {\n    pub db: VectorDB,\n    model: EmbeddingModel,\n}\n\nimpl Search {\n    /// Creates a new Search instance.\n    pub fn new(db: VectorDB) -\u003e Result\u003cSelf\u003e {\n        let model = db.create_embedding_model()?;\n        Ok(Self {\n            db,\n            model,\n        })\n    }\n\n    /// Lists unique file types present in the database.\n    pub fn list_file_types(\u0026self) -\u003e Vec\u003cString\u003e {\n        let mut extensions = HashSet::new();\n        // Iterate through indexed_chunks to get file paths\n        for chunk in \u0026self.db.indexed_chunks {\n            if let Some(ext) = Path::new(\u0026chunk.file_path).extension().and_then(|e| e.to_str()) {\n                extensions.insert(ext.to_lowercase());\n            }\n        }\n        extensions.into_iter().collect()\n    }\n\n    /// Lists unique top-level directories present in the database.\n    pub fn list_indexed_dirs(\u0026self) -\u003e Vec\u003cString\u003e {\n        let mut top_dirs = HashSet::new();\n        for chunk in \u0026self.db.indexed_chunks {\n            if let Ok(abs_path) = fs::canonicalize(\u0026chunk.file_path) {\n                 if let Some(parent) = abs_path.parent() {\n                     // Find the first ancestor directory that exists in the indexed_roots map\n                     let mut current = parent;\n                     loop {\n                         if self.db.indexed_roots().contains_key(current.to_string_lossy().as_ref()) {\n                             top_dirs.insert(current.to_string_lossy().into_owned());\n                             break;\n                         }\n                         if let Some(p) = current.parent() {\n                             current = p;\n                         } else {\n                             break; // Reached root without finding indexed root\n                         }\n                     }\n                 }\n            } else {\n                 warn!(\"Could not canonicalize path {} during list_indexed_dirs\", chunk.file_path);\n            }\n        }\n        // Alternative: Directly return keys from db.indexed_roots() if that's desired?\n        // return self.db.indexed_roots().keys().cloned().collect();\n        top_dirs.into_iter().collect()\n    }\n\n    /// Standard search using vector similarity with a limit on the number of results.\n    pub fn search_with_limit(\n        \u0026mut self,\n        query: \u0026str,\n        max_results: usize,\n    ) -\u003e anyhow::Result\u003cVec\u003cSearchResult\u003e\u003e {\n        vector::search_with_limit(\n            \u0026self.db,\n            \u0026mut self.model,\n            query,\n            max_results,\n        )\n    }\n}\n\n// --- Tests --- \n#[cfg(test)]\nmod tests {\n    // Keep imports as they are, they should work with the new structure\n    use super::*; \n    use crate::vectordb::db::VectorDB;\n    use tempfile::tempdir;\n    use std::fs;\n    use std::path::Path;\n    use log::warn; // Ensure warn is imported for setup_test_env\n\n    // Helper function to set up a test environment with indexed files\n    fn setup_test_env() -\u003e (tempfile::TempDir, VectorDB) {\n        let temp_dir = tempdir().unwrap();\n        let db_path = temp_dir.path().join(\"test_db.json\");\n        let db_path_str = db_path.to_str().unwrap().to_string();\n\n        if let Some(parent) = db_path.parent() {\n            fs::create_dir_all(parent).unwrap();\n        }\n\n        let mut db = VectorDB::new(db_path_str.clone()).unwrap();\n\n        // Attempt to set default ONNX paths\n        let default_model_path = Path::new(\"onnx/all-minilm-l12-v2.onnx\");\n        let default_tokenizer_path = Path::new(\"onnx/minilm_tokenizer.json\");\n        if default_model_path.exists() \u0026\u0026 default_tokenizer_path.exists() {\n             if let Err(e) = db.set_onnx_paths(Some(default_model_path.to_path_buf()), Some(default_tokenizer_path.to_path_buf())) {\n                warn!(\"Setup_test_env: Failed to set default ONNX paths: {}\", e);\n             }\n        }\n\n        // Create test files\n        let files_data = vec![\n            (\"file1_alpha.txt\", \"Detailed Rust code snippet regarding alpha topic, contains specific implementation details.\"),\n            (\"file2_bravo.txt\", \"Python script focusing on the bravo subject matter, includes data processing functions.\"),\n            (\"file3_alpha.txt\", \"Another Rust example for the alpha problem, showcasing a different approach to the implementation.\"),\n        ];\n\n        for (filename, content) in files_data {\n            let file_path = temp_dir.path().join(filename);\n            fs::write(\u0026file_path, content).unwrap();\n        }\n\n        // Index the directory containing the test files\n        let file_patterns = vec![\"txt\".to_string()];\n        db.index_directory(temp_dir.path().to_str().unwrap(), \u0026file_patterns)\n            .expect(\"Failed to index test directory in setup_test_env\");\n\n        (temp_dir, db)\n    }\n\n    #[test_log::test]\n    fn test_vector_search() {\n        // Restore check for ONNX model files\n        let default_model_path = Path::new(\"onnx/all-minilm-l12-v2.onnx\");\n        let default_tokenizer_path = Path::new(\"onnx/minilm_tokenizer.json\");\n        if !default_model_path.exists() || !default_tokenizer_path.exists() {\n            warn!(\"Skipping test_vector_search because default ONNX model/tokenizer files are not available in ./onnx/\");\n            return; // Skip test if files are missing\n        }\n\n        let (_temp_dir, db) = setup_test_env();\n        let _model = db.create_embedding_model().expect(\"Failed to create ONNX model in test_vector_search\");\n        let mut search = Search::new(db).expect(\"Failed to create Search instance in test_vector_search\");\n\n        let query_alpha = \"alpha problem implementation\";\n        let results_alpha = search.search_with_limit(query_alpha, 3).unwrap();\n        println!(\"Query: '{}', Results: {:?}\", query_alpha, results_alpha.iter().map(|r| (\u0026r.file_path, r.similarity)).collect::\u003cVec\u003c_\u003e\u003e());\n\n        assert!(!results_alpha.is_empty(), \"Should find results for 'alpha problem'\");\n        assert!(results_alpha[0].file_path.contains(\"_alpha.txt\"), \"Top result should be alpha\");\n        assert!(results_alpha.len() \u003e= 1);\n\n        let query_bravo = \"bravo subject data processing\";\n        let results_bravo = search.search_with_limit(query_bravo, 1).unwrap();\n        println!(\"Query: '{}', Results: {:?}\", query_bravo, results_bravo.iter().map(|r| (\u0026r.file_path, r.similarity)).collect::\u003cVec\u003c_\u003e\u003e());\n        assert_eq!(results_bravo.len(), 1, \"Should find 1 result for 'bravo subject'\");\n        assert!(results_bravo[0].file_path.contains(\"file2_bravo.txt\"));\n    }\n} ","traces":[{"line":37,"address":[3782080,3782425],"length":1,"stats":{"Line":0}},{"line":38,"address":[3782107,3782339,3782161],"length":1,"stats":{"Line":0}},{"line":39,"address":[3782250],"length":1,"stats":{"Line":0}},{"line":40,"address":[3782232],"length":1,"stats":{"Line":0}},{"line":46,"address":[3725729,3725758,3725168],"length":1,"stats":{"Line":0}},{"line":47,"address":[3782478],"length":1,"stats":{"Line":0}},{"line":49,"address":[3782581,3782513,3782736],"length":1,"stats":{"Line":0}},{"line":50,"address":[3725544,3725472],"length":1,"stats":{"Line":0}},{"line":51,"address":[3782961],"length":1,"stats":{"Line":0}},{"line":54,"address":[3782786,3782659],"length":1,"stats":{"Line":0}},{"line":58,"address":[3725776,3726989,3727590],"length":1,"stats":{"Line":0}},{"line":59,"address":[3783095],"length":1,"stats":{"Line":0}},{"line":60,"address":[3783391,3783144,3783224,3784791],"length":1,"stats":{"Line":0}},{"line":61,"address":[3783474,3783420],"length":1,"stats":{"Line":0}},{"line":62,"address":[3783681,3783565],"length":1,"stats":{"Line":0}},{"line":64,"address":[3783789],"length":1,"stats":{"Line":0}},{"line":65,"address":[3726894,3726525],"length":1,"stats":{"Line":0}},{"line":66,"address":[3783837],"length":1,"stats":{"Line":0}},{"line":67,"address":[3784179],"length":1,"stats":{"Line":0}},{"line":70,"address":[3784030],"length":1,"stats":{"Line":0}},{"line":71,"address":[3784158],"length":1,"stats":{"Line":0}},{"line":78,"address":[3784440,3783582,3784392,3784583],"length":1,"stats":{"Line":0}},{"line":83,"address":[3783308,3783443],"length":1,"stats":{"Line":0}},{"line":87,"address":[3784912],"length":1,"stats":{"Line":0}},{"line":94,"address":[3784952],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","query_analysis.rs"],"content":"// File is now empty after removing unused code.\n// We can keep the file for potential future query analysis features,\n// or delete it. ","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","result.rs"],"content":"/// Represents a single search result.\n#[derive(Debug, Clone)]\npub struct SearchResult {\n    pub file_path: String,\n    pub similarity: f32,\n} ","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","tests.rs"],"content":"use crate::vectordb::{\n    cache::EmbeddingCache,\n    db::VectorDB,\n    embedding::{EmbeddingModel, EmbeddingModelType},\n    hnsw::{HNSWConfig, HNSWIndex},\n    search::{ \n        bm25::{build_bm25_index, search_bm25_top_k},\n        vector::search_with_limit,\n    },\n    snippet_extractor::SnippetExtractor,\n};\nuse std::collections::HashMap;\nuse std::fs;\nuse tempfile::tempdir;\nuse anyhow;\n\n// --- Mock Embedding Model --- \n#[derive(Clone)]\nstruct MockEmbeddingModel {\n    embeddings: HashMap\u003cString, Vec\u003cf32\u003e\u003e,\n    dimension: usize,\n}\n\nimpl MockEmbeddingModel {\n    fn new(dimension: usize) -\u003e Self {\n        MockEmbeddingModel { embeddings: HashMap::new(), dimension }\n    }\n\n    fn add_embedding(\u0026mut self, text: \u0026str, embedding: Vec\u003cf32\u003e) {\n        assert_eq!(embedding.len(), self.dimension, \"Mock embedding dimension mismatch\");\n        self.embeddings.insert(text.to_string(), embedding);\n    }\n}\n\nimpl crate::vectordb::provider::EmbeddingProvider for MockEmbeddingModel {\n    fn embed(\u0026self, text: \u0026str) -\u003e anyhow::Result\u003cVec\u003cf32\u003e\u003e {\n        self.embeddings.get(text)\n            .cloned()\n            .ok_or_else(|| anyhow::anyhow!(\"Mock embedding not found for query: {}\", text))\n    }\n\n    fn embed_batch(\u0026self, texts: \u0026[\u0026str]) -\u003e anyhow::Result\u003cVec\u003cVec\u003cf32\u003e\u003e\u003e {\n        texts.iter().map(|text| self.embed(text)).collect()\n    }\n\n    fn dimension(\u0026self) -\u003e usize {\n        self.dimension\n    }\n}\n\n// --- Mock VectorDB Setup ---\n// Function to setup mock db with embeddings and *content*\n// Now accepts embeddings map directly\nfn setup_mock_db_with_content(\n    content_map: HashMap\u003cString, String\u003e, \n    embeddings: HashMap\u003cString, Vec\u003cf32\u003e\u003e, // Accept embeddings\n    dimension: usize, \n    use_hnsw: bool\n) -\u003e (VectorDB, tempfile::TempDir, String) // Return db_path string\n{\n    let temp_dir = tempdir().expect(\"Failed to create temp dir for mock db\");\n    let db_path = temp_dir.path().join(\"mock_db.json\").to_string_lossy().to_string();\n    let cache_path = temp_dir.path().join(\"cache.json\").to_string_lossy().to_string();\n    let cache = EmbeddingCache::new(cache_path).unwrap();\n\n    // Create files, but use provided embeddings\n    let mut final_embeddings = HashMap::new();\n    for (file_name, content) in \u0026content_map {\n        let file_path = temp_dir.path().join(file_name);\n        fs::write(\u0026file_path, content).expect(\"Failed to write mock content file\");\n        let path_str = file_path.to_string_lossy().into_owned();\n        // Use the embedding provided for the original file name key\n        if let Some(embedding) = embeddings.get(file_name) { // Look up by original filename\n             final_embeddings.insert(path_str, embedding.clone());\n        } else {\n            // Optionally handle cases where embedding is missing for a file\n            println!(\"Warning: No embedding provided for file: {}\", file_name);\n        }\n    }\n\n    let hnsw_index_opt = if use_hnsw \u0026\u0026 !final_embeddings.is_empty() {\n        let mut hnsw_index = HNSWIndex::new(HNSWConfig::new(dimension));\n        // Use final_embeddings for HNSW build\n        let mut sorted_paths: Vec\u003cString\u003e = final_embeddings.keys().cloned().collect();\n        sorted_paths.sort();\n        for path in \u0026sorted_paths {\n            if let Some(embedding) = final_embeddings.get(path) {\n                hnsw_index.insert(embedding.clone()).unwrap();\n            }\n        }\n        Some(hnsw_index)\n    } else {\n        None\n    };\n\n    let db = VectorDB::new_test(\n        db_path.clone(), \n        final_embeddings, // Use the map with full paths and correct embeddings\n        cache,\n        hnsw_index_opt,\n        EmbeddingModelType::Onnx,\n    );\n    (db, temp_dir, db_path)\n}\n\n// --- Tests --- \n\n#[test]\nfn test_vector_search_empty_query() {\n    let dim = 4;\n    let content_map: HashMap\u003cString, String\u003e = HashMap::new(); \n    let embeddings: HashMap\u003cString, Vec\u003cf32\u003e\u003e = HashMap::new();\n    let (db, _temp_dir, _) = setup_mock_db_with_content(content_map, embeddings, dim, true);\n    let mut model = EmbeddingModel::new_mock(Box::new(MockEmbeddingModel::new(dim)));\n    let mut snippet_extractor = SnippetExtractor::new();\n    let results = search_with_limit(\u0026db, \u0026mut model, \u0026mut snippet_extractor, \"\", 10).unwrap();\n    assert!(results.is_empty(), \"Empty query should return empty results\");\n}\n\n#[test]\nfn test_vector_search_hnsw_path() {\n    let dim = 4;\n    let mut mock_provider = MockEmbeddingModel::new(dim);\n    mock_provider.add_embedding(\"query1\", vec![1.0, 0.0, 0.0, 0.0]);\n    mock_provider.add_embedding(\"query2\", vec![0.0, 0.0, 1.0, 0.0]);\n\n    // Define content and corresponding embeddings explicitly\n    let mut content_map = HashMap::new();\n    content_map.insert(\"file1.txt\".to_string(), \"content1\".to_string());\n    content_map.insert(\"file2.txt\".to_string(), \"content2\".to_string());\n    content_map.insert(\"file3.txt\".to_string(), \"content3\".to_string());\n    content_map.insert(\"file4.txt\".to_string(), \"content4\".to_string());\n\n    let mut embeddings = HashMap::new();\n    embeddings.insert(\"file1.txt\".to_string(), vec![0.9, 0.1, 0.0, 0.0]); // High sim query1\n    embeddings.insert(\"file2.txt\".to_string(), vec![0.0, 0.0, 0.8, 0.2]); // High sim query2\n    embeddings.insert(\"file3.txt\".to_string(), vec![0.6, 0.1, 0.3, 0.0]); // Med sim query1\n    embeddings.insert(\"file4.txt\".to_string(), vec![0.1, 0.2, 0.1, 0.6]); // Low sim both\n\n    let (db, _temp_dir, _) = setup_mock_db_with_content(content_map, embeddings, dim, true); // Use HNSW\n    let mut model = EmbeddingModel::new_mock(Box::new(mock_provider));\n    let mut snippet_extractor = SnippetExtractor::new();\n\n    let results1 = search_with_limit(\u0026db, \u0026mut model, \u0026mut snippet_extractor, \"query1\", 10).unwrap();\n    assert!(!results1.is_empty(), \"Should find results for query1\");\n    assert!(results1[0].file_path.ends_with(\"file1.txt\"), \"Top result for query1 should be file1.txt\"); \n    assert!(results1[0].similarity \u003e 0.8, \"Similarity for file1.txt should be high\"); // Check similarity\n    // Check the next result is file3\n    if results1.len() \u003e 1 {\n        assert!(results1[1].file_path.ends_with(\"file3.txt\"), \"Second result for query1 should be file3.txt\");\n        assert!(results1[1].similarity \u003c results1[0].similarity, \"Result 2 sim should be \u003c Result 1 sim\");\n    }\n    assert!(!results1.iter().any(|r| r.file_path.ends_with(\"file4.txt\") \u0026\u0026 r.similarity \u003e 0.3), \"file4.txt should have low similarity\");\n\n    let results2 = search_with_limit(\u0026db, \u0026mut model, \u0026mut snippet_extractor, \"query2\", 10).unwrap();\n    assert!(!results2.is_empty(), \"Should find results for query2\");\n    assert!(results2[0].file_path.ends_with(\"file2.txt\"), \"Top result for query2 should be file2.txt\");\n    assert!(results2[0].similarity \u003e 0.7, \"Similarity for file2.txt should be high\");\n}\n\n#[test]\nfn test_vector_search_brute_force_path() {\n    let dim = 4;\n    let mut mock_provider = MockEmbeddingModel::new(dim);\n    mock_provider.add_embedding(\"query1\", vec![1.0, 0.0, 0.0, 0.0]);\n\n    let mut content_map = HashMap::new();\n    content_map.insert(\"bf_file1.txt\".to_string(), \"content bf1\".to_string());\n    content_map.insert(\"bf_file2.txt\".to_string(), \"content bf2\".to_string());\n\n    let mut embeddings = HashMap::new();\n    embeddings.insert(\"bf_file1.txt\".to_string(), vec![0.9, 0.1, 0.0, 0.0]); // High sim\n    embeddings.insert(\"bf_file2.txt\".to_string(), vec![0.1, 0.1, 0.9, 0.0]); // Low sim\n\n    // Setup DB *without* HNSW, pass explicit embeddings\n    let (db, _temp_dir, _) = setup_mock_db_with_content(content_map, embeddings, dim, false); \n    assert!(db.hnsw_index.is_none(), \"HNSW index should be None for brute force test\");\n\n    let mut model = EmbeddingModel::new_mock(Box::new(mock_provider));\n    let mut snippet_extractor = SnippetExtractor::new();\n\n    let results = search_with_limit(\u0026db, \u0026mut model, \u0026mut snippet_extractor, \"query1\", 10).unwrap();\n    assert!(!results.is_empty(), \"Brute force should find results\");\n    assert!(results[0].file_path.ends_with(\"bf_file1.txt\"), \"Top result should be bf_file1.txt\");\n    assert!(results[0].similarity \u003e 0.8, \"Similarity for bf_file1.txt should be high\");\n    // Check if low similarity result is present but ranked lower (threshold might filter it)\n    if results.len() \u003e 1 {\n        assert!(results.iter().any(|r| r.file_path.ends_with(\"bf_file2.txt\")), \"bf_file2.txt should be present if not filtered\");\n        assert!(results.iter().find(|r| r.file_path.ends_with(\"bf_file2.txt\")).unwrap().similarity \u003c 0.3, \"bf_file2.txt should have low similarity\");\n    }\n}\n\n#[test]\nfn test_vector_search_max_results_limit() {\n    let dim = 2;\n    let mut mock_provider = MockEmbeddingModel::new(dim);\n    mock_provider.add_embedding(\"query\", vec![1.0, 0.0]);\n\n    let mut content_map = HashMap::new();\n    let mut embeddings = HashMap::new();\n    for i in 0..5 {\n        let filename = format!(\"limit_file_{}.txt\", i);\n        content_map.insert(filename.clone(), format!(\"content {}\", i));\n        // Vary similarity slightly\n        let sim = 0.9 - (i as f32 * 0.1);\n        embeddings.insert(filename, vec![sim, (1.0 - sim*sim).sqrt()]);\n    }\n\n    // Pass embeddings to setup\n    let (db, _temp_dir, _) = setup_mock_db_with_content(content_map, embeddings, dim, true); \n    let mut model = EmbeddingModel::new_mock(Box::new(mock_provider));\n    let mut snippet_extractor = SnippetExtractor::new();\n\n    let limit = 3;\n    let results = search_with_limit(\u0026db, \u0026mut model, \u0026mut snippet_extractor, \"query\", limit).unwrap();\n    assert_eq!(results.len(), limit, \"Number of results should be equal to the limit\");\n    // Verify descending order (highest similarity first)\n    assert!(results[0].similarity \u003e results[1].similarity);\n    assert!(results[1].similarity \u003e results[2].similarity);\n}\n\n#[test]\nfn test_vector_search_similarity_threshold() {\n    let dim = 2;\n    let mut mock_provider = MockEmbeddingModel::new(dim);\n    mock_provider.add_embedding(\"query\", vec![1.0, 0.0]);\n\n    let temp_dir = tempdir().unwrap();\n    let db_path = temp_dir.path().join(\"thresh_db.json\").to_string_lossy().to_string();\n    let cache_path = temp_dir.path().join(\"thresh_cache.json\").to_string_lossy().to_string();\n    let cache = EmbeddingCache::new(cache_path).unwrap();\n    let mut embeddings: HashMap\u003cString, Vec\u003cf32\u003e\u003e = HashMap::new();\n    embeddings.insert(\"high_sim.txt\".to_string(), vec![0.9, 0.435]);\n    embeddings.insert(\"low_sim.txt\".to_string(), vec![0.1, 0.995]);\n    embeddings.insert(\"medium_sim.txt\".to_string(), vec![0.5, 0.866]);\n    \n    let db = VectorDB::new_test(\n        db_path, \n        embeddings, \n        cache, \n        None,\n        EmbeddingModelType::Onnx\n    );\n\n    let mut model = EmbeddingModel::new_mock(Box::new(mock_provider));\n    let mut snippet_extractor = SnippetExtractor::new();\n\n    let results = search_with_limit(\u0026db, \u0026mut model, \u0026mut snippet_extractor, \"query\", 10).unwrap();\n    \n    assert!(results.iter().any(|r| r.file_path == \"high_sim.txt\"), \"High similarity file should be present\");\n    assert!(results.iter().any(|r| r.file_path == \"medium_sim.txt\"), \"Medium similarity file should be present\");\n    assert!(!results.iter().any(|r| r.file_path == \"low_sim.txt\"), \"Low similarity file should be filtered out by threshold\");\n    assert_eq!(results.len(), 2, \"Only results above threshold should remain\");\n}\n\n// --- BM25 Tests --- \n\n#[test]\nfn test_bm25_index_building() {\n    let mut content_map = HashMap::new();\n    content_map.insert(\"doc1.txt\".to_string(), \"the quick brown fox\".to_string());\n    content_map.insert(\"doc2.txt\".to_string(), \"jumps over the lazy fox\".to_string());\n    content_map.insert(\"doc3.txt\".to_string(), \"the lazy dog\".to_string());\n\n    // Pass an empty embeddings map\n    let empty_embeddings: HashMap\u003cString, Vec\u003cf32\u003e\u003e = HashMap::new();\n    let (_db, _temp_dir, db_path) = setup_mock_db_with_content(content_map.clone(), empty_embeddings.clone(), 4, false); \n    \n    let temp_path = _temp_dir.path();\n    let adjusted_embeddings = content_map.keys().map(|fname| {\n        let full_path = temp_path.join(fname).to_string_lossy().into_owned();\n        (full_path, vec![0.0; 4])\n    }).collect();\n    let cache_path = temp_path.join(\"bm25_cache.json\").to_string_lossy().to_string();\n    let cache = EmbeddingCache::new(cache_path).unwrap();\n    let db_for_bm25 = VectorDB::new_test(\n        db_path, \n        adjusted_embeddings,\n        cache,\n        None,\n        EmbeddingModelType::Onnx,\n    );\n\n    let bm25_result = build_bm25_index(\u0026db_for_bm25);\n    assert!(bm25_result.is_ok(), \"BM25 index build failed: {:?}\", bm25_result.err());\n    let bm25_index = bm25_result.unwrap();\n\n    assert_eq!(bm25_index.total_docs, 3);\n    assert_eq!(bm25_index.doc_data.len(), 3);\n    assert!(bm25_index.avg_doc_length \u003e 0.0);\n    assert!(bm25_index.idf.contains_key(\"fox\"));\n    assert!(bm25_index.idf.contains_key(\"lazy\"));\n    assert!(bm25_index.idf.contains_key(\"the\"));\n    assert!(bm25_index.idf[\"quick\"] \u003e bm25_index.idf[\"fox\"]);\n    assert!(bm25_index.idf[\"dog\"] \u003e bm25_index.idf[\"lazy\"]);\n    assert!(bm25_index.idf[\"lazy\"] \u003e bm25_index.idf[\"the\"]); \n}\n\n#[test]\nfn test_bm25_search() {\n    let mut content_map = HashMap::new();\n    content_map.insert(\"bm_doc1.txt\".to_string(), \"search algorithms are fun\".to_string());\n    content_map.insert(\"bm_doc2.txt\".to_string(), \"fun search index test\".to_string());\n    content_map.insert(\"bm_doc3.txt\".to_string(), \"another test document\".to_string());\n\n    // Pass an empty embeddings map\n    let empty_embeddings: HashMap\u003cString, Vec\u003cf32\u003e\u003e = HashMap::new();\n    let (_db, _temp_dir, db_path) = setup_mock_db_with_content(content_map.clone(), empty_embeddings.clone(), 4, false);\n    let temp_path = _temp_dir.path();\n    let adjusted_embeddings = content_map.keys().map(|fname| {\n        (temp_path.join(fname).to_string_lossy().into_owned(), vec![0.0; 4])\n    }).collect();\n    let cache_path = temp_path.join(\"bm25_s_cache.json\").to_string_lossy().to_string();\n    let cache = EmbeddingCache::new(cache_path).unwrap();\n    let db_for_bm25 = VectorDB::new_test(\n        db_path, adjusted_embeddings, cache, None, EmbeddingModelType::Onnx\n    );\n\n    let bm25_index = build_bm25_index(\u0026db_for_bm25).unwrap();\n\n    let results1 = search_bm25_top_k(\"fun search\", \u0026bm25_index, 10).unwrap();\n    assert_eq!(results1.len(), 2);\n    assert!(results1.iter().any(|(p, _)| p.ends_with(\"bm_doc1.txt\")), \"bm_doc1 should be present for 'fun search'\");\n    assert!(results1.iter().any(|(p, _)| p.ends_with(\"bm_doc2.txt\")), \"bm_doc2 should be present for 'fun search'\");\n    assert!(results1[0].1 \u003e= results1[1].1, \"Scores should be non-increasing for 'fun search'\"); \n\n    let results2 = search_bm25_top_k(\"algorithms\", \u0026bm25_index, 10).unwrap();\n    assert_eq!(results2.len(), 1);\n    assert!(results2[0].0.ends_with(\"bm_doc1.txt\"));\n\n    let results3 = search_bm25_top_k(\"test\", \u0026bm25_index, 10).unwrap();\n    assert_eq!(results3.len(), 2);\n    assert!(results3.iter().any(|(p, _)| p.ends_with(\"bm_doc2.txt\")), \"bm_doc2 should be present for 'test'\");\n    assert!(results3.iter().any(|(p, _)| p.ends_with(\"bm_doc3.txt\")), \"bm_doc3 should be present for 'test'\");\n    assert!(results3[0].1 \u003e= results3[1].1, \"Scores should be non-increasing for 'test'\");\n    \n    let results4 = search_bm25_top_k(\"\", \u0026bm25_index, 10).unwrap();\n    assert!(results4.is_empty());\n\n    let results5 = search_bm25_top_k(\"nonexistent term\", \u0026bm25_index, 10).unwrap();\n    assert!(results5.is_empty());\n}\n\n// TODO: Add test for specialized search threshold ","traces":[],"covered":0,"coverable":0},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","search","vector.rs"],"content":"use crate::vectordb::db::VectorDB;\nuse crate::vectordb::embedding::EmbeddingModel;\nuse log::{debug, warn, error};\nuse std::collections::HashSet;\nuse anyhow::anyhow;\nuse std::cmp::Ordering;\nuse super::result::SearchResult;\n\n/// Standard search using vector similarity with a limit on the number of results\npub(crate) fn search_with_limit(\n    db: \u0026VectorDB, // Pass db as reference\n    model: \u0026mut EmbeddingModel, // Pass model as mutable reference\n    query: \u0026str,\n    max_results: usize,\n) -\u003e anyhow::Result\u003cVec\u003cSearchResult\u003e\u003e {\n    debug!(\"Performing vector search for query: {}\", query);\n\n    // Validate query\n    if query.trim().is_empty() {\n        debug!(\"Empty query detected, returning empty results\");\n        return Ok(Vec::new());\n    }\n\n    // Convert the query to an embedding\n    debug!(\"Converting query to embedding vector\");\n    let query_embedding = model.embed(query).map_err(|e| anyhow!(e))?;\n    debug!(\"Generated embedding of dimension {}\", query_embedding.len());\n\n    let ef_search = 100; // Example, make configurable?\n    let hnsw_index = match db.hnsw_index() {\n        Some(index) =\u003e index,\n        None =\u003e {\n            warn!(\"Attempted search but HNSW index is not built.\");\n            return Ok(Vec::new()); // Return empty results if no index\n        }\n    };\n\n    let search_results = hnsw_index.search_parallel(\u0026query_embedding, max_results * 5, ef_search)?;\n\n    // Process results\n    let mut final_results: Vec\u003cSearchResult\u003e = Vec::with_capacity(search_results.len());\n    for (node_id, distance) in search_results {\n        let similarity = 1.0 - distance;\n        if similarity \u003c 0.0 { continue; } // Skip highly dissimilar results\n\n        // Retrieve chunk data using node_id\n        if let Some(chunk) = db.indexed_chunks.get(node_id) {\n             // Create a SearchResult \n             final_results.push(SearchResult {\n                 file_path: chunk.file_path.clone(),\n                 similarity, // Use the HNSW similarity\n                 // Optional: Add chunk info like start/end lines if SearchResult is adapted\n             });\n        } else {\n             error!(\"HNSW search returned invalid node ID: {}\", node_id);\n        }\n    }\n    \n    // Sort by similarity (descending)\n    final_results.sort_by(|a, b| b.similarity.partial_cmp(\u0026a.similarity).unwrap_or(Ordering::Equal));\n\n    // Deduplicate results by file path, keeping the one with the highest similarity\n    let mut unique_results = Vec::new();\n    let mut seen_files = HashSet::new();\n    for result in final_results {\n        if seen_files.insert(result.file_path.clone()) {\n            unique_results.push(result);\n        }\n    }\n    \n    // Apply the final limit\n    unique_results.truncate(max_results);\n    Ok(unique_results)\n\n    /* // Old logic using db.embeddings\n    let embeddings_map = \u0026db\n        .embeddings\n        .par_iter()\n        .filter(|(path, _)| {\n            // ... (file type filtering) ...\n        })\n        .map(|(path, embedding)| (path.clone(), embedding))\n        .collect::\u003cHashMap\u003c_, _\u003e\u003e();\n\n    if embeddings_map.is_empty() {\n        return Ok(vec![]);\n    }\n\n    let mut results: Vec\u003cSearchResult\u003e = embeddings_map\n        .par_iter()\n        .map(|(path, embedding)| {\n            let similarity = 1.0 - crate::vectordb::utils::cosine_distance(\u0026query_embedding, embedding);\n            SearchResult {\n                file_path: path.clone(),\n                similarity,\n            }\n        })\n        .collect();\n    results.sort_by(|a, b| b.similarity.partial_cmp(\u0026a.similarity).unwrap_or(Ordering::Equal));\n    results.truncate(limit);\n    Ok(results)\n    */\n} ","traces":[{"line":10,"address":[2826923,2827645,2823248],"length":1,"stats":{"Line":0}},{"line":16,"address":[2823347,2823489,2823635],"length":1,"stats":{"Line":0}},{"line":19,"address":[2823416],"length":1,"stats":{"Line":0}},{"line":20,"address":[2827747,2823849],"length":1,"stats":{"Line":0}},{"line":21,"address":[2827658],"length":1,"stats":{"Line":0}},{"line":25,"address":[2824046,2823806],"length":1,"stats":{"Line":0}},{"line":26,"address":[2938240,2938247],"length":1,"stats":{"Line":0}},{"line":27,"address":[2824497,2824280,2824417,2824704],"length":1,"stats":{"Line":0}},{"line":29,"address":[4167847],"length":1,"stats":{"Line":0}},{"line":30,"address":[2824431,2824891],"length":1,"stats":{"Line":0}},{"line":31,"address":[2824973],"length":1,"stats":{"Line":0}},{"line":33,"address":[2825038,2825110,2824928],"length":1,"stats":{"Line":0}},{"line":34,"address":[2825052,2825316],"length":1,"stats":{"Line":0}},{"line":38,"address":[2825624,2825378,2825005],"length":1,"stats":{"Line":0}},{"line":41,"address":[2825604,2825703],"length":1,"stats":{"Line":0}},{"line":42,"address":[2825964,2825837,2825990,2825733],"length":1,"stats":{"Line":0}},{"line":43,"address":[4170536],"length":1,"stats":{"Line":0}},{"line":44,"address":[2826051],"length":1,"stats":{"Line":0}},{"line":47,"address":[2826958],"length":1,"stats":{"Line":0}},{"line":49,"address":[2827130],"length":1,"stats":{"Line":0}},{"line":50,"address":[2827063],"length":1,"stats":{"Line":0}},{"line":55,"address":[2827261,2827423,2827082,2827210],"length":1,"stats":{"Line":0}},{"line":60,"address":[2826076],"length":1,"stats":{"Line":0}},{"line":63,"address":[2826118],"length":1,"stats":{"Line":0}},{"line":64,"address":[2826125],"length":1,"stats":{"Line":0}},{"line":65,"address":[2826474,2826193,2826297,2826424,2826885],"length":1,"stats":{"Line":0}},{"line":66,"address":[2826514,2826752],"length":1,"stats":{"Line":0}},{"line":67,"address":[2826805],"length":1,"stats":{"Line":0}},{"line":72,"address":[2826560],"length":1,"stats":{"Line":0}},{"line":73,"address":[2826575],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":30},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","snippet_extractor.rs"],"content":"use anyhow::Result;\n// Removed unused import\n// use regex::Regex;\nuse std::fs;\nuse std::path::Path;\n// use super::code_structure::{CodeStructureAnalyzer, CodeContext, MethodInfo, TypeInfo};\n\nconst DEFAULT_CONTEXT_LINES: usize = 5;\n\n/// Structure to hold context information for a code snippet\n#[derive(Debug, Clone)]\npub struct SnippetContext {\n    pub snippet_text: String,\n    // Removed unused fields\n    // pub start_line: usize,\n    // pub end_line: usize,\n    // pub file_path: String,\n    // pub is_definition: bool,\n    // pub is_usage: bool,\n}\n\n/// Simple snippet extractor based on content matching\npub struct SnippetExtractor {}\n\nimpl SnippetExtractor {\n    pub fn new() -\u003e Self {\n        Self {}\n    }\n    \n    /// Extract a relevant snippet from a file based on the query\n    // Note: This now only uses content-based extraction\n    pub fn extract_snippet(\u0026mut self, file_path: \u0026str, query: \u0026str) -\u003e Result\u003cSnippetContext\u003e {\n        let path = Path::new(file_path);\n        if !path.exists() {\n            return Err(anyhow::anyhow!(\"File does not exist: {}\", file_path));\n        }\n        \n        // Read file content\n        let content = fs::read_to_string(path)?;\n        \n        // Find the most relevant code section using query terms\n        let query_terms: Vec\u003cString\u003e = query\n            .to_lowercase()\n            .split_whitespace()\n            .map(|s| s.to_string())\n            .collect();\n        \n        // Use content-based matching directly\n        self.extract_content_based_snippet(\u0026content, file_path, \u0026query_terms)\n    }\n    \n    // Fallback snippet extraction based on query term location\n    fn extract_content_based_snippet(\u0026self, content: \u0026str, _file_path: \u0026str, query_terms: \u0026[String]) -\u003e Result\u003cSnippetContext\u003e {\n        let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n        if lines.is_empty() {\n            return Ok(SnippetContext {\n                snippet_text: \"\".to_string(),\n                // Fields removed\n            });\n        }\n\n        // Find the line with the highest score based on query terms\n        let mut best_line_index = 0;\n        let mut max_score = 0.0;\n\n        for (i, line) in lines.iter().enumerate() {\n            let score = Self::calculate_line_score(line, query_terms);\n            if score \u003e max_score {\n                max_score = score;\n                best_line_index = i;\n            }\n        }\n\n        // Calculate context window around the best line\n        let start_context = best_line_index.saturating_sub(DEFAULT_CONTEXT_LINES);\n        let end_context = (best_line_index + DEFAULT_CONTEXT_LINES + 1).min(lines.len());\n\n        let snippet_start_line = start_context;\n        let snippet_end_line = end_context;\n\n        // Build the snippet text\n        let mut snippet = String::new();\n        if snippet_start_line \u003e 0 {\n            snippet.push_str(\"... (truncated above)\\n\");\n        }\n        for i in snippet_start_line..snippet_end_line {\n            snippet.push_str(\u0026format!(\"{}: {}\\n\", i + 1, lines[i]));\n        }\n        if snippet_end_line \u003c lines.len() {\n            snippet.push_str(\"... (truncated below)\\n\");\n        }\n\n        Ok(SnippetContext {\n            snippet_text: snippet,\n            // Fields removed\n        })\n    }\n\n    /// Calculate a relevance score for a line based on query terms\n    fn calculate_line_score(line: \u0026str, query_terms: \u0026[String]) -\u003e f32 {\n        let line_lower = line.to_lowercase();\n        let mut score = 0.0;\n\n        for term in query_terms {\n            if line_lower.contains(term) {\n                score += 1.0;\n                // Bonus for exact word match\n                if line_lower.split_whitespace().any(|word| word == term.as_str()) {\n                    score += 1.0;\n                }\n            }\n        }\n\n        // Normalize score by line length (prefer shorter lines with matches)\n        if !line.is_empty() {\n            score / (line.len() as f32).sqrt()\n        } else {\n            0.0\n        }\n    }\n    \n    // Removed unused method highlight_snippet\n\n    // Removed structure-aware methods: extract_method_snippet, extract_type_snippet,\n    // find_matching_method, find_matching_type, extract_method_usage_snippet, clear_cache\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Removed test test_highlight_snippet\n    \n    // Helper to create a temporary file with content\n    fn create_temp_file(content: \u0026str) -\u003e tempfile::NamedTempFile {\n        use std::io::Write;\n        let mut file = tempfile::NamedTempFile::new().unwrap();\n        file.write_all(content.as_bytes()).unwrap();\n        file\n    }\n\n    #[test]\n    fn test_extract_content_based_snippet() -\u003e Result\u003c()\u003e {\n        let content = \"Line 1\\nLine 2: Important keyword\\nLine 3\\nLine 4: Another important thing\\nLine 5\";\n        let file = create_temp_file(content);\n        let mut extractor = SnippetExtractor::new();\n        \n        // Test with a specific keyword\n        let snippet_context = extractor.extract_snippet(file.path().to_str().unwrap(), \"keyword\")?;\n        assert!(snippet_context.snippet_text.contains(\"Line 2: Important keyword\"));\n        // Removed assertions using removed fields\n        // assert!(snippet_context.start_line \u003c= 2 \u0026\u0026 snippet_context.end_line \u003e= 2);\n        println!(\"Snippet for 'keyword':\\n{}\", snippet_context.snippet_text);\n\n        // Test with another keyword\n        let snippet_context_2 = extractor.extract_snippet(file.path().to_str().unwrap(), \"thing\")?;\n        assert!(snippet_context_2.snippet_text.contains(\"Line 4: Another important thing\"));\n        // Removed assertions using removed fields\n        // assert!(snippet_context_2.start_line \u003c= 4 \u0026\u0026 snippet_context_2.end_line \u003e= 4);\n        println!(\"Snippet for 'thing':\\n{}\", snippet_context_2.snippet_text);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_extract_from_empty_file() -\u003e Result\u003c()\u003e {\n        let content = \"\";\n        let file = create_temp_file(content);\n        let mut extractor = SnippetExtractor::new();\n        let snippet_context = extractor.extract_snippet(file.path().to_str().unwrap(), \"anything\")?;\n        assert!(snippet_context.snippet_text.is_empty());\n        // Removed assertions using removed fields\n        // assert_eq!(snippet_context.start_line, 1);\n        // assert_eq!(snippet_context.end_line, 1);\n        Ok(())\n    }\n}\n","traces":[{"line":32,"address":[4160384,4161461],"length":1,"stats":{"Line":2}},{"line":33,"address":[4123720],"length":1,"stats":{"Line":3}},{"line":34,"address":[4123780],"length":1,"stats":{"Line":3}},{"line":35,"address":[4160639,4160769],"length":1,"stats":{"Line":0}},{"line":39,"address":[3347626,3347809,3347721],"length":1,"stats":{"Line":6}},{"line":42,"address":[3347894,3347785,3347970],"length":1,"stats":{"Line":9}},{"line":45,"address":[3846480,3846533],"length":1,"stats":{"Line":6}},{"line":49,"address":[3348094],"length":1,"stats":{"Line":3}},{"line":53,"address":[4163657,4163470,4161488],"length":1,"stats":{"Line":3}},{"line":54,"address":[4161672],"length":1,"stats":{"Line":3}},{"line":55,"address":[3348514,3348583],"length":1,"stats":{"Line":6}},{"line":56,"address":[4126839],"length":1,"stats":{"Line":2}},{"line":57,"address":[4161864],"length":1,"stats":{"Line":2}},{"line":63,"address":[4125073],"length":1,"stats":{"Line":2}},{"line":64,"address":[4125085],"length":1,"stats":{"Line":2}},{"line":66,"address":[4125096,4125174,4125487],"length":1,"stats":{"Line":6}},{"line":67,"address":[4126772,4125524],"length":1,"stats":{"Line":4}},{"line":68,"address":[3350297,3350342],"length":1,"stats":{"Line":4}},{"line":69,"address":[4163525],"length":1,"stats":{"Line":2}},{"line":70,"address":[4126818],"length":1,"stats":{"Line":2}},{"line":75,"address":[4125407,4125558],"length":1,"stats":{"Line":4}},{"line":76,"address":[4162282],"length":1,"stats":{"Line":2}},{"line":82,"address":[4125718],"length":1,"stats":{"Line":2}},{"line":83,"address":[4162449],"length":1,"stats":{"Line":2}},{"line":84,"address":[3349289,3349360],"length":1,"stats":{"Line":0}},{"line":86,"address":[3349268,3349478,3349372],"length":1,"stats":{"Line":6}},{"line":87,"address":[4126646,4125983,4126353,4126233,4126501],"length":1,"stats":{"Line":8}},{"line":89,"address":[4126016,4125938],"length":1,"stats":{"Line":4}},{"line":90,"address":[3349696],"length":1,"stats":{"Line":0}},{"line":93,"address":[3349597],"length":1,"stats":{"Line":2}},{"line":94,"address":[3349549],"length":1,"stats":{"Line":2}},{"line":100,"address":[4126960,4127698],"length":1,"stats":{"Line":2}},{"line":101,"address":[3350548],"length":1,"stats":{"Line":2}},{"line":102,"address":[4127055],"length":1,"stats":{"Line":2}},{"line":104,"address":[4127153,4127066,4127256],"length":1,"stats":{"Line":6}},{"line":105,"address":[3351034,3350801],"length":1,"stats":{"Line":4}},{"line":106,"address":[4127546],"length":1,"stats":{"Line":2}},{"line":108,"address":[3351205,3351100],"length":1,"stats":{"Line":8}},{"line":109,"address":[4127667],"length":1,"stats":{"Line":2}},{"line":115,"address":[4127309,4127364,4127245],"length":1,"stats":{"Line":4}},{"line":116,"address":[4127371,4127325],"length":1,"stats":{"Line":4}},{"line":118,"address":[4127352],"length":1,"stats":{"Line":0}}],"covered":38,"coverable":42},{"path":["/","home","adam","repos","vectordb-cli","src","vectordb","utils.rs"],"content":"/// Calculate cosine distance between two vectors (range 0.0 to 2.0)\n/// Higher values mean less similarity.\npub fn cosine_distance(a: \u0026[f32], b: \u0026[f32]) -\u003e f32 {\n    let dot_product: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();\n    let norm_a: f32 = a.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n    let norm_b: f32 = b.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n\n    // Handle zero vectors to avoid division by zero and return max distance\n    if norm_a == 0.0 || norm_b == 0.0 {\n        return 2.0; // Max distance for cosine similarity interpretation (1.0 - (-1.0))\n    }\n\n    // Calculate cosine similarity\n    let similarity = dot_product / (norm_a * norm_b);\n\n    // Clamp similarity to [-1.0, 1.0] to handle potential floating point inaccuracies\n    let clamped_similarity = similarity.clamp(-1.0, 1.0);\n\n    // Convert similarity to distance: distance = 1.0 - similarity\n    1.0 - clamped_similarity\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_cosine_distance_basic() {\n        let vec1 = vec![1.0, 0.0, 0.0];\n        let vec2 = vec![1.0, 0.0, 0.0];\n        let vec3 = vec![0.0, 1.0, 0.0];\n        let vec4 = vec![-1.0, 0.0, 0.0];\n        let vec5 = vec![0.0, 0.0, 0.0];\n\n        // Use approximate comparison for floating point results\n        assert!((cosine_distance(\u0026vec1, \u0026vec2) - 0.0).abs() \u003c 1e-6);\n        assert!((cosine_distance(\u0026vec1, \u0026vec3) - 1.0).abs() \u003c 1e-6); // Orthogonal\n        assert!((cosine_distance(\u0026vec1, \u0026vec4) - 2.0).abs() \u003c 1e-6); // Opposite\n        assert!((cosine_distance(\u0026vec1, \u0026vec5) - 2.0).abs() \u003c 1e-6); // Zero vector\n        assert!((cosine_distance(\u0026vec5, \u0026vec5) - 2.0).abs() \u003c 1e-6); // Zero vector\n    }\n\n    #[test]\n    fn test_cosine_distance_non_unit() {\n        let vec1 = vec![2.0, 0.0];\n        let vec2 = vec![4.0, 0.0];\n        let vec3 = vec![0.0, 3.0];\n        assert!(cosine_distance(\u0026vec1, \u0026vec2) \u003c 1e-6);\n        assert!((cosine_distance(\u0026vec1, \u0026vec3) - 1.0).abs() \u003c 1e-6);\n    }\n\n    // Remove the near_normalized test as it's covered by non_unit\n    // #[test]\n    // fn test_cosine_distance_near_normalized() { ... }\n\n} ","traces":[{"line":3,"address":[3440688],"length":1,"stats":{"Line":2}},{"line":4,"address":[3582891,3582848],"length":1,"stats":{"Line":7}},{"line":5,"address":[3440861],"length":1,"stats":{"Line":9}},{"line":6,"address":[3582976,3582990],"length":1,"stats":{"Line":9}},{"line":9,"address":[3440976],"length":1,"stats":{"Line":3}},{"line":10,"address":[3441004],"length":1,"stats":{"Line":2}},{"line":14,"address":[3441038],"length":1,"stats":{"Line":3}},{"line":17,"address":[3441055],"length":1,"stats":{"Line":3}},{"line":20,"address":[3441088],"length":1,"stats":{"Line":3}}],"covered":9,"coverable":9}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>