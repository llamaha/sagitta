# Multi-Tenancy with API Keys in Vectordb-MCP

## 1. Overview

This document explains the multi-tenancy model implemented in the Vectordb-MCP (Master Control Program) server, focusing on API key-based authentication and data isolation.

In this model:
- Each API key is uniquely associated with a `tenant_id`.
- All operations performed using an API key (e.g., repository synchronization, queries, tool usage) are automatically and strictly isolated to the data and resources belonging to that API key's `tenant_id`.
- Data isolation is primarily achieved by namespacing Qdrant collections with the `tenant_id` (e.g., `{tenant_id}_{repo_name}`).

## 2. Prerequisites

- A running instance of the Vectordb-MCP server.
- Administrative access or an administrative API key with permissions to manage tenants and API keys (details on admin scopes to be refined).

## 3. Setting Up Tenants

Logical tenants must be created in the system before API keys can be associated with them. This is typically an administrative task.

**Endpoint:** `POST /api/v1/tenants`

**Request Body:**
```json
{
  \"name\": \"your-tenant-name\"
}
```
- `name`: A human-readable name for the tenant (e.g., "acme-corp", "research-dept-alpha").

**Example Request:**
```bash
curl -X POST http://localhost:8080/api/v1/tenants \\
     -H \"Content-Type: application/json\" \\
     -H \"X-Admin-API-Key: <your_admin_key_if_required>\" \\
     -d \'{
           \"name\": \"acme-corp\"
         }\'
```

**Example Response (Success: 201 Created):**
```json
{
  \"id\": \"a7b2c3d4-e5f6-7890-1234-567890abcdef\", // Unique tenant ID generated by the system
  \"name\": \"acme-corp\",
  \"status\": \"Active\", // Default status
  \"created_at\": 1678886400,
  \"updated_at\": 1678886400,
  \"metadata\": {}
}
```
Take note of the returned `id`; this is the `tenant_id` you will use when creating API keys for this tenant.

## 4. Managing API Keys

Once a tenant exists, API keys can be created for it. These keys will grant access to that tenant's resources.

### 4.1. Creating an API Key

**Endpoint:** `POST /api/v1/keys`

**Request Body:**
```json
{
  \"tenant_id\": \"<tenant_id_for_association>\",
  \"description\": \"Optional description for the key\",
  \"user_id\": \"optional_user_identifier\", 
  \"scopes\": [], // Currently deferred, pass an empty array
  \"expires_at\": null // Optional: Unix timestamp for expiration, or null/omit for no expiry
}
```
- **`tenant_id` (Mandatory):** The unique ID of the tenant this API key will be associated with. This is retrieved from the tenant creation step.
- `description`: A human-readable description for the API key (e.g., "Analytics service key for Project X").
- `user_id` (Optional): An optional identifier for a user within the tenant, if applicable.
- `scopes` (Deferred): Currently, granular scopes are not implemented. Pass an empty array `[]`. An API key grants access to all supported operations for its associated tenant.
- `expires_at` (Optional): A Unix timestamp (seconds since epoch) indicating when the key should expire. If `null` or omitted, the key does not expire.

**Example Request:**
```bash
curl -X POST http://localhost:8080/api/v1/keys \\
     -H \"Content-Type: application/json\" \\
     -H \"X-Admin-API-Key: <your_admin_key_if_required>\" \\
     -d \'{
           \"tenant_id\": \"a7b2c3d4-e5f6-7890-1234-567890abcdef\",
           \"description\": \"Primary API key for acme-corp operations\"
         }\'
```

**Example Response (Success: 201 Created):**
```json
{
  \"id\": \"key_abc123xyz789\", // The ID of the ApiKey entity
  \"key\": \"vdb_sk_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", // The actual API key value. Copy this immediately and store it securely. It will not be shown again.
  \"tenant_id\": \"a7b2c3d4-e5f6-7890-1234-567890abcdef\",
  \"user_id\": null,
  \"description\": \"Primary API key for acme-corp operations\",
  \"created_at\": 1678886500,
  \"expires_at\": null,
  \"last_used_at\": null,
  \"scopes\": [],
  \"revoked\": false,
  \"key_preview\": \"vdb_sk_xxxx\" 
}
```
**Important:** The `key` field in the response contains the actual API key value (e.g., `vdb_sk_...`). This value is shown **only once** upon creation. Copy it immediately and store it securely.

### 4.2. Listing API Keys

**Endpoint:** `GET /api/v1/keys`

This endpoint can be used to list API keys. For administrative purposes, it might list all keys or be filterable by `tenant_id`. For tenant users, it would typically be restricted to keys within their own tenant. (Access control details to be refined).

**Example Request (Admin):**
```bash
curl -X GET http://localhost:8080/api/v1/keys?tenant_id=a7b2c3d4-e5f6-7890-1234-567890abcdef \\
     -H \"X-Admin-API-Key: <your_admin_key_if_required>\"
```

**Example Response:**
```json
{
  \"api_keys\": [
    {
      \"id\": \"key_abc123xyz789\",
      \"tenant_id\": \"a7b2c3d4-e5f6-7890-1234-567890abcdef\",
      \"user_id\": null,
      \"description\": \"Primary API key for acme-corp operations\",
      \"created_at\": 1678886500,
      \"expires_at\": null,
      \"last_used_at\": null,
      \"scopes\": [],
      \"revoked\": false,
      \"key_preview\": \"vdb_sk_xxxx\"
    }
    // ... other keys
  ]
}
```
Note: The full API key value is not returned when listing keys, only a preview.

### 4.3. Revoking an API Key

**Endpoint:** `DELETE /api/v1/keys/{key_id}`

This endpoint revokes an API key, making it invalid for future use.

**Example Request:**
```bash
curl -X DELETE http://localhost:8080/api/v1/keys/key_abc123xyz789 \\
     -H \"X-Admin-API-Key: <your_admin_key_if_required_or_key_with_permission>\"
```

**Expected Response (Success):** `204 No Content`

## 5. Using API Keys for Operations

To use an API key for operations like repository synchronization, querying, or using tools, include it in the `X-API-Key` header of your HTTP requests to the MCP server.

**Header:**
`X-API-Key: <your_api_key_value>`

**Example (Querying a repository):**
Assume an API key `vdb_sk_xxxxxxxxxxxx` is associated with `tenant_id: "acme-corp"`.
A repository named `my-codebase` has been added for this tenant.

```bash
curl -X POST http://localhost:8080/mcp \\
     -H \"Content-Type: application/json\" \\
     -H \"X-API-Key: vdb_sk_xxxxxxxxxxxx\" \\
     -d \'{
           \"jsonrpc\": \"2.0\",
           \"method\": \"query\",
           \"params\": {
             \"repositoryName\": \"my-codebase\",
             \"queryText\": \"How is authentication handled?\"
           },
           \"id\": 1
         }\'
```
The MCP server, upon validating the API key, will extract `tenant_id: "acme-corp"`. The query will automatically be directed to the Qdrant collection named `acme-corp_my-codebase`. The user does not need to (and should not) specify the `tenant_id` in the MCP operation parameters if using API key authentication.

## 6. Data Isolation & Qdrant Collections

Data isolation is enforced by naming Qdrant collections using a combination of the `tenant_id` and the repository name. The convention is:
`{tenant_id}_{repo_name}`

For example, if `tenant_id` is `acme-corp` and the repository name is `web-app`, the corresponding Qdrant collection will be `acme-corp_web-app`. The MCP handlers, guided by the `tenant_id` from the `AuthenticatedUser` (derived from the API key), ensure that all Qdrant operations target the correctly namespaced collection.

## 7. Current Status of OAuth and Multi-Tenancy

Currently, when users authenticate via OAuth, their `AuthenticatedUser` object in the MCP server is assigned a placeholder `tenant_id` (e.g., `"oauth_placeholder_tenant"`).

This means:
- OAuth users are not yet meaningfully associated with the tenant model described above.
- They cannot, by default, access repositories or data belonging to specific tenants (e.g., "acme-corp").
- True multi-tenancy for OAuth users (such as mapping OAuth identities to specific tenants, allowing OAuth users to operate within a tenant context, or managing cross-tenant access for OAuth users) is **not yet implemented** and is planned for future work.

The current API key-based multi-tenancy provides a robust way for distinct services or user groups (represented by tenants) to have their data and operations isolated.

## 8. (Advanced) Note on "Global" Repositories

Repositories can technically be configured in the MCP server without a `tenant_id` (i.e., `tenant_id: null` or `tenant_id` field omitted in their `RepositoryConfig`). These can be considered "global" or "un-tenanted" repositories.

- **API Key Access:** Users authenticating with an API key *always* have a specific `tenant_id` string associated with their `AuthenticatedUser` profile (due to recent changes where `AuthenticatedUser.tenant_id` is a non-optional `String`).
    - For an API key user to access a global repository, their `tenant_id` string would need to match a special, conventional string that signifies "global access". Currently, the system does not have a universally defined production string for this. The tenant isolation logic primarily expects specific tenant ID matches.
    - The `GLOBAL_USER_TENANT_PLACEHOLDER` string is used *within tests* to simulate a global user, and handlers have been adapted to allow this placeholder to access global repos in tests. This is a test-specific mechanism.
- **OAuth Access:** As mentioned, OAuth users get a placeholder tenant ID. Their access to global repositories would depend on how this placeholder is treated by the access control logic (currently, they would likely be denied unless the global repo was misconfigured with the OAuth placeholder as its tenant).

**In general, the primary and recommended model is for tenanted API keys to access repositories specifically assigned to that same tenant.** Interactions with global repositories by tenanted users are not the standard operational mode. 

## 9. CORS, Credentials, and Client Integration

### 9.1. What is CORS and When Does it Matter?

CORS (Cross-Origin Resource Sharing) is a browser security feature that controls which web pages (origins) are allowed to make HTTP requests to your MCP server. CORS **only applies to requests made from browsers** (JavaScript running in a web page). If your client is a CLI, script, or coding agent running outside the browser, CORS does not apply.

### 9.2. What is a "Frontend" or "Client"?

In this context, "frontend" or "client" refers to **any application or tool that makes HTTP requests to the MCP server**. This could be:
- A web application running in a browser (e.g., React, Next.js, Vite, etc.)
- A local script, CLI, or coding agent
- Another backend service or integration

CORS settings are only relevant for browser-based clients. For CLI, scripts, or backend integrations, CORS settings do not affect connectivity.

### 9.3. Configuring CORS for MCP

The MCP server supports two main CORS-related configuration options in `config.toml`:
- `cors_allowed_origins`: A list of allowed origins (URLs) that can access the MCP server. **This should be set to the URL(s) of your browser-based client(s), not the MCP server itself.**
- `cors_allow_credentials`: Whether to allow credentials (cookies, HTTP authentication, or custom headers like API keys) to be sent with requests. This should be `true` if you want to allow API keys in headers from browser-based clients.

#### Example: Browser-based Client (e.g., React app on localhost:3000)
```toml
cors_allow_credentials = true
cors_allowed_origins = ["http://localhost:3000"]
```
- This allows a web app running at `http://localhost:3000` to make authenticated requests to the MCP server.
- If you deploy your frontend elsewhere, update the origin accordingly (e.g., `https://mycompany.com`).

#### Example: CLI, Script, or Coding Agent (Non-browser Client)
```toml
cors_allow_credentials = false
# cors_allowed_origins can be omitted or set to any value; it does not affect non-browser clients.
```
- For non-browser clients, CORS settings do not matter. You can safely disable credentials and omit allowed origins.

### 9.4. Security Restrictions: Why Wildcards Are Not Allowed with Credentials

When `cors_allow_credentials = true`, you **cannot** use wildcards (`*`) for allowed origins, methods, or headers. This is enforced by both browser security standards and the MCP server's HTTP framework. You must explicitly list the allowed origins, methods, and headers.

- If you set `cors_allow_credentials = true`, you must set `cors_allowed_origins` to at least one explicit origin (not `*`).
- If you set `cors_allow_credentials = false`, you may use wildcards, but this is only useful for public, unauthenticated APIs.

### 9.5. Summary Table
| Client Type         | cors_allow_credentials | cors_allowed_origins           | Notes                                      |
|--------------------|-----------------------|-------------------------------|--------------------------------------------|
| Browser (Web App)  | true                  | ["http://localhost:3000"]      | Must match the web app's URL               |
| CLI/Script/Agent   | false                 | (any or omitted)               | CORS does not apply                        |
| Public API         | false                 | ["*"] or omitted               | Not recommended for authenticated endpoints |

### 9.6. Troubleshooting
- If you see errors like `Invalid CORS configuration: Cannot combine Access-Control-Allow-Credentials: true with Access-Control-Allow-Origin: *`, update your config to use explicit origins.
- If you are not using a browser-based client, you can disable CORS entirely by setting `cors_allow_credentials = false` and omitting `cors_allowed_origins`.

---

This section ensures that all users understand how to configure and troubleshoot CORS and credential settings for their specific integration scenario with Vectordb-MCP. 