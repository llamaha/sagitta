//! Model types and definitions for the Sagitta embedding engine.

pub mod types;

use crate::error::Result;
use crate::provider::EmbeddingProvider;
use serde::{Deserialize, Serialize};
use std::fmt;
use std::path::PathBuf;
use std::sync::Arc;

/// Enum representing the type of embedding model to use.
#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum EmbeddingModelType {
    #[default]
    /// Use the default embedding model (currently ONNX). Identical to `Onnx`.
    Default,
    /// Use an ONNX-based embedding model.
    Onnx,
    // Add other types later
}

impl EmbeddingModelType {
    /// Get the expected dimension for the model type.
    pub fn dimension(&self) -> usize {
        match self {
            EmbeddingModelType::Onnx => 384,
            EmbeddingModelType::Default => 384, // Use default dimension for now
            // Add other model types here
        }
    }
}

impl fmt::Display for EmbeddingModelType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            EmbeddingModelType::Onnx => write!(f, "ONNX"),
            EmbeddingModelType::Default => write!(f, "Default"),
        }
    }
}

/// Represents an embedding model with its provider and metadata.
#[derive(Clone, Debug)]
pub struct EmbeddingModel {
    provider: Arc<dyn EmbeddingProvider + Send + Sync>,
    model_type: EmbeddingModelType,
    #[allow(dead_code)] // Allow dead code for now, may be used for identification/debugging
    onnx_model_path: Option<PathBuf>,
    #[allow(dead_code)] // Allow dead code for now, may be used for identification/debugging
    onnx_tokenizer_path: Option<PathBuf>,
    tenant_id: Option<String>,
}

impl EmbeddingModel {
    /// Creates a new EmbeddingModel with the given provider.
    pub fn new(
        provider: Arc<dyn EmbeddingProvider + Send + Sync>,
        model_type: EmbeddingModelType,
    ) -> Self {
        Self {
            provider,
            model_type,
            onnx_model_path: None,
            onnx_tokenizer_path: None,
            tenant_id: None,
        }
    }

    /// Creates a new ONNX-based EmbeddingModel.
    #[cfg(feature = "onnx")]
    pub fn new_onnx<P: AsRef<std::path::Path>>(
        model_path: P,
        tokenizer_path: P,
    ) -> Result<Self> {
        use crate::provider::onnx::OnnxEmbeddingModel;
        
        let onnx_provider = OnnxEmbeddingModel::new(
            model_path.as_ref(),
            tokenizer_path.as_ref(),
        )?;

        Ok(Self {
            provider: Arc::new(onnx_provider),
            model_type: EmbeddingModelType::Onnx,
            onnx_model_path: Some(model_path.as_ref().to_path_buf()),
            onnx_tokenizer_path: Some(tokenizer_path.as_ref().to_path_buf()),
            tenant_id: None,
        })
    }

    /// Get the type of the embedding model.
    pub fn get_type(&self) -> EmbeddingModelType {
        self.model_type.clone()
    }

    /// Get the dimensions of the embeddings generated by this model.
    pub fn dim(&self) -> usize {
        self.provider.dimension()
    }

    /// Generates embeddings for a batch of texts.
    pub fn embed_batch(&self, texts: &[&str]) -> Result<Vec<Vec<f32>>> {
        self.provider.embed_batch(texts)
    }

    /// Set the tenant ID for this model.
    pub fn with_tenant_id<S: Into<String>>(mut self, tenant_id: S) -> Self {
        self.tenant_id = Some(tenant_id.into());
        self
    }

    /// Get the tenant ID for this model.
    pub fn tenant_id(&self) -> Option<&str> {
        self.tenant_id.as_deref()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_embedding_model_type_display() {
        assert_eq!(EmbeddingModelType::Onnx.to_string(), "ONNX");
        assert_eq!(EmbeddingModelType::Default.to_string(), "Default");
    }

    #[test]
    fn test_embedding_model_type_dimension() {
        assert_eq!(EmbeddingModelType::Onnx.dimension(), 384);
        assert_eq!(EmbeddingModelType::Default.dimension(), 384);
    }

    #[test]
    fn test_embedding_model_type_default() {
        let default_type = EmbeddingModelType::default();
        assert_eq!(default_type, EmbeddingModelType::Default);
    }
} 